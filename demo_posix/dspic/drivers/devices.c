/***************************************************************************************
 * File: 			devices.c
 * Description:		file access using posix
 ***************************************************************************************/

#include <define.h>
#include <errno.h>

/****************************************************************************************
 * Name:        int open(const char *pathname, int flags)
 * 
 * Function:    get the device ready
 *              +-- all devices can be open with O_RDWR/O_RDONLY/O_WRONLY except 
 *              +-- ADC can only be opened for O_RDONLY mode
 *              +-- PWM can be opened with all mode, but only write operation is supported
 *              +-- when I2C EEPROM is in NON-BLOCKING mode, application can only write 
 *                  upto 64 bytes at a time to eeprom
 * 
 * Input:       pathname: (= device BASE (e.g. "0") + sub-item)
 *              flags: accessing mode
 * 
 * Output:      file descriptor: 0 - 9
 *              -1: when error occur, sub-functions should set errno appropricately
 * 
 ****************************************************************************************/
int open(const char *pathname, int flags)
{
    int tmp;
    tmp = *pathname - 0x30;		// only support 10 devices, from 0x30 to 0x39

#if (UART_MOD>0)
    /*
     * UART
     */
    if (tmp<(BASE_UART + NO_OF_UART))
    {
        return (uart_open(tmp - BASE_UART, flags) == 0)? tmp : -1;
    }
#endif

#if (I2C_MOD>0)
    /*
     * I2C
     */
    #if (I2C_DAC_MOD>0) 
        /*
         * I2C DAC
         */
    	if (tmp==BASE_I2C)
    	{
    		return (i2c_dac_open(flags) == 0)? tmp : -1;
    	}
    #endif
	
    #if (I2C_EEPROM_MOD>0)
        /*
         * I2C EEPROM
         */
    	if (tmp==BASE_I2C + 1)
    	{
    		return (i2c_eeprom_open(flags) == 0)? tmp : -1;
    	}
	#endif
	
#endif
    
#if (ADC_MOD>0)
    /*
     * ADC
     */
	if (tmp==BASE_ADC)
	{
		return (adc_open(flags) == 0)? tmp : -1;
	}
#endif

#ifdef MPLAB_DSPIC30_PORT
#if (EEPROM_MOD>0)
    /*
     * EEPROM (dsPic30 only)
	 */
	if (tmp==BASE_EEPROM)
	{
        // open eeprom module, 1Kbyte as a single file
		return (eeprom_open(flags) == 0)? tmp : -1;				
	}
#endif
#endif

#if (PWM_MOD>0)
    /*
     * PWM
     */
	if (tmp==BASE_PWM)
	{
		return (pwm_open(flags) == 0)? tmp : -1;
	}
#endif

#if (KB_MOD>0)
    /*
     * KB
     */
    if (tmp==BASE_KB)
    {
        return (gpio_open(flags) == 0)? tmp : -1;
    }
#endif

#if (ETHERNET_MOD>0)
    /*
     * ETHERNET
     */
    if (tmp==BASE_ETHERNET)
    {
        return (dmfe_open(flags) == 0)? tmp : -1;
    }
#endif

    errno = ENXIO;
	return -1;
}

/****************************************************************************************
 * Name:        int write(int fd, void* buf, int count)
 * 
 * Function:    write $count bytes from $buf to device
 * 
 * Input:       fd: file descriptor generated by open()
 *              buf: buffer which contains data to write out
 *              count: length of data (in bytes) to write out
 *                      +-- when I2C EEPROM is in NON-BLOCKING mode, application can 
 *                          only write upto 64 bytes at a time to eeprom
 * 
 * Output:      number of bytes actually written to the file associated
 *              0: no byte is written (busy/count = 0/communication fail)
 *              -1: when error occur
 ****************************************************************************************
 * For i2c devices, if there are multiple devices, write cannot be used in ISR
 ****************************************************************************************/
int write(int fd, void* buf, int count)
{
#if (UART_MOD>0)
    /*
     * UART
     */
    if (fd < (BASE_UART + NO_OF_UART) )
    {
        return uart_write(fd-BASE_UART, buf, count);
    }
#endif

#if (I2C_MOD>0)
    #if (I2C_DAC_MOD > 0)
        /*
         * I2C DAC
         */
    	if (fd==BASE_I2C)
    	{
    		return i2c_dac_write(buf);
    	}
    #endif

	#if (I2C_EEPROM_MOD > 0)
        /*
         * I2C EEPROM
         */
    	if (fd==BASE_I2C + 1)
    	{
    		return i2c_eeprom_write(buf, count);
    	}
	#endif

#endif

#if (ADC_MOD>0)
    /*
     * ADC
     */
	if (fd==BASE_ADC)
	{
		return 0;
	}
#endif

#ifdef MPLAB_DSPIC30_PORT
#if (EEPROM_MOD>0)
    /*
     * EEPROM (dsPic30F only)
     */
	if (fd==BASE_EEPROM)
	{
		return eeprom_write(buf, count);
	}
#endif
#endif

#if (PWM_MOD>0)
    /*
     * PWM
     */
	if (fd==BASE_PWM)
	{
		return pwm_write(buf);
	}
#endif

#if (KB_MOD>0)
    /*
     * KB
     */
    if (fd==BASE_KB)
    {
        return 0;
    }
#endif

#if (ETHERNET_MOD>0)
    /*
     * ETHERNET
     */
    if (fd==BASE_ETHERNET)
    {
        return dmfe_write();
    }
#endif

    return -1;
}

/****************************************************************************************
 * Name:        int read(int fd, void* buf, int count)
 * 
 * Function:    read $count bytes from device to $buf
 * 
 * Input:       fd: file descriptor generated by open()
 *              buf: buffer which contains allocation to read in data
 *              count: length of data (in bytes) to read from
 * 
 * Output:      number of bytes actually read from the file associated
 *              0: no byte is read (busy/count = 0/communication fail)
 *              -1: when error occur
 ****************************************************************************************
 * For i2c devices, if there are multiple devices, read cannot be used in ISR
 ****************************************************************************************/
int read(int fd, void* buf, int count)
{
#if (UART_MOD>0)
    /*
     * UART
     */
    if (fd<(BASE_UART + NO_OF_UART))
    {
        return uart_read(fd-BASE_UART, buf);
    }
#endif

#if (I2C_MOD>0)
    #if (I2C_DAC_MOD > 0)
        /*
         * I2C DAC
         */
    	if (fd==BASE_I2C)
    	{
    		return i2c_dac_read(buf);
    	}
    #endif

	#if (I2C_EEPROM_MOD > 0)
        /*
         * I2C EEPROM
         */
    	if (fd==BASE_I2C + 1)
    	{
    		return i2c_eeprom_read(buf, count);
    	}
	#endif
	
#endif

#if (ADC_MOD>0)
    /*
     * ADC
     */
	if (fd==BASE_ADC)
	{
		return adc_read(buf, count);
	}
#endif

#ifdef MPLAB_DSPIC30_PORT
#if (EEPROM_MOD>0)
    /*
     * EEPROM
     */
	if (fd==BASE_EEPROM)
	{
		return eeprom_read(buf, count);
	}
#endif
#endif

#if (PWM_MOD>0)
    /*
     * PWM
     */
	if (fd==BASE_PWM)
	{
		return 0;
	}
#endif

#if (KB_MOD>0)
    /*
     * KB
     */
    if (fd==BASE_KB)
    {
        return gpio_read(buf);
    }
#endif

#if (ETHERNET_MOD>0)
    /*
     * ETHERNET
     */
    if (fd==BASE_ETHERNET)
    {
        return dmfe_read();
    }
#endif

	return -1;
}

/****************************************************************************************
 * Name:        int ioctl(int fd, int request, void* argp)
 * 
 * Function:    change the device control setting (type referenced by $request) using
 *              data in $argp
 * 
 * Input:       fd: file descriptor generated by open()
 *              request: a device-dependent request code, defined in <sys/ioctl.h>
 *              argp: argument pointer for control data
 * 
 * Output:      0: change is successful
 *              -1: when error occur
 ****************************************************************************************/
int ioctl(int fd, int request, void* argp)
{
#if (UART_MOD>0)
    /*
     * UART
     */
    if (fd<(BASE_UART + NO_OF_UART))
    {
        return 0;
    }
#endif

#if (I2C_MOD>0)
    #if (I2C_DAC_MOD > 0)
        /*
         * I2C DAC
         */
    	if (fd==BASE_I2C)
    	{
    		return i2c_dac_ioctl(request, argp);
    	}
    #endif
	
	#if (I2C_EEPROM_MOD > 0)
        /*
         * I2C EEPROM
         */
    	if (fd==BASE_I2C + 1)
    	{
    		return 0;
    	}
	#endif
		
#endif

#if (ADC_MOD>0)
    /*
     * ADC
     */
	if (fd==BASE_ADC)
	{
		return adc_ioctl(request, argp);
	}
#endif

#ifdef MPLAB_DSPIC30_PORT
#if (EEPROM_MOD>0)
    /*
     * EEPROM (dsPic30f only)
     */
	if (fd==BASE_EEPROM)
	{
		return 0;
	}
#endif
#endif

#if (PWM_MOD>0)
    /*
     * PWM
     */
	if (fd==BASE_PWM)
	{
		return pwm_ioctl(request, argp);
	}
#endif

#if (KB_MOD>0)
    /*
     * KB
     */
    if (fd==BASE_KB)
    {
        return 0;
    }
#endif

#if (ETHERNET_MOD>0)
    /*
     * ETHERNET
     */
    if (fd==BASE_ETHERNET)
    {
        return 0;
    }
#endif

	return -1;
}

/****************************************************************************************
 * Name:        int lseek(int fd, int offset, int whence)
 * 
 * Function:    adjust the position of the file pointer
 * 
 * Input:       fd: file descriptor generated by open()
 *              offset: indicates how much offset is needed
 *              whence: indicates what kind of offset is needed, currently unimplemented
 * 
 * Output:      0: current offset from base address
 *              -1: when error occur
 ****************************************************************************************/
int lseek(int fd, int offset, int whence)
{
#if (UART_MOD>0)
    /*
     * UART
     */
     if (fd<(BASE_UART + NO_OF_UART))
     {
        return 0;
     }
#endif

#if (I2C_MOD>0)
    #if (I2C_DAC_MOD > 0)
        /*
         * I2C DAC
         */
    	if (fd==BASE_I2C)
    	{
    		return 0;
    	}
    #endif
	
	#if (I2C_EEPROM_MOD > 0)
        /*
         * I2C EEPROM
         */
    	if (fd==BASE_I2C + 1)
    	{
    		return i2c_eeprom_lseek(offset, whence);
    	}
	#endif	
	
#endif

#if (ADC_MOD>0)
    /*
     * ADC
     */
	if (fd==BASE_ADC)
	{
		return 0;
	}
#endif

#ifdef MPLAB_DSPIC30_PORT
#if (EEPROM_MOD>0)
    /*
     * EEPROM
     */
	if (fd==BASE_EEPROM)
	{
		return eeprom_lseek(offset, whence);
	}
#endif
#endif

#if (PWM_MOD>0)
    /*
     * PWM
     */
	if (fd==BASE_PWM)
	{
		return 0;
	}
#endif

#if (KB_MOD>0)
    /*
     * KB
     */
    if (fd==BASE_KB)
    {
        return 0;
    }
#endif

#if (ETHERNET_MOD>0)
    /*
     * ETHERNET
     */
    if (fd==BASE_ETHERNET)
    {
        return 0;
    }
#endif

	return -1;
}
