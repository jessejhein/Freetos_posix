/************************************************************************************************
 * File: 			unistd.h
 * Description:		interface between user application and os
 ***********************************************************************************************/

#ifndef UNISTD_H_
#define UNISTD_H_       1

#if(FREERTOS_SCHE_ENABLE == 1)
#include <FreeRTOS.h>
#include <task.h>
#endif

#include <asm/types.h>
#include <sys/ioctl.h>

/****************************************************************************************
 * Name:        void usleep(unsigned long usec)
 * 
 * Function:    suspends process for (at least) usec microseconds
 * 
 * Input:       time (in us) to sleep
 * 
 * Output:      void
 * 
 ****************************************************************************************
 * Minimum sleep time is 0 or greater than t, where t is the period for context switch,
 * governed by configTICK_RATE_HZ in <FreeRTOSConfig.h>
 ****************************************************************************************
 * Maximum sleep time is limited by the resolution of counter set by configUSE_16_BIT_TICKS
 * and the frequency of context switch set by configTICK_RATE_HZ in <FreeRTOSConfig.h>
 * If configUSE_16_BIT_TICKS equals 1, the counter is 16-bit, otherwise the counter is 32-bit
 * For 16-bit counter with context switch period of 10ms, maximum number of sec is 65535*0.01 
 * = 655 sec = 11 minutes
 * For 32-bit counter with context switch period of 10ms, maximum number of sec is 4,294,967,295*0.01 
 * = 42,949,672 sec = 3.3 yrs
 ****************************************************************************************/
#if(FREERTOS_SCHE_ENABLE == 1)
    #define usleep(usec)	vTaskDelay((portTickType)((__u64)usec/(1000*portTICK_RATE_MS)))
#else
    #define usleep(usec)   scrReturnV
#endif

/****************************************************************************************
 * Name:        void sleep(unsigned int seconds)
 * 
 * Function:    sleep() makes the current process sleep until seconds seconds have elapsed
 * 
 * Input:       time (in s) to sleep 
 * 
 * Output:      void (for full POSIX-compliant, should reture unsigned int)
 * 
 ****************************************************************************************
 * Maximum sleep time is limited by the resolution of counter set by configUSE_16_BIT_TICKS
 * and the frequency of context switch set by configTICK_RATE_HZ in <FreeRTOSConfig.h>
 * If configUSE_16_BIT_TICKS equals 1, the counter is 16-bit, otherwise the counter is 32-bit
 * For 16-bit counter with context switch period of 10ms, maximum number of sec is 65535*0.01 
 * = 655 sec = 11 minutes
 * For 32-bit counter with context switch period of 10ms, maximum number of sec is 4,294,967,295*0.01 
 * = 42,949,672 sec = 3.3 yrs
 ****************************************************************************************/
#if(FREERTOS_SCHE_ENABLE == 1)
    #define sleep(sec)      usleep((__u64)sec*1000000)
#else
    #define sleep(sec)      scrReturnV
#endif


/****************************************************************************************
 * Name:        int open(const char *pathname, int flags)
 * 
 * Function:    get the device ready
 *              +-- all devices can be open with O_RDWR/O_RDONLY/O_WRONLY except 
 *              +-- ADC can only be opened for O_RDONLY mode
 *              +-- PWM can be opened with all mode, but only write operation is supported
 *              +-- when I2C EEPROM is in NON-BLOCKING mode, application can only write 
 *                  upto 64 bytes at a time to eeprom
 * 
 * Input:       pathname: (= device BASE (e.g. "0") + sub-item)
 *              flags: accessing mode
 * 
 * Output:      file descriptor: 0 - 9
 *              -1: when error occur, sub-functions should set errno appropricately
 * 
 ****************************************************************************************/
extern int open(const char *pathname, int flags);

/****************************************************************************************
 * Name:        int write(int fd, void* buf, int count)
 * 
 * Function:    write $count bytes from $buf to device
 * 
 * Input:       fd: file descriptor generated by open()
 *              buf: buffer which contains data to write out
 *              count: length of data (in bytes) to write out
 *                      +-- when I2C EEPROM is in NON-BLOCKING mode, application can 
 *                          only write upto 64 bytes at a time to eeprom
 * 
 * Output:      number of bytes actually written to the file associated
 *              0: no byte is written (busy/count = 0/communication fail)
 *              -1: when error occur
 ****************************************************************************************
 * For i2c devices, if there are multiple devices, write cannot be used in ISR
 ****************************************************************************************/
extern int write(int fd, void* buf, int count);

/****************************************************************************************
 * Name:        int read(int fd, void* buf, int count)
 * 
 * Function:    read $count bytes from device to $buf
 * 
 * Input:       fd: file descriptor generated by open()
 *              buf: buffer which contains allocation to read in data
 *              count: length of data (in bytes) to read from
 * 
 * Output:      number of bytes actually read from the file associated
 *              0: no byte is read (busy/count = 0/communication fail)
 *              -1: when error occur
 ****************************************************************************************
 * For i2c devices, if there are multiple devices, read cannot be used in ISR
 ****************************************************************************************/
extern int read(int fd, void* buf, int count);

/****************************************************************************************
 * Name:        int ioctl(int fd, int request, void* argp)
 * 
 * Function:    change the device control setting (type referenced by $request) using
 *              data in $argp
 * 
 * Input:       fd: file descriptor generated by open()
 *              request: a device-dependent request code, defined in <sys/ioctl.h>
 *              argp: argument pointer for control data
 * 
 * Output:      0: change is successful
 *              -1: when error occur
 ****************************************************************************************/
extern int ioctl(int fd, int request, void* argp);

/****************************************************************************************
 * Name:        int lseek(int fd, int offset, int whence)
 * 
 * Function:    adjust the position of the file pointer
 * 
 * Input:       fd: file descriptor generated by open()
 *              offset: indicates how much offset is needed
 *              whence: indicates what kind of offset is needed, currently unimplemented
 * 
 * Output:      0: current offset from base address
 *              -1: when error occur
 ****************************************************************************************/
#define SEEK_SET       0       /* Seek from beginning of file.  */
extern int lseek(int fd, int offset, int whence);

#endif /* UNISTD_H_  */
