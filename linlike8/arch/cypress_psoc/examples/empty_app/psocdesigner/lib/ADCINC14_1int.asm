;;*****************************************************************************
;;*****************************************************************************
;;  FILENAME:   ADCINC14_1INT.asm
;;  Version: 1.3, Updated on 2005/03/06 at 17:14:19
;;  Generated by PSoC Designer ver 4.2  b1013 : 02 September, 2004
;;
;;  DESCRIPTION: ADCINC14 Interrupt Service Routines.
;;
;;-----------------------------------------------------------------------------
;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
;;*****************************************************************************
;;*****************************************************************************

include "m8c.inc"
include "memory.inc"
include "ADCINC14_1.inc"

;-----------------------------------------------
;  Global Symbols
;-----------------------------------------------
export _ADCINC14_1_CNT_ISR
export _ADCINC14_1_PWM24_ISR
export  ADCINC14_1_iCounterU
export _ADCINC14_1_iResult
export  ADCINC14_1_iResult
export _ADCINC14_1_bfStatus
export  ADCINC14_1_bfStatus
export  ADCINC14_1_bSampC

;-----------------------------------------------
; Variable Allocation
;-----------------------------------------------
AREA InterruptRAM(RAM, REL, CON)

 ADCINC14_1_iCounterU:     BLK   2  ;The Upper word of the Counter
_ADCINC14_1_iResult:
 ADCINC14_1_iResult:       BLK   2  ;A/D value
_ADCINC14_1_bfStatus:
 ADCINC14_1_bfStatus:      BLK   1  ;Data Valid Flag
 ADCINC14_1_bSampC:        BLK   1  ;# of times to run A/D


;-----------------------------------------------
;  EQUATES and TABLES
;-----------------------------------------------
LSB:       equ 1
MSB:       equ 0

;@PSoC_UserCode_INIT@ (Do not change this line.)
;---------------------------------------------------
; Insert your custom declarations below this banner
;---------------------------------------------------

;------------------------
;  Constant Definitions
;------------------------


;------------------------
; Variable Allocation
;------------------------


;---------------------------------------------------
; Insert your custom declarations above this banner
;---------------------------------------------------
;@PSoC_UserCode_END@ (Do not change this line.)


AREA UserModules (ROM, REL)

;-----------------------------------------------------------------------------
;  FUNCTION NAME: ADCINC14_1_CNT_ISR (Counter8 Interrupt)
;
;
;  DESCRIPTION:
;  Increment the upper (software) half on the counter whenever the
;  lower (hardware) half of the counter underflows.  This counter
;  should start out at the most negative value (0xFF).
;
;-----------------------------------------------------------------------------
;
_ADCINC14_1_CNT_ISR:
   inc [ADCINC14_1_iCounterU+LSB]
   jnc END_ADCINC14_1_CNT_ISR
   inc [ADCINC14_1_iCounterU+MSB]

   ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
   ;---------------------------------------------------
   ; Insert your custom code below this banner
   ;---------------------------------------------------
   ;   NOTE: interrupt service routines must preserve
   ;   the values of the A and X CPU registers.

   ;---------------------------------------------------
   ; Insert your custom code above this banner
   ;---------------------------------------------------
   ;@PSoC_UserCode_END@ (Do not change this line.)

END_ADCINC14_1_CNT_ISR:
   reti


;-----------------------------------------------------------------------------
;  FUNCTION NAME: ADCINC14_1_PWM24_ISR  (PWM24 Interrupt)
;
;  DESCRIPTION:
;  This ISR is called when the ADC has completed and integrate cycle.
;  The ADC value is calculated and stored in a global location before
;  the end of the ISR.
;
;-----------------------------------------------------------------------------
;
;  SIDE EFFECTS:
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
_ADCINC14_1_PWM24_ISR:
   and   reg[ADCINC14_1_bCounter_CR0], ~ADCINC14_1_fDBLK_ENABLE  ; Disable Counter
IF ADCINC14_1_NoAZ
   or    reg[ADCINC14_1_bfAtoDcr2], ADCINC14_1_fAutoZero   ; Put Integrator in AutoZero
ENDIF
   or    reg[ADCINC14_1_bfAtoDcr3],ADCINC14_1_fFSW0        ; Put Integrator in reset

                                                           ; Enable interrupts for a short period of time just in case.
                                                           ; Make sure we didn't have a counter interrupt ready to fire
   M8C_EnableGInt
   nop                                                     ; Wait a couple cycles
   M8C_DisableGInt                                         ; Disable interrupt, read to complete processing
   push  A                                                 ; Save the Accumulator
   mov   A,reg[ADCINC14_1_bCount]                          ; Read counter value  (Bogus read puts value in Period register)
   mov   A,reg[ADCINC14_1_bCompare]                        ; Read counter value
   dec   A                                                 ; Decrement by one to make sure we didn't miss a count
   cpl   A                                                 ; Invert the value
   jnc   .INT_CALCV                                        ; if carry, then inc MSB as well
   inc   [ADCINC14_1_iCounterU + LSB]
   jnc   .INT_CALCV                                        ; if carry, then inc MSB as well
   inc   [ADCINC14_1_iCounterU + MSB]
.INT_CALCV:
   mov   [(ADCINC14_1_iResult + LSB)], A                   ; Store LSB value
   mov   A, [ADCINC14_1_iCounterU + LSB]                   ; Store MSB from temp counter
   mov   [(ADCINC14_1_iResult + MSB)], A
                                                           ; The new value has been stored,
                                                           ; so get counters ready for next reading first.
   mov   reg[ADCINC14_1_bPeriod],0xFF                      ; Initialize counter to FF - Set to overflow after 256 counts
   or    reg[ADCINC14_1_bCounter_CR0],ADCINC14_1_fDBLK_ENABLE  ; Enable Counter

   ;@PSoC_UserCode_BODY_2@ (Do not change this line.)
   ;---------------------------------------------------
   ; If the input is muxed with multiple inputs
   ; this is a good place to change inputs.
   ; Insert your custom code below this banner
   ;---------------------------------------------------
   ; NOTE: interrupt service routines must preserve
   ; the values of the A and X CPU registers.

   ;---------------------------------------------------
   ; Insert your custom code above this banner
   ;---------------------------------------------------
   ;@PSoC_UserCode_END@ (Do not change this line.)

   and   reg[ADCINC14_1_bfAtoDcr3],~ADCINC14_1_fFSW0       ; Take Integrator out of reset
IF ADCINC14_1_NoAZ
   and   reg[ADCINC14_1_bfAtoDcr2],~ADCINC14_1_fAutoZero   ; Take Integrator out of AutoZero
ENDIF

   ;****************************************************************************
   ;M8C_EnableGInt            ; May want to re-enable interrupts at this point,
   ;                          ; if stack space isn't at a premium.
   ; NOTE:  this will make system more responsive but, will increase the
   ;        overall processing time of the A/D calctime.  If an interrupt is
   ;        taken, it must return within the specified CalcTime to guarantee
   ;        successful acquisition of the next byte.
   ;****************************************************************************
IF (ADCINC14_1_DATA_FORMAT)                      ; Only check for Negative numbers if SIGNED result

                                                 ; Negative Overflow Check
   tst   [ADCINC14_1_iCounterU + MSB],0x80
   jnz   .NOT_POVFL
ENDIF


IF (ADCINC14_1_DATA_FORMAT)                                ; Init counter for SIGNED result
   tst   [ADCINC14_1_iCounterU + LSB],0x80       ; Test for Positive Overflow
   jz    .NOT_POVFL
                                                 ; Positive overflow, fix it - set to Max Positive + 1
                                                 ; Force most positive * 4 into result
   mov   [ADCINC14_1_iCounterU + MSB], 0x00
   mov   [(ADCINC14_1_iResult + MSB)], 0x7F
   mov   [(ADCINC14_1_iResult + LSB)], 0xFF
ELSE                                             ; UNSIGNED
   tst   [ADCINC14_1_iCounterU + MSB],0x01       ; Test for Positive Overflow
   jz    .NOT_POVFL
                                                 ; Positive overflow, fix it - set to Max Positive + 1
                                                 ; Force most positive * 4 into result
   mov   [ADCINC14_1_iCounterU + MSB], 0x00
   mov   [(ADCINC14_1_iResult + MSB)], 0xFF
   mov   [(ADCINC14_1_iResult + LSB)], 0xFF
ENDIF


.NOT_POVFL:

   asr   [ADCINC14_1_iCounterU + MSB]
   rrc   [(ADCINC14_1_iResult + MSB)]                      ; Shift MSB and LSB right twice to divide by four
   rrc   [(ADCINC14_1_iResult + LSB)]                      ; Remember digital clock 4 times analog clock

   asr   [ADCINC14_1_iCounterU + MSB]
   rrc   [(ADCINC14_1_iResult + MSB)]
   rrc   [(ADCINC14_1_iResult + LSB)]

IF (ADCINC14_1_DATA_FORMAT)                                ; Init counter for signed result
   mov   [ADCINC14_1_iCounterU + LSB],0x80                 ; Place most negative value in LSB of counter for next cycle
   mov   [ADCINC14_1_iCounterU + MSB],0xFF                 ; Set the MSB of the upper counter to negative
ELSE                                                       ; Init counter for unsigned result
   mov   [ADCINC14_1_iCounterU + LSB],0x00                 ; Place initial value in MSB of counter
   mov   [ADCINC14_1_iCounterU + MSB],0x00                 ; Clear the MSB of the upper counter (positive)
ENDIF

   ;@PSoC_UserCode_BODY_3@ (Do not change this line.)
   ;---------------------------------------------------
   ; Data is ready at this point.
   ; If processing Data at Interrupt level - add
   ; User Code to handle the data below this banner
   ;---------------------------------------------------
   ;   NOTE: interrupt service routines must preserve
   ;   the values of the A and X CPU registers.

   ;---------------------------------------------------
   ; Insert your custom code above this banner
   ;---------------------------------------------------
   ;@PSoC_UserCode_END@ (Do not change this line.)

   pop   A                                       ; Restore A, not used any more

   or    [ADCINC14_1_bfStatus],ADCINC14_1_fDATA_READY  ; Set Data ready bit

   tst   [ADCINC14_1_bSampC], ffh                ; If sample_counter == 0 -->> continuous data collection
   jz    ADCINC14_1_END_PWM24_ISR

   dec   [ADCINC14_1_bSampC]                     ; Dec sample counter and check for zero
   jnz   ADCINC14_1_END_PWM24_ISR

   ;**********************************************
   ; Turn off ADC
   ;**********************************************
   and   reg[ADCINC14_1_fPWM_LSB_CR0], ~ADCINC14_1_fDBLK_ENABLE     ; Disable the PWM
   and   reg[ADCINC14_1_bCounter_CR0], ~ADCINC14_1_fDBLK_ENABLE           ; Disable the Counter
IF ADCINC14_1_NoAZ
   or    reg[ADCINC14_1_bfAtoDcr2], ADCINC14_1_fAutoZero       ; Put the Integrator into Autozero mode
ENDIF
   or    reg[ADCINC14_1_bfAtoDcr3], ADCINC14_1_fFSW0           ; Put Integrator into reset
   and   reg[ADCINC14_1_bfPWM24_INT_REG], ~ADCINC14_1_bfPWM24_Mask      ; Disable interrupts
   and   reg[ADCINC14_1_bfCounter_INT_REG], ~ADCINC14_1_bfCounter_Mask

ADCINC14_1_END_PWM24_ISR:
   reti

; End of File ADCINC14_1INT.asm
