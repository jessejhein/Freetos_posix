/**
 * demo pin_define.h
 */

#ifndef PIN_DEFINE_H_
#define PIN_DEFINE_H_

#include <asm/types.h>


//  =========================ADDRESS BUS=================================
/**
 * \brief initialise address
 * \remarks ADDR0 (RG0): output, [addressing mode]
 */
#define addr_bus_init() \
{ \
  TRISG &= 0xFFFE; \
  LATG |= 0x0001; \
}


/**
 * \brief set address bus
 * \param address address to set
 */
#define addr_bus_set_addr(address) \
{ \
  LATG = (PORTG & 0xFFFE) | (((unsigned int)address) & 0x0001); \
}



// ============================IO BUS===================================
/**
 * \brief initialise IO bus
 * \remarks IOR# (RF0): output, [not read]
 * \remarks IOW# (RF1): output, [not write]
 */
#define io_bus_init() \
{ \
  TRISF &= 0xFFFC; \
  LATF |= 0x0003; \
}


/**
 * \brief set IO bus
 * \param write write/read mode
 */
#define io_bus_set_write(write) \
{ \
  if (write) LATF = (PORTF & 0xFFFC) | 0x0001; \
  else LATF = (PORTF & 0xFFFC) | 0x0002; \
}



//  ===========================DATA BUS===================================
/**
 * \brief configure data port pins to output or input
 * \param x 0: output\n
 *          1: input
 * \remarks DATA7   =>  _RD9
 * \remarks DATA6   =>  _RD8
 * \remarks DATA5   =>  _RD7
 * \remarks DATA4   =>  _RD6
 * \remarks DATA3   =>  _RD5
 * \remarks DATA2   =>  _RD4
 * \remarks DATA1   =>  _RD3
 * \remarks DATA0   =>  _RD2
 * \remarks Configure output    =>  1111 1100 0000 0011 => 0xFC03
 * \remarks Configure input     =>  0000 0011 1111 1100 => 0x03FC
 */
#define PCONFIG(x) \
{ \
  if ((x) == 0) TRISD &= 0xFC03; \
  else TRISD |= 0x03FC; \
}


/**
 * \brief write a byte to data port
 * \param x 8-bit data
 * \remarks
 * \li DDDD DD-- ---- --DD & 1111 1100 0000 0011          => DDDD DD00 0000 00DD
 * \li (0000 0000 XXXX XXXX << 2) & 0000 0011 1111 1100   => 0000 00XX XXXX XX00
 * \li                        ORing                       => DDDD DDXX XXXX XXDD
 */
#define PWRITE(x) \
{ \
  LATD = ( (PORTD & 0xFC03) | ((((int)x) << 2) & 0x03FC) ); \
}


/**
 * \brief read a byte from data port
 * \return 8-bit data
 */
#define PREAD()                         ( (unsigned char)( (PORTD & 0x03FC) >> 2) )



//  ==============================UART=====================================
#ifdef UART_MOD
/**
 * \brief set the RS485 digital control pin as output
 */
#define UART_A_RS485_CTL_EN()


/**
 * \brief set the RS485 digital control pin to TX state
 */
#define UART_A_RS485_TX_ON()


/**
 * \brief set the RS485 digital control pin to RX state
 */
#define UART_A_RS485_TX_OFF()


/**
 * \brief set the RS485 digital control pin as output
 */
#define UART_B_RS485_CTL_EN()


/**
 * \brief set the RS485 digital control pin to TX state
 */
#define UART_B_RS485_TX_ON()


/**
 * \brief set the RS485 digital control pin to RX state
 */
#define UART_B_RS485_TX_OFF()
#endif /* UART_MOD */



//  ==============================KB======================================
#ifdef KB_MOD
/**
 * \brief configure pin for all keys
 */
extern void kb_config (void);


/**
 * \brief determine if a key has been pressed (push key)
 * \param id key id
 * \retval 1 key is being pressed
 * \retval 0 key is released
 */
extern int kb_key_press (unsigned char id);


#ifdef KB_ROTATE_KEY
/**
 * \brief Check the state of rotary pin
 * \param id key id
 * \retval 1 key is at high state
 * \retval 0 key is at low state
 */
extern int kb_rkey_state (unsigned char id);
#endif /* KB_ROTATE_KEY */


#ifdef KB_PUSH_KEY
#if (TOTAL_PUSH_KEY == 1)
/**
 * \brief Initialise Enter Key
 * \remarks ENTER_KEY (RG1), input
 */
#define EN_PKEY0()                      TRISG |= 0x0002


/**
 * \brief Read Enter Key Status
 * \retval 0 key is up
 * \retval 1 key is down
 */
#define IO_PKEY0()                      PORTG & 0x0002
#endif /* TOTAL_PUSH_KEY == 1 */
#endif /* KB_PUSH_KEY */


//  -------------------------------------------------------------------------------
#ifdef KB_ROTATE_KEY
/**
 * \brief Initialise Rotary Up Key
 * \remarks UP_KEY (RG13), input, change notification
 */
#define EN_RKEY0_UP() \
{ \
  TRISC |= 0x2000; \
  _CN1IE = 1; /* change input register, interrupt setting */ \
}


/**
 * \brief Read Rotary Up Key Status
 * \retval 0 key is low state
 * \retval 1 key is high state
 */
#define IO_RKEY0_UP()                   PORTC & 0x2000


/**
 * \brief Initialise Rotary Down Key
 * \remarks DOWN_KEY (RG14), input, change notification
 */
#define EN_RKEY0_DN() \
{ \
  TRISC |= 0x4000; \
  _CN0IE = 1; /* change input register, interrupt setting */ \
}


/**
 * \brief Read Rotary Down Key Status
 * \retval 0 key is low state
 * \retval 1 key is high state
 */
#define IO_RKEY0_DN()                   PORTC & 0x4000
#endif /* KB_ROTATE_KEY */
#endif /* KB_MOD */



//  ==============================LED=====================================
#ifdef LED_MOD
/** handler for LED module */
extern int fd_led;


/**
 * \brief initialise IOs for LED port
 */ 
extern void led_config (void);


/**
 * \brief turn on led at hardware level
 * \param which which channel
 */
extern void led_on (int which);


/**
 * \brief turn off led at hardware level
 * \param which which channel
 */
extern void led_off (int which);


/**
 * \brief change the state of led at application level
 * \param channel which channel
 * \param state state to change to
 */
extern void led (__u8 channel, __u8 state);
#endif /* LED_MOD */


#ifdef I2C_LED_DRIVER_MOD
/** handler for I2C LED module */
extern int fd_i2c_led;

#define LED_CHANNEL0                    0
#define LED_CHANNEL1                    1
#define LED_CHANNEL2                    2
#define MASTER_LED_CHANNEL              3
#define BUZZER_VOLUME_CHANNEL           4


/**
 * \brief Control on off of buzzer
 * \param status 0 = off, 1 = on
 * \remarks volume depends on UI setting
 */
extern void ui_buzzer_ctrl (char status);
#endif /* I2C_LED_DRIVER_MOD */



//  ===========================GPIO========================================
#ifdef I2C_GPIO_MOD
/** handler for I2C GPIO module */
extern int fd_i2c_gpio;
#endif /* I2C_GPIO_MOD */



//  ===========================ETHERNET PORT===============================
#ifdef ETHERNET_MOD
/*
 * \brief KEY MAPS
 * \remarks Interrupt Key Map
 */ 
#define ETH_ISR_EP                      _INT0EP
#define ETH_ISR_IF                      _INT0IF
#define ETH_ISR_IP                      _INT0IP
#define ETH_ISR_IE                      _INT0IE
#define dmfe_interrupt                  _IRQ _INT0Interrupt

/**
 * \brief initialise chip select for Ethernet port
 * \remarks ETH_CS# (RG14): output, [do not select chip]
 */
#define ETH_CS_CONFIG() \
{ \
  TRISG &= 0xBFFF; \
  LATG |= 0x4000; \
}

/**
 * \brief set the chip select pin
 * \param x logic to set
 */
#define ETH_CS(x) \
{ \
  LATG = ( (PORTG & 0xBFFF) | ((((__u16)x) << 14) & 0x4000) /* CS# */ ); \
}
#endif /* ETHERNET_MOD */



/**
 * \brief change ADC registers to add channel for scanning
 * \param channel channel id (ANx)
 */
extern void adc_add_ch (int channel);


/**
 * \brief parse the ADC channel id (ANx) to local buffer id [0, ADC_MAX_CH-1]
 * \param channel channel id (ANx)
 * \return local buffer id
 * \retval -1 error
 */
extern int adc_parse_ch (int channel);


#endif /* PIN_DEFINE_H_ */
