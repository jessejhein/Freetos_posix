/**
 * demo pin_define.h
 */

#ifndef PIN_DEFINE_H_
#define PIN_DEFINE_H_

//  ===========================DATA BUS===================================
/**
 * \brief configure data port pins to output or input
 * \param x 0: output\n
 *          1: input
 * \remarks DATA7   =>  _RD9
 * \remarks DATA6   =>  _RD8
 * \remarks DATA5   =>  _RD7
 * \remarks DATA4   =>  _RD6
 * \remarks DATA3   =>  _RD5
 * \remarks DATA2   =>  _RD4
 * \remarks DATA1   =>  _RD3
 * \remarks DATA0   =>  _RD2
 * \remarks Configure output    =>  1111 1100 0000 0011 => 0xFC03
 * \remarks Configure input     =>  0000 0011 1111 1100 => 0x03FC
 */
#define PCONFIG(x) \
{ \
  if ((x) == 0) TRISD &= 0xFC03; \
  else TRISD |= 0x03FC; \
}

/**
 * \brief write a byte to data port
 * \param x 8-bit data
 * \remarks
 * \li DDDD DD-- ---- --DD & 1111 1100 0000 0011          => DDDD DD00 0000 00DD
 * \li (0000 0000 XXXX XXXX << 2) & 0000 0011 1111 1100   => 0000 00XX XXXX XX00
 * \li                        ORing                       => DDDD DDXX XXXX XXDD
 */
#define PWRITE(x) \
{ \
  LATD = ( (PORTD & 0xFC03) | ((((int)x) << 2) & 0x03FC) ); \
}

/**
 * \brief read a byte from data port
 * \return 8-bit data
 */
#define PREAD()                         ( (unsigned char)( (PORTD & 0x03FC) >> 2) )



//  ==============================UART=====================================
#ifdef UART_MOD
/**
 * \brief set the RS485 digital control pin as output
 */
#define RS485_CTL_EN()                  TRISG &= 0x7FFF

/**
 * \brief set the RS485 digital control pin to TX state
 */
#define RS485_TX_ON()                   LATG |= 0x8000

/**
 * \brief set the RS485 digital control pin to RX state
 */
#define RS485_TX_OFF()                  LATG &= 0x7FFF
#endif /* UART_MOD */



//  ==============================KB======================================
#ifdef KB_MOD
/**
 * \brief configure pin for all keys
 */
extern void key_config (void);

/**
 * \brief determine if a key has been pressed (push key)
 * \param id key id
 * \retval 1 key is being pressed
 * \retval 0 key is released
 */
extern int key_press (unsigned char id);

#ifdef KB_ROTATE_KEY
/**
 * \brief Check the state of rotary pin
 * \param id key id
 * \retval 1 key is at high state
 * \retval 0 key is at low state
 */
extern int rkey_state (unsigned char id);
#endif /* KB_ROTATE_KEY */

/**
 * \brief KEY MAPS
 * \remarks EN: input/output selection
 * \remarks IO: logic state of key
 * \remarks CN: change notification (interrupt enable pin to detect change of state)
 */
#ifdef KB_PUSH_KEY
#if (TOTAL_PUSH_KEY == 1)
//Enter key
#define EN_PKEY0()                      TRISG |= 0x0002
#define IO_PKEY0()                      PORTG & 0x0002
#endif /* TOTAL_PUSH_KEY == 1 */
#endif /* KB_PUSH_KEY */
//  -------------------------------------------------------------------------------
#ifdef KB_ROTATE_KEY
#if (TOTAL_ROTARY_KEY == 1)
//Up key
#define EN_RKEY0_UP() \
{ \
  TRISC |= 0x2000; \
  _CN1IE = 1; /* change input register, interrupt setting */ \
}
#define IO_RKEY0_UP()                   PORTC & 0x2000
//Down Key
#define EN_RKEY0_DN() \
{ \
  TRISC |= 0x4000; \
  _CN0IE = 1; /* change input register, interrupt setting */ \
}
#define IO_RKEY0_DN()                   PORTC & 0x4000
#endif /* TOTAL_ROTARY_KEY */
#endif /* KB_ROTATE_KEY */
#endif /* KB_MOD */



//  ==============================LED=====================================
#ifdef LED_MOD
/** handler for led module */
extern int fd_led;
/**
 * \brief initialise IOs for LED port
 */ 
extern void io_config (void);

/**
 * \brief turn on led at hardware level
 * \param which which channel
 */
extern void io_on (int which);

/**
 * \brief turn off led at hardware level
 * \param which which channel
 */
extern void io_off (int which);

/**
 * \brief change the state of led at application level
 * \param channel which channel
 * \param state state to change to
 */
extern void led (unsigned char channel, unsigned char state);
#endif /* LED_MOD */

#ifdef I2C_LED_DRIVER_MOD
extern int fd_i2c_led;
#define LCD_BACKLIGHT_CHANNEL0          0
#define LCD_BACKLIGHT_CHANNEL1          1
#define LED_CHANNEL0                    2
#define LED_CHANNEL1                    3
#define LED_CHANNEL2                    4
#define MASTER_LED_CHANNEL              5
#define BUZZER_VOLUME_CHANNEL0          6
#define BUZZER_VOLUME_CHANNEL1          7

/**
 * \brief Control on off of buzzer
 * \param status 0 = off, 1 = on
 * \remarks volume depends on ui setting
 */
extern void ui_buzzer_ctrl (char status);
#endif /* I2C_LED_DRIVER_MOD */

//  ======================OBSOLETE ERROR PIN===============================
#define ERR_LED_CONFIG()
#define ERR_LED0(x)
#define ERR_LED1(x)



//  ===========================GPIO========================================
#ifdef I2C_GPIO_MOD
extern int fd_i2c_gpio;
#endif /* I2C_GPIO_MOD */



//  ===========================ETHERNET PORT===============================
#ifdef ETHERNET_MOD
/*
 * \brief KEY MAPS
 * \remarks Interrupt Key Map
 */ 
#define ETH_ISR_EP                      _INT0EP
#define ETH_ISR_IF                      _INT0IF
#define ETH_ISR_IP                      _INT0IP
#define ETH_ISR_IE                      _INT0IE
#define dmfe_interrupt                  _IRQ _INT0Interrupt

/**
 * \brief initialise IOs for Ethernet port
 * \remarks ETH_CS# (RG14): output, [do not select chip]
 * \remarks ADDR0 (RG0): output, [addressing mode]
 * \remarks IOR# (RF0): output, [not read]
 * \remarks IOW# (RF1): output, [not write]
 */
#define ETH_IOCONFIG() \
{ \
  TRISG &= 0xBFFE; \
  TRISF &= 0xFFFC; \
  LATG |= 0x4001; \
  LATF |= 0x0003; \
}

/**
 * \brief set the IO pins to read/write an address/data register
 * \param x command\n
 *          bit 0: IOR#\n
 *          bit 1: IOW#\n
 *          bit 2: ADDR/DATA\n
 *          bit 3: CS#\n
 */
#define ETH_IOCMD(x) \
{ \
  LATG = ( (PORTG & 0xBFFE) | ((((int)x) << 11) & 0x4000) /* CS# */ | ((((int)x) >> 2) & 0x0001) /* ADDR/DATA */ ); \
  LATF = ( (PORTF & 0xFFFC) | (((int)x) & 0x0003) ); \
}
#endif /* ETHERNET_MOD */



//  ===============================LCD=====================================
#ifdef LCD_MOD
/** handler for LCD module */
extern int fd_lcd;
#endif /* LCD_MOD */
#ifdef LCD_TWLMB162NDC
/**
 * \brief initialise IOs for LCD display
 * \remarks LCD_CS# (G12): output, [do not select chip]
 * \remarks ADDR0 (G0): output, [addressing mode]
 */
#define lcd_io_init() \
{ \
  TRISG &= 0xEFFE; \
  LATG |= 0x1001; \
}
#define TW_LMB162_RS(x)                 LATG = ((x)==1)? (LATG | 0x0001) : (LATG & 0xFFFE)
#define TW_LMB162_WR(x)                 //directly short to ground for write mode only
#define TW_LMB162_EN(x)                 LATG = ((x)==1)? (LATG | 0x1000) : (LATG & 0xEFFF)


#ifdef PWM_MOD
/** handler for PWM module for contrast control */
extern int fd_pwm;

/** PWM channel id for LCD contrast */
#define PWM_CONTRAST_CH                 0
#endif /* PWM_MOD */
#endif /* LCD_TWLMB162NDC */


#endif /* PIN_DEFINE_H_ */
