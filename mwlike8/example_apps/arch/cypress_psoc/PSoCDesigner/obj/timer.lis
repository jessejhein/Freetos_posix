                        .module timer.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./interrupt.h
 0000                   .dbfunc s mark_bh _mark_bh fV
 0000           ;             nr -> X-4
 0000           _mark_bh:
 0000                   .dbline -1
 0000 10                push X
 0001 4F                mov X,SP
 0002                   .dbline 22
 0002           ; /*
 0002           ;  *    kernel/timer.c
 0002           ;  *
 0002           ;  *    23-04-2004      yan     create this following linux
 0002           ;  *    17-06-2004      yan     modify timer structure from 6 bytes to 4 bytes only to reduce RAM usage, then more timer variables can reduce more RAM
 0002           ;  *    27-07-2004      yan     max. timer delay or sleep is 255*10mSec = 2.55 Sec, then reuce more RAM : timer counter from 16-bit to 8-bit
 0002           ;  *
 0002           ;  */
 0002           ; 
 0002           ; #include "app.h"
 0002           ; #include "sched.h"                                                                    // schedule_timeout()
 0002           ; #include "current.h"                                                                  // current
 0002           ; #include "interrupt.h"                                                                        // mark_bh()
 0002           ; #include "timer.h"                                                                    // timer_list
 0002           ; #include "system.h"                                                                   // sti()             
 0002           ; #if (KB_MOD==1)
 0002           ;       #include "kb.h"                                                                 // kb hw driver(application dependent, so diff. appl. has diff. kb.h)
 0002           ;       #include "gpio.h"
 0002           ;       #include "gpio_kb_app.h"                                                        // kb app.
 0002           ; #endif
 0002           ; 
 0002           ; #if (TIMER_MOD==1)
 0002                   .dbline 23
 0002           ; 
 0002 550001            mov [__r0],1
 0005 52FC              mov A,[X-4]
 0007 2107              and A,7
 0009 A006              jz X0
 000B           X1:
 000B 6500              asl [__r0]
 000D 78                dec A
 000E BFFC              jnz X1
 0010           X0:
 0010 5100              mov A,[_softirq_vec]
 0012 2A00              or A,[__r0]
 0014 5300              mov [_softirq_vec],A
 0016                   .dbline -2
 0016                   .dbline 24
 0016           ; #if (AUTO_ZERO==1)
 0016           L2:
 0016 20                pop X
 0017                   .dbline 0 ; func end
 0017 7F                ret
 0018                   .dbsym l nr -4 c
 0018                   .dbend
 0018                   .dbfile ./timer.c
 0018                   .dbfunc e do_timer _do_timer fV
 0018           _do_timer::
 0018                   .dbline -1
 0018                   .dbline 44
 0018           ; unsigned char jiffies;
 0018           ; #else
 0018           ; unsigned char jiffies = 0;                                                            // 9-bit, so can handle 2^8 * 10mSec =  days; if type is be modified, change MAX_JIFFY_OFFSET also in include/linlike8/time.h
 0018           ; #endif
 0018           ; 
 0018           ; #if (NR_TIMER_OUT>0)
 0018           ; struct timer_list* timer_vector[NR_TIMER_OUT];
 0018           ; #endif
 0018           ; 
 0018           ; #if (AUTO_ZERO==0)
 0018           ; void init_timer(void)
 0018           ; {
 0018           ;       unsigned char i;
 0018           ;       for (i=0;i<NR_TIMER_OUT;i++)                                                    // clr all to zero, indicating empty timer.
 0018           ;               timer_vector[i] = 0;
 0018           ; }
 0018           ; #endif
 0018           ; 
 0018           ; void do_timer(void)
 0018           ; {
 0018                   .dbline 45
 0018           ;       jiffies++;                                                                      // make sure it is running in atomic, so make sure no other interrupt here
 0018 7606              inc [_jiffies]
 001A                   .dbline 46
 001A           ;       mark_bh(TIMER_BH);                                                              // enable bh timer task
 001A 5000              mov A,0
 001C 08                push A
 001D 9FE1              xcall _mark_bh
 001F 38FF              add SP,-1
 0021                   .dbline -2
 0021                   .dbline 47
 0021           ; }
 0021           L6:
 0021                   .dbline 0 ; func end
 0021 7F                ret
 0022                   .dbend
 0022                   .dbfunc e timer_softirq _timer_softirq fV
 0022           ;              i -> X+1
 0022           ;    timer_event -> X+1
 0022           ;              i -> X+0
 0022           _timer_softirq::
 0022                   .dbline -1
 0022 10                push X
 0023 4F                mov X,SP
 0024 3804              add SP,4
 0026                   .dbline 50
 0026           ; 
 0026           ; void timer_softirq(void)
 0026           ; {
 0026                   .dbline 59
 0026           ; #if (NR_TIMER_OUT>0)
 0026           ;       unsigned char i;                                                                // common variabe
 0026           ;       
 0026           ;               // this timer_softirq source code should do not longer than 10mSec, since each timer interrupt event is each 10mSec
 0026           ;               //******************************************************************************
 0026           ;               
 0026           ;               // run_timer_list();    => chk timer event
 0026           ;               //******************************************************************************
 0026           ;       {
 0026                   .dbline 62
 0026           ; //    if (gpio_var.timer_semop==0) {
 0026           ; //            gpio_var.timer_semop = 1;
 0026           ;       for (i=0;i<NR_TIMER_OUT;i++)                                                    // find out non-empty place
 0026 560000            mov [X+0],0
 0029 80A2              xjmp L11
 002B           L8:
 002B                   .dbline 63
 002B           ;               if (timer_vector[i]!=0) {
 002B 5200              mov A,[X+0]
 002D 5300              mov [__r1],A
 002F 550000            mov [__r0],0
 0032 6500              asl [__r1]
 0034 6B00              rlc [__r0]
 0036 060000            add [__r1],<_timer_vector
 0039 0E0000            adc [__r0],>_timer_vector
 003C 3E00              mvi A,[__r1]
 003E 5300              mov [__r0],A
 0040 3E00              mvi A,[__r1]
 0042 3C0000            cmp [__r0],0
 0045 B005              jnz X2
 0047 3900              cmp A,0
 0049 A080              jz L12
 004B           X2:
 004B                   .dbline 63
 004B                   .dbline 64
 004B           ;                       struct timer_list timer_event = *timer_vector[i];
 004B 5A00              mov [__r1],X
 004D 060001            add [__r1],1
 0050 5200              mov A,[X+0]
 0052 5300              mov [__r3],A
 0054 550000            mov [__r2],0
 0057 6500              asl [__r3]
 0059 6B00              rlc [__r2]
 005B 060000            add [__r3],<_timer_vector
 005E 0E0000            adc [__r2],>_timer_vector
 0061 3E00              mvi A,[__r3]
 0063 3E00              mvi A,[__r3]
 0065 5300              mov [__r3],A
 0067 3E00              mvi A,[__r3]
 0069 3F00              mvi [__r1],A
 006B 3E00              mvi A,[__r3]
 006D 3F00              mvi [__r1],A
 006F 3E00              mvi A,[__r3]
 0071 3F00              mvi [__r1],A
 0073                   .dbline 65
 0073           ;                       if (timer_event.expires==jiffies) {
 0073 5201              mov A,[X+1]
 0075 3A06              cmp A,[_jiffies]
 0077 B052              jnz L14
 0079                   .dbline 65
 0079                   .dbline 66
 0079           ;                               if ((timer_event.data.timer_data&0xff00)==0xff00) wake_up_process(((struct task_struct*) (&task[(timer_event.data.timer_data&0x00ff)]) ));// related to sched.c only
 0079 5203              mov A,[X+3]
 007B 2100              and A,0
 007D 5300              mov [__r1],A
 007F 5202              mov A,[X+2]
 0081 21FF              and A,-1
 0083 39FF              cmp A,-1
 0085 B022              jnz L16
 0087 3C0000            cmp [__r1],0
 008A B01D              jnz L16
 008C           X3:
 008C                   .dbline 66
 008C 5203              mov A,[X+3]
 008E 21FF              and A,-1
 0090 5300              mov [__r1],A
 0092 5202              mov A,[X+2]
 0094 2100              and A,0
 0096 5300              mov [__r0],A
 0098 6500              asl [__r1]
 009A 6B00              rlc [__r0]
 009C 060001            add [__r1],<_task+1
 009F 0E0001            adc [__r0],>_task+1
 00A2 5000              mov A,0
 00A4 3F00              mvi [__r1],A
 00A6 8023              xjmp L17
 00A8           L16:
 00A8                   .dbline 68
 00A8           ; //                            if ((struct timer_list timer_vector[i])->data!=0) wake_up_process(((struct task_struct*) ((struct timer_list timer_vector[i])->data)));
 00A8           ;                               else {
 00A8                   .dbline 69
 00A8           ;                                       timer_event.data.timer_function();
 00A8 5203              mov A,[X+3]
 00AA 5300              mov [__r1],A
 00AC 5202              mov A,[X+2]
 00AE 5300              mov [__r0],A
 00B0 7C0000            xcall __plcall
 00B3                   .dbline 70
 00B3           ;                                       del_timer(i);
 00B3 5200              mov A,[X+0]
 00B5 5300              mov [__r1],A
 00B7 550000            mov [__r0],0
 00BA 6500              asl [__r1]
 00BC 6B00              rlc [__r0]
 00BE 060000            add [__r1],<_timer_vector
 00C1 0E0000            adc [__r0],>_timer_vector
 00C4 7600              inc [__r1]
 00C6 5000              mov A,0
 00C8 3F00              mvi [__r1],A
 00CA                   .dbline 71
 00CA           ;                               }
 00CA           L17:
 00CA                   .dbline 73
 00CA           ;                               //after timer interrupt, should have schedule again for updated process to run; do it in future; now just let programmer to yield other process, then run into this process again
 00CA           ;                       }
 00CA           L14:
 00CA                   .dbline 74
 00CA           ;               }
 00CA           L12:
 00CA           L9:
 00CA                   .dbline 62
 00CA 7700              inc [X+0]
 00CC           L11:
 00CC                   .dbline 62
 00CC 3D0003            cmp [X+0],3
 00CF A003              jz X4
 00D1 CF59              jc L8
 00D3           X4:
 00D3                   .dbline 78
 00D3           ;               
 00D3           ; //            gpio_var.timer_semop = 0;
 00D3           ; //    }
 00D3           ;       }
 00D3                   .dbline 83
 00D3           ; #endif
 00D3           ;               
 00D3           ; #if (KB_MOD==1)
 00D3           ; 
 00D3           ;       if ((++gpio_var.scan_key_timeout)%7) {
 00D3 5100              mov A,[_gpio_var]
 00D5 67                asr A
 00D6 67                asr A
 00D7 67                asr A
 00D8 67                asr A
 00D9 67                asr A
 00DA 2107              and A,7
 00DC 5300              mov [__r0],A
 00DE 260007            and [__r0],7
 00E1 060001            add [__r0],1
 00E4 5F0000            mov [__r1],[__r0]
 00E7 550000            mov [__r0],0
 00EA 260007            and [__r1],7
 00ED 260000            and [__r0],0
 00F0 550000            mov [__r3],<_gpio_var
 00F3 5F0000            mov [__r5],[_gpio_var]
 00F6 550000            mov [__r4],0
 00F9 26001F            and [__r5],31
 00FC 2600FF            and [__r4],-1
 00FF 5F0000            mov [__r7],[__r1]
 0102 5F0000            mov [__r6],[__r0]
 0105 6500              asl [__r7]
 0107 6B00              rlc [__r6]
 0109 6500              asl [__r7]
 010B 6B00              rlc [__r6]
 010D 6500              asl [__r7]
 010F 6B00              rlc [__r6]
 0111 6500              asl [__r7]
 0113 6B00              rlc [__r6]
 0115 6500              asl [__r7]
 0117 6B00              rlc [__r6]
 0119 2600E0            and [__r7],-32
 011C 260000            and [__r6],0
 011F 5100              mov A,[__r7]
 0121 2C00              or [__r5],A
 0123 5100              mov A,[__r6]
 0125 2C00              or [__r4],A
 0127 5100              mov A,[__r5]
 0129 3F00              mvi [__r3],A
 012B 5000              mov A,0
 012D 08                push A
 012E 5007              mov A,7
 0130 08                push A
 0131 5100              mov A,[__r0]
 0133 08                push A
 0134 5100              mov A,[__r1]
 0136 08                push A
 0137 7C0000            xcall __divmod_16X16_16
 013A 38FE              add SP,-2
 013C 18                pop A
 013D 5300              mov [__r1],A
 013F 18                pop A
 0140 3900              cmp A,0
 0142 B006              jnz X5
 0144 3C0000            cmp [__r1],0
 0147 A091              jz L22
 0149           X5:
 0149                   .dbline 83
 0149                   .dbline 86
 0149           ;               
 0149           ;       //      if ((gpio_var.key_fr_hi_lo&((unsigned)FR_HI_LO_ENTER))&&(!ENTER_KEY_DET)) {
 0149           ;               if ((gpio_var.key_deb_f==0)&&(!ENTER_KEY_DET)) {
 0149 5F0000            mov [__r0],[_gpio_var]
 014C 70FB              and F,-5
 014E 6E00              rrc [__r0]
 0150 260001            and [__r0],1
 0153 B074              jnz L24
 0155 490C02            tst REG[12],2
 0158 B06F              jnz L24
 015A                   .dbline 86
 015A                   .dbline 88
 015A           ;       //              gpio_var.key_fr_hi_lo &= (unsigned) ~FR_HI_LO_ENTER;                    //      in low state
 015A           ;                       gpio_var.key_deb_f = 1;
 015A 2E0002            or [_gpio_var],2
 015D 5100              mov A,[_gpio_var]
 015F           L26:
 015F                   .dbline 90
 015F           ;                       // appl. level code here for ENTER key in DOWN case
 015F           ;                       APP_ENTER_KEY_DOWN_CASE;
 015F                   .dbline 90
 015F 5002              mov A,2
 0161 08                push A
 0162 5100              mov A,[_ptr_events_vect]
 0164 67                asr A
 0165 67                asr A
 0166 67                asr A
 0167 67                asr A
 0168 210F              and A,15
 016A 08                push A
 016B 5100              mov A,[_ptr_events_vect]
 016D 210F              and A,15
 016F 08                push A
 0170 7C0000            xcall _pre_wr_cir254buf
 0173 38FD              add SP,-3
 0175 5401              mov [X+1],A
 0177 39FF              cmp A,-1
 0179 A056              jz L25
 017B                   .dbline 90
 017B                   .dbline 90
 017B 5F0000            mov [__r1],[_ptr_events_vect]
 017E 550000            mov [__r0],0
 0181 26000F            and [__r1],15
 0184 260000            and [__r0],0
 0187 060000            add [__r1],<_events_vect
 018A 0E0000            adc [__r0],>_events_vect
 018D 3E00              mvi A,[__r1]
 018F 7A00              dec [__r1]
 0191 5300              mov [__r2],A
 0193 2600F8            and [__r2],-8
 0196 2E0002            or [__r2],2
 0199 5100              mov A,[__r2]
 019B 3F00              mvi [__r1],A
 019D                   .dbline 90
 019D 5F0000            mov [__r1],[_ptr_events_vect]
 01A0 550000            mov [__r0],0
 01A3 26000F            and [__r1],15
 01A6 260000            and [__r0],0
 01A9 060000            add [__r1],<_events_vect
 01AC 0E0000            adc [__r0],>_events_vect
 01AF 3E00              mvi A,[__r1]
 01B1 7A00              dec [__r1]
 01B3 21E7              and A,-25
 01B5 3F00              mvi [__r1],A
 01B7                   .dbline 90
 01B7 5100              mov A,[_ptr_events_vect]
 01B9 21F0              and A,-16
 01BB 5300              mov [__r0],A
 01BD 5201              mov A,[X+1]
 01BF 210F              and A,15
 01C1 2C00              or [__r0],A
 01C3 5F0000            mov [_ptr_events_vect],[__r0]
 01C6                   .dbline 90
 01C6                   .dbline 90
 01C6                   .dbline 90
 01C6                   .dbline 91
 01C6 8009              xjmp L25
 01C8           L24:
 01C8                   .dbline 91
 01C8           ;               } else if (ENTER_KEY_DET) {
 01C8 490C02            tst REG[12],2
 01CB A004              jz L31
 01CD                   .dbline 91
 01CD                   .dbline 92
 01CD           ;                       gpio_var.key_deb_f = 0;
 01CD 2600FD            and [_gpio_var],-3
 01D0                   .dbline 93
 01D0           ;               }
 01D0           L31:
 01D0           L25:
 01D0                   .dbline 94
 01D0 430C02            or REG[12],2
 01D3                   .dbline 95
 01D3 430C08            or REG[12],8
 01D6                   .dbline 96
 01D6 431408            or REG[20],8
 01D9                   .dbline 100
 01D9           L22:
 01D9                   .dbline -2
 01D9                   .dbline 103
 01D9           ;               ENTER_KEY_SET_HIGH;                                                             //      restore to high level regularly
 01D9           ;               DOWN_KEY_SET_HIGH;                                                              //      since other process also use this gpio port for other function,
 01D9           ;               UPPER_KEY_SET_HIGH;                                                             //      it read this pin and write back same data.
 01D9           ;                                                                                               //      However, this pin may be at active state when user click-in
 01D9           ;                                                                                               //      then this active state will be always keep, so we need to clean regulary
 01D9           ;               //gpio_var.scan_key_timeout = 0;
 01D9           ;       }
 01D9           ; #endif
 01D9           ; 
 01D9           ; }
 01D9           L7:
 01D9 38FC              add SP,-4
 01DB 20                pop X
 01DC                   .dbline 0 ; func end
 01DC 7F                ret
 01DD                   .dbsym l i 1 c
 01DD                   .dbsym l timer_event 1 X
 01DD                   .dbsym l i 0 c
 01DD                   .dbend
 01DD                   .dbfunc e add_timer _add_timer fc
 01DD           ;              i -> X+0
 01DD           ;    ptimer_addr -> X-5
 01DD           _add_timer::
 01DD                   .dbline -1
 01DD 10                push X
 01DE 4F                mov X,SP
 01DF 3801              add SP,1
 01E1                   .dbline 111
 01E1           ; 
 01E1           ; #if (NR_TIMER_OUT>0)
 01E1           ; // parameters
 01E1           ; // return
 01E1           ; //    <0 as invalid timer
 01E1           ; //    >=0 as valid timer index
 01E1           ; char add_timer(struct timer_list* ptimer_addr)
 01E1           ; {
 01E1                   .dbline 113
 01E1           ;       char i;
 01E1           ;       for (i=0;i<NR_TIMER_OUT;i++)                                                    // chk struct timer vector for old one
 01E1 560000            mov [X+0],0
 01E4 803E              xjmp L37
 01E6           L34:
 01E6                   .dbline 115
 01E6           ; #if (CYPRESS_PSOC_RAM_UNDER_256==1)
 01E6           ;               if ((((unsigned int)timer_vector[i])&0x00ff)==(((unsigned int)ptimer_addr)&0x00ff))
 01E6 5200              mov A,[X+0]
 01E8 5300              mov [__r1],A
 01EA 550000            mov [__r0],0
 01ED 6500              asl [__r1]
 01EF 6B00              rlc [__r0]
 01F1 060000            add [__r1],<_timer_vector
 01F4 0E0000            adc [__r0],>_timer_vector
 01F7 3E00              mvi A,[__r1]
 01F9 5300              mov [__r0],A
 01FB 3E00              mvi A,[__r1]
 01FD 5300              mov [__r1],A
 01FF 2600FF            and [__r1],-1
 0202 260000            and [__r0],0
 0205 52FC              mov A,[X-4]
 0207 21FF              and A,-1
 0209 5300              mov [__r3],A
 020B 52FB              mov A,[X-5]
 020D 2100              and A,0
 020F 5300              mov [__r2],A
 0211 5100              mov A,[__r0]
 0213 3A00              cmp A,[__r2]
 0215 B00B              jnz L38
 0217 5100              mov A,[__r1]
 0219 3A00              cmp A,[__r3]
 021B B005              jnz L38
 021D           X6:
 021D                   .dbline 123
 021D           ;               // compiler problem in :
 021D           ;               //      CY27CXXXX has 256 bytes RAM only, so the higher byte of 16-bit data is don't care. 
 021D           ;               //      however, compiler of psoc is don't care the higher byte in parameter input(RAM address data) in subr.
 021D           ;               //      this compiler is still handle the higher byte when comparing RAM address data
 021D           ; #else
 021D           ;               if (timer_vector[i]==ptimer_addr)
 021D           ; #endif
 021D           ;                       return i;
 021D 5200              mov A,[X+0]
 021F 805C              xjmp L33
 0221           L38:
 0221           L35:
 0221                   .dbline 113
 0221 7700              inc [X+0]
 0223           L37:
 0223                   .dbline 113
 0223 3D0003            cmp [X+0],3
 0226 A003              jz X7
 0228 CFBD              jc L34
 022A           X7:
 022A                   .dbline 124
 022A           ;       for (i=0;i<NR_TIMER_OUT;i++)                                                    //              find out the empty place for new timer
 022A 560000            mov [X+0],0
 022D 8025              xjmp L43
 022F           L40:
 022F                   .dbline 125
 022F           ;               if (timer_vector[i]==0)
 022F 5200              mov A,[X+0]
 0231 5300              mov [__r1],A
 0233 550000            mov [__r0],0
 0236 6500              asl [__r1]
 0238 6B00              rlc [__r0]
 023A 060000            add [__r1],<_timer_vector
 023D 0E0000            adc [__r0],>_timer_vector
 0240 3E00              mvi A,[__r1]
 0242 5300              mov [__r0],A
 0244 3E00              mvi A,[__r1]
 0246 3C0000            cmp [__r0],0
 0249 B007              jnz L44
 024B 3900              cmp A,0
 024D B003              jnz L44
 024F           X8:
 024F                   .dbline 126
 024F           ;                       break;
 024F 800A              xjmp L42
 0251           L44:
 0251           L41:
 0251                   .dbline 124
 0251 7700              inc [X+0]
 0253           L43:
 0253                   .dbline 124
 0253 3D0003            cmp [X+0],3
 0256 A003              jz X9
 0258 CFD6              jc L40
 025A           X9:
 025A           L42:
 025A                   .dbline 127
 025A           ;       if (i==NR_TIMER_OUT) {
 025A 3D0003            cmp [X+0],3
 025D B005              jnz L46
 025F                   .dbline 127
 025F                   .dbline 128
 025F           ;               return (char) -1;
 025F 50FF              mov A,-1
 0261 801A              xjmp L33
 0263           L46:
 0263                   .dbline 130
 0263           ;       }
 0263           ;       timer_vector[i] = ptimer_addr;
 0263 5200              mov A,[X+0]
 0265 5300              mov [__r1],A
 0267 550000            mov [__r0],0
 026A 6500              asl [__r1]
 026C 6B00              rlc [__r0]
 026E 060000            add [__r1],<_timer_vector
 0271 0E0000            adc [__r0],>_timer_vector
 0274 7600              inc [__r1]
 0276 52FC              mov A,[X-4]
 0278 3F00              mvi [__r1],A
 027A                   .dbline 131
 027A           ;       return i;
 027A 5200              mov A,[X+0]
 027C                   .dbline -2
 027C           L33:
 027C 38FF              add SP,-1
 027E 20                pop X
 027F                   .dbline 0 ; func end
 027F 7F                ret
 0280                   .dbsym l i 0 c
 0280                   .dbsym l ptimer_addr -5 pX
 0280                   .dbend
 0280                   .dbfunc e _malarm __malarm fc
 0280           ;          timer -> X-8
 0280           ;    jiffies_cnt -> X-6
 0280           ;       function -> X-5
 0280           __malarm::
 0280                   .dbline -1
 0280 10                push X
 0281 4F                mov X,SP
 0282                   .dbline 159
 0282           ; }
 0282           ; 
 0282           ; /*void del_timer(unsigned char timer_num)
 0282           ; {
 0282           ;       timer_vector[timer_num] = 0; 
 0282           ; }
 0282           ; 
 0282           ; void sleep(unsigned char sec)
 0282           ; {
 0282           ;       schedule_timeout(sec * 100);
 0282           ; }*/
 0282           ; 
 0282           ; /*void alarm(p_func function, unsigned char sec)
 0282           ; {
 0282           ;       struct timer_list timer;
 0282           ;       timer.expires = sec*100 + jiffies;
 0282           ;       timer.data = 0;
 0282           ;       timer.function = function;
 0282           ;       add_timer(&timer);
 0282           ; }*/
 0282           ; 
 0282           ; // parameters
 0282           ; //    jiffies_cnt -- should not be ZERO
 0282           ; // return
 0282           ; //    <0 as invalid timer
 0282           ; //    >=0 as valid timer index
 0282           ; char _malarm(p_func function, unsigned char jiffies_cnt, struct timer_list* timer)
 0282           ; {
 0282                   .dbline 163
 0282           ; //    char i = (char) -1;
 0282           ; //    if (gpio_var.timer_semop==0) {
 0282           ; //            gpio_var.timer_semop = 1;
 0282           ;               timer->expires = jiffies_cnt + jiffies;
 0282 52F9              mov A,[X-7]
 0284 5300              mov [__r1],A
 0286 52FA              mov A,[X-6]
 0288 0206              add A,[_jiffies]
 028A 3F00              mvi [__r1],A
 028C                   .dbline 165
 028C           ; //            timer->data.timer_function = (p_func) function;// outside to do it, after solve this problem, enable this
 028C           ;               return add_timer(timer);
 028C 52F8              mov A,[X-8]
 028E 08                push A
 028F 52F9              mov A,[X-7]
 0291 08                push A
 0292 9F49              xcall _add_timer
 0294 38FE              add SP,-2
 0296                   .dbline -2
 0296           L48:
 0296 20                pop X
 0297                   .dbline 0 ; func end
 0297 7F                ret
 0298                   .dbsym l timer -8 pX
 0298                   .dbsym l jiffies_cnt -6 c
 0298                   .dbsym l function -5 pfX
 0298                   .dbend
                        .area bss(ram, con, rel)
 0000                   .dbfile ./timer.c
 0000           _timer_vector::
 0000                   .blkb 6
 0006                   .dbsym e timer_vector _timer_vector A[6:3]pX
 0006           _jiffies::
 0006                   .blkb 1
 0007                   .dbsym e jiffies _jiffies c
