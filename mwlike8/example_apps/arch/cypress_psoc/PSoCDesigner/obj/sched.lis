                        .module sched.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./sched.c
 0000                   .dbfunc e sched_init _sched_init fV
 0000           _sched_init::
 0000                   .dbline -1
 0000                   .dbline 27
 0000           ; /*
 0000           ;  *    kernel/sched.c
 0000           ;  *
 0000           ;  *    Kernel scheduler and related syscalls
 0000           ;  *
 0000           ;  *    09-04-2004      yan     create this following linux
 0000           ;  */
 0000           ; 
 0000           ; #include "app.h"
 0000           ; #include "sched.h"
 0000           ; #include "current.h"                                                                  // MUST be placed after sched.h
 0000           ; #include "system.h"
 0000           ; #include "timer.h"                                                                    // timer_list
 0000           ; 
 0000           ; void sched_init(void);
 0000           ; struct task_struct task[NR_TASKS];
 0000           ; #if (CONTEXT_SW==1)
 0000           ; unsigned char current_ptr;
 0000           ; unsigned char next_ptr;
 0000           ; #endif
 0000           ; 
 0000           ; #if (AUTO_ZERO==0)
 0000           ; extern void init_timer(void);
 0000           ; #endif
 0000           ; 
 0000           ; void sched_init(void)
 0000           ; {
 0000           L3:
 0000                   .dbline 43
 0000                   .dbline 43
 0000 550003                    mov [__r1],<_task                                               ;       _task+0, so stack ptr
 0003                   ;mov [__r0],>_task 
 0003 4E                swap A, SP 
 0004 3F00              mvi [__r1], A 
 0006 4E                swap A, SP 
 0007                   
 0007           
 0007                   .dbline 43
 0007           L4:
 0007                   .dbline 43
 0007           ;       //unsigned char cpu = smp_processor_id();                                       // get existing process id
 0007           ;       //init_task.processor = cpu;
 0007           ; 
 0007           ; #if (AUTO_ZERO==0)
 0007           ;       init_timer();
 0007           ; #endif
 0007           ; 
 0007           ;                               // the following does not same to linux
 0007           ;                               // init. process 0
 0007           ; #if (AUTO_ZERO==0)
 0007           ; #if (CONTEXT_SW==1)
 0007           ;       current_ptr = 0;
 0007           ;       next_ptr = 0;
 0007           ; #endif
 0007           ; #endif
 0007           ;       get_process0_sp();                                                              // task[0].stack_ptr = SP, since Process0 is also starting from this layer, see main.c
 0007                   .dbline 44
 0007           ;       wake_up_process(current);
 0007 5F0002            mov [__r1],[_current_ptr]
 000A 550000            mov [__r0],0
 000D 6500              asl [__r1]
 000F 6B00              rlc [__r0]
 0011 060004            add [__r1],<_task+1
 0014 0E0004            adc [__r0],>_task+1
 0017 5000              mov A,0
 0019 3F00              mvi [__r1],A
 001B                   .dbline -2
 001B                   .dbline 45
 001B           ; }
 001B           L2:
 001B                   .dbline 0 ; func end
 001B 7F                ret
 001C                   .dbend
 001C                   .dbfunc e schedule _schedule fV
 001C           _schedule::
 001C                   .dbline -1
 001C                   .dbline 57
 001C           ; 
 001C           ; //void wake_up_process(struct task_struct* p)
 001C           ; //{
 001C           ; //    p->state = TASK_RUNNING;
 001C           ; //}
 001C           ; 
 001C           ; #if (CONTEXT_SW==1)
 001C           ;               // Description : each time kernel arrange different processes to run, this schedule must be called, so try to min. the code and RAM
 001C           ;               //                      global variables declaration, since reduce time to declar in local and save memory in each time stack
 001C           ; struct task_struct *prev;                                             
 001C           ; void schedule(void)
 001C           ; {
 001C                   .dbline 58
 001C           ;       cli();
 001C 70FE                      and F, FEh
 001E           
 001E                   .dbline 59
 001E           ;       prev = current;
 001E 5F0002            mov [__r1],[_current_ptr]
 0021 550000            mov [__r0],0
 0024 6500              asl [__r1]
 0026 6B00              rlc [__r0]
 0028 5100              mov A,[__r1]
 002A 0103              add A,<_task
 002C 5301              mov [_prev+1],A
 002E 5100              mov A,[__r0]
 0030 0903              adc A,>_task
 0032 5300              mov [_prev],A
 0034           L8:
 0034                   .dbline 60
 0034           ;       do {                                                                            // seek next running state process
 0034                   .dbline 61
 0034           ;               if (next_ptr==0) {                                                              //      just normal sched for next
 0034 3C0700            cmp [_next_ptr],0
 0037 B00D              jnz L11
 0039                   .dbline 61
 0039                   .dbline 62
 0039           ;                       current_ptr++;                                                  //              method A => choose this method, since it is more save RAM and ROM code studied from assembly code, at least in cypress PSoC, verify other mcus, and think about what is the good implement method from C
 0039 7602              inc [_current_ptr]
 003B                   .dbline 63
 003B           ;                       if (current_ptr==NR_TASKS) current_ptr = 0;
 003B 3C0202            cmp [_current_ptr],2
 003E B00C              jnz L12
 0040                   .dbline 63
 0040 550200            mov [_current_ptr],0
 0043                   .dbline 65
 0043 8007              xjmp L12
 0045           L11:
 0045                   .dbline 65
 0045           ;                       //current_ptr = ((current_ptr++) == NR_TASKS) ? 0 :;            //              method B
 0045           ;               } else {                                                                //      any urge process
 0045                   .dbline 66
 0045           ;                       current_ptr = next_ptr;
 0045 5F0207            mov [_current_ptr],[_next_ptr]
 0048                   .dbline 67
 0048           ;                       next_ptr = 0;
 0048 550700            mov [_next_ptr],0
 004B                   .dbline 68
 004B           ;               }
 004B           L12:
 004B                   .dbline 69
 004B           L9:
 004B                   .dbline 69
 004B           ;       } while (current->state!=TASK_RUNNING);
 004B 5F0002            mov [__r1],[_current_ptr]
 004E 550000            mov [__r0],0
 0051 6500              asl [__r1]
 0053 6B00              rlc [__r0]
 0055 060004            add [__r1],<_task+1
 0058 0E0004            adc [__r0],>_task+1
 005B 3E00              mvi A,[__r1]
 005D BFD6              jnz L8
 005F                   .dbline 70
 005F 5F0002            mov [__r1],[_current_ptr]
 0062 550000            mov [__r0],0
 0065 6500              asl [__r1]
 0067 6B00              rlc [__r0]
 0069 060003            add [__r1],<_task
 006C 0E0003            adc [__r0],>_task
 006F 5100              mov A,[_prev]
 0071 3A00              cmp A,[__r0]
 0073 B007              jnz X0
 0075 5101              mov A,[_prev+1]
 0077 3A00              cmp A,[__r1]
 0079 A01C              jz L16
 007B           X0:
 007B           L18:
 007B                   .dbline 70
 007B                   .dbline 70
 007B                           ;add SP,-2                                                              ; remove yield() return address 
 007B 10                push X                                                          ; keep X index register
 007C 4E                swap A, SP 
 007D                                                                           ; save previous stack pointer, mov p->SP, SP
 007D 5F0001            mov [__r1], [_prev+1]
 0080 3F00              mvi [__r1], A                                                   ;       __r1 + 0, so stack ptr
 0082 5F0002            mov [__r1],[_current_ptr]                                       ; get next stack pointer, mov SP, n->SP
 0085 550000            mov [__r0],0 
 0088 6500              asl [__r1] 
 008A 6B00              rlc [__r0] 
 008C 060003            add [__r1],<_task                                               ;       _task+0, so stack ptr
 008F 0E0003            adc [__r0],>_task 
 0092 3E00              mvi A,[__r1] 
 0094 4E                swap A, SP 
 0095 20                pop X
 0096                   
 0096           
 0096                   .dbline 70
 0096           L19:
 0096                   .dbline 70
 0096           ;       if (prev!=current) switch_to();
 0096           L16:
 0096                   .dbline 71
 0096           ;       sti();
 0096 7101                      or  F, 01h
 0098           
 0098                   .dbline -2
 0098                   .dbline 72
 0098           ; }
 0098           L7:
 0098                   .dbline 0 ; func end
 0098 7F                ret
 0099                   .dbend
 0099                   .dbfunc e schedule_timeout _schedule_timeout fV
 0099           ;              i -> X+3
 0099           ;          timer -> X+0
 0099           ; millisec_time_10 -> X-4
 0099           _schedule_timeout::
 0099                   .dbline -1
 0099 10                push X
 009A 4F                mov X,SP
 009B 3804              add SP,4
 009D                   .dbline 104
 009D           ; 
 009D           ; //void sys_sched_yield(void)
 009D           ; //{
 009D           ; //
 009D           ; //}
 009D           ; //void sched_yield(void)
 009D           ; //{
 009D           ;       //set_current_state(TASK_RUNNING);                                              // already in running state
 009D           ;       //sys_sched_yield();
 009D           ; //    schedule();
 009D           ; //}
 009D           ; 
 009D           ; #if (TIMER_MOD==1)                    
 009D           ;               // Remarks 
 009D           ;               //      * max. of time for sleep is 256Sec
 009D           ; extern char add_timer(struct timer_list* ptimer_addr);
 009D           ; //extern void del_timer(unsigned char timer_num);
 009D           ; /*void schedule_timeout(unsigned char sec)
 009D           ; {
 009D           ;       unsigned char i;
 009D           ;       struct timer_list timer;
 009D           ;       current->state = TASK_INTERRUPTIBLE;
 009D           ;       timer.expires = sec * 100 + jiffies;                                            // since 10mSec for 1 tick, so X100
 009D           ;       timer.data = (unsigned int) current;
 009D           ;       //timer.function = process_timeout;
 009D           ;       i = add_timer(&timer);
 009D           ;       schedule();
 009D           ;       del_timer(i);
 009D           ; }*/
 009D           ;               // must in times of 10mSec
 009D           ; void schedule_timeout(unsigned char millisec_time_10)
 009D           ; {
 009D                   .dbline 107
 009D           ;       unsigned char i;
 009D           ;       struct timer_list timer;
 009D           ;       timer.expires = millisec_time_10 + jiffies;                                     // since 10mSec for 1 tick, so X100
 009D 52FC              mov A,[X-4]
 009F 0200              add A,[_jiffies]
 00A1 5400              mov [X+0],A
 00A3                   .dbline 108
 00A3           ;       timer.data.timer_data = (0xff00 | ((unsigned int) current_ptr));                // related to timer.c only
 00A3 5102              mov A,[_current_ptr]
 00A5 2900              or A,0
 00A7 5402              mov [X+2],A
 00A9 5000              mov A,0
 00AB 29FF              or A,-1
 00AD 5401              mov [X+1],A
 00AF                   .dbline 110
 00AF           ;       //timer.data = (unsigned int) current;
 00AF           ;       if ((i = add_timer(&timer))>=0) current->state = TASK_INTERRUPTIBLE;
 00AF 5000              mov A,0
 00B1 08                push A
 00B2 10                push X
 00B3 7C0000            xcall _add_timer
 00B6 38FE              add SP,-2
 00B8 5403              mov [X+3],A
 00BA 3900              cmp A,0
 00BC A003              jz X1
 00BE C015              jc L23
 00C0           X1:
 00C0                   .dbline 110
 00C0 5F0002            mov [__r1],[_current_ptr]
 00C3 550000            mov [__r0],0
 00C6 6500              asl [__r1]
 00C8 6B00              rlc [__r0]
 00CA 060004            add [__r1],<_task+1
 00CD 0E0004            adc [__r0],>_task+1
 00D0 5001              mov A,1
 00D2 3F00              mvi [__r1],A
 00D4           L23:
 00D4                   .dbline 111
 00D4 9F46              xcall _schedule
 00D6                   .dbline 112
 00D6 3D0300            cmp [X+3],0
 00D9 A003              jz X2
 00DB C018              jc L26
 00DD           X2:
 00DD                   .dbline 112
 00DD 5203              mov A,[X+3]
 00DF 5300              mov [__r1],A
 00E1 550000            mov [__r0],0
 00E4 6500              asl [__r1]
 00E6 6B00              rlc [__r0]
 00E8 060000            add [__r1],<_timer_vector
 00EB 0E0000            adc [__r0],>_timer_vector
 00EE 7600              inc [__r1]
 00F0 5000              mov A,0
 00F2 3F00              mvi [__r1],A
 00F4           L26:
 00F4                   .dbline -2
 00F4                   .dbline 113
 00F4           ;       schedule();                                                                     // when switching, struct timer_list timer staying be kept
 00F4           ;       if (i>=0) del_timer(i);
 00F4           ; }
 00F4           L21:
 00F4 38FC              add SP,-4
 00F6 20                pop X
 00F7                   .dbline 0 ; func end
 00F7 7F                ret
 00F8                   .dbsym l i 3 c
 00F8                   .dbsym l timer 0 X
 00F8                   .dbsym l millisec_time_10 -4 c
 00F8                   .dbend
                        .area bss(ram, con, rel)
 0000                   .dbfile ./sched.c
 0000           _prev::
 0000                   .blkb 2
 0002                   .dbsym e prev _prev pX
 0002           _current_ptr::
 0002                   .blkb 1
 0003                   .dbsym e current_ptr _current_ptr c
 0003           _task::
 0003                   .blkb 4
 0007                   .dbsym e task _task A[4:2]X
 0007           _next_ptr::
 0007                   .blkb 1
 0008                   .dbsym e next_ptr _next_ptr c
