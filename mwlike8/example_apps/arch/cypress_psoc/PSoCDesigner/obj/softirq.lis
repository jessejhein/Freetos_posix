                        .module softirq.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./softirq.c
 0000                   .dbfunc e softirq_init _softirq_init fV
 0000           _softirq_init::
 0000                   .dbline -1
 0000                   .dbline 24
 0000           ; /*
 0000           ;  *    kernel/softirq.c
 0000           ;  *
 0000           ;  *    29-04-2004      yan     create this following linux
 0000           ;  *
 0000           ;  */
 0000           ; 
 0000           ; #include "app.h"
 0000           ; #include "system.h"                                                                   // sti             
 0000           ; #include "hardirq.h"                                                                  // irq_cpustat.h, in_interrupt
 0000           ; #include "irq_cpustat.h"                                                              // irq_cpustat_t
 0000           ; #include "softirq.h"                                                                  // local_bh_disable
 0000           ; #include "sched.h"                                                                    // schedule()
 0000           ; 
 0000           ; irq_cpustat_t irq_stat[1];                                                            // must be '1', since linlike8 just support single MCU; where to init. in linux ???
 0000           ; unsigned char softirq_vec;
 0000           ; 
 0000           ; #if (TIMER_MOD==1)                    
 0000           ; extern void timer_softirq(void);
 0000           ; #endif                                                                   
 0000           ; extern void gpio_softirq(void);
 0000           ; 
 0000           ; void softirq_init(void)
 0000           ; {
 0000                   .dbline -2
 0000                   .dbline 29
 0000           ; #if (AUTO_ZERO==0)
 0000           ;       softirq_vec = 0;
 0000           ;       irq_stat[0].__local_softirq_count = 0;
 0000           ; #endif
 0000           ; }
 0000           L2:
 0000                   .dbline 0 ; func end
 0000 7F                ret
 0001                   .dbend
 0001                   .dbfunc e do_softirq _do_softirq fV
 0001           _do_softirq::
 0001                   .dbline -1
 0001                   .dbline 32
 0001           ;                       
 0001           ; void do_softirq(void)
 0001           ; {
 0001                   .dbline 33
 0001           ;       if (in_interrupt()) return;                                                     // if any previous soft irq is running, avoid nesting, return to let it to run cont., current soft irq will be run after previous by looping
 0001 3C0100            cmp [_irq_stat],0
 0004 A003              jz L4
 0006                   .dbline 33
 0006 8026              xjmp L3
 0008           L4:
 0008           L6:
 0008                   .dbline 34
 0008                   .dbline 34
 0008 7601              inc [_irq_stat]
 000A                   .dbline 34
 000A           L7:
 000A                   .dbline 34
 000A           ;       local_softirq_disable();
 000A                   .dbline 35
 000A           ;       sti();                                                                          // start to enable interrupt again
 000A 7101                      or  F, 01h
 000C           
 000C 8019              xjmp L10
 000E           L9:
 000E                   .dbline 36
 000E           ;       while (softirq_vec) {
 000E                   .dbline 38
 000E           ; #if (TIMER_MOD==1)                    
 000E           ;               if (softirq_vec&0x01) {timer_softirq();softirq_vec&=~0x01;}             // timer is always has interrupt, so let it to chk and do 1st to reduce each interrupt time consuming
 000E 470001            tst [_softirq_vec],1
 0011 A009              jz L12
 0013                   .dbline 38
 0013                   .dbline 38
 0013 7C0000            xcall _timer_softirq
 0016                   .dbline 38
 0016 2600FE            and [_softirq_vec],-2
 0019                   .dbline 38
 0019 800C              xjmp L13
 001B           L12:
 001B                   .dbline 39
 001B           ;               else if (softirq_vec&0x02) {gpio_softirq();softirq_vec&=~0x02;}
 001B 470002            tst [_softirq_vec],2
 001E A007              jz L14
 0020                   .dbline 39
 0020                   .dbline 39
 0020 7C0000            xcall _gpio_softirq
 0023                   .dbline 39
 0023 2600FD            and [_softirq_vec],-3
 0026                   .dbline 39
 0026           L14:
 0026           L13:
 0026                   .dbline 46
 0026           L10:
 0026                   .dbline 36
 0026 3C0000            cmp [_softirq_vec],0
 0029 BFE4              jnz L9
 002B           L16:
 002B                   .dbline 47
 002B                   .dbline 47
 002B 7A01              dec [_irq_stat]
 002D                   .dbline 47
 002D           L17:
 002D                   .dbline 47
 002D           ; #else
 002D           ;               if (softirq_vec&0x02) {gpio_softirq();softirq_vec&=~0x02;}
 002D           ; #endif
 002D           ;               //else if (softirq_vec&0x04) ;                                          // after complete one softirq, directly go to while loop goto chk and out
 002D           ;               // ... 
 002D           ;               
 002D           ;       }
 002D           ;       local_softirq_enable();
 002D                   .dbline -2
 002D                   .dbline 51
 002D           ; #if (AUTO_SW_MOD==1)
 002D           ;       schedule();
 002D           ; #endif
 002D           ; }
 002D           L3:
 002D                   .dbline 0 ; func end
 002D 7F                ret
 002E                   .dbend
                        .area bss(ram, con, rel)
 0000                   .dbfile ./softirq.c
 0000           _softirq_vec::
 0000                   .blkb 1
 0001                   .dbsym e softirq_vec _softirq_vec c
 0001           _irq_stat::
 0001                   .blkb 1
 0002                   .dbsym e irq_stat _irq_stat A[1:1]X
