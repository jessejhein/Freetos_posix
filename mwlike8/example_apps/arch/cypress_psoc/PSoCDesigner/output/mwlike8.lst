        0000: 7D 00 68 LJMP  0x0068
        0003: 30       HALT  
FILE: .\boot.asm
(0001) ; Generated by PSoC Designer ver 4.1 b931 : 21 January, 2004
(0002) ;
(0003) ;@Id: boot.tpl#46 @
(0004) ;=============================================================================
(0005) ;  FILENAME:   boot.asm
(0006) ;  VERSION:    4.04
(0007) ;  DATE:       18 November 2003
(0008) ;
(0009) ;  DESCRIPTION:
(0010) ;  M8C Boot Code for CY8C27xxx microcontroller family.
(0011) ;
(0012) ;  Copyright (C) Cypress MicroSystems 2001-2003. All rights reserved.
(0013) ;
(0014) ; NOTES:
(0015) ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
(0016) ; the project's root directory to create BOOT.ASM. Any changes made to 
(0017) ; BOOT.ASM will be  overwritten every time the project is generated; therfore
(0018) ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
(0019) ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
(0020) ; are not accidentally modified.
(0021) ;
(0022) ;=============================================================================
(0023) 
(0024) include ".\lib\GlobalParams.inc"
(0025) include "m8c.inc"
(0026) include "m8ssc.inc"
(0027) 
(0028) ;-----------------------------------------------------------------------------
(0029) ; Optimization flags
(0030) ;-----------------------------------------------------------------------------
(0031) C_LANGUAGE_SUPPORT: equ 1   ;Set to 0 to optimize for ASM only
(0032) 
(0033) ;-----------------------------------------------------------------------------
(0034) ; The following equate is required for proper operation. Reseting its value
(0035) ; is discouraged.  WAIT_FOR_32K is effective only if the crystal oscillator is
(0036) ; selected.  If the designer chooses to not wait then the ECO and PLL_Lock
(0037) ; processes must take place within user code. See the family data sheet for 
(0038) ; the requirements of starting the ECO and PLL lock mode.
(0039) ;-----------------------------------------------------------------------------
(0040) WAIT_FOR_32K:       equ 1   ; Wait for Crystal to start before allowing main()
(0041) 
(0042) ;-----------------------------------------------------------------------------
(0043) ; Export Declarations
(0044) ;-----------------------------------------------------------------------------
(0045) 
(0046) export __Start
(0047) export __Exit
(0048) export __bss_start
(0049) 
(0050) export __lit_start
(0051) export __idata_start
(0052) export __data_start
(0053) export __func_lit_start
(0054) export __text_start
(0055) export __usermodules_start
(0056) export __psoc_config_start
(0057) 
(0058) ;-----------------------------------------------------------------------------
(0059) ; Interrupt Vector Table
(0060) ;-----------------------------------------------------------------------------
(0061) ;
(0062) ; Interrupt vector table entries are 4 bytes long and contain the code that
(0063) ; services the interrupt (or causes it to be serviced).
(0064) ;
(0065) ;-----------------------------------------------------------------------------
(0066) 
(0067)     AREA    TOP(ROM,ABS,CON)
(0068) 
(0069)     org 0                   ;Reset Interrupt Vector
(0070)     ljmp __Start             ;First instruction executed following a Reset
(0071) 
(0072)     org 04h                 ;Supply Monitor Interrupt Vector
(0073)     halt                    ;Stop execution if power falls too low
        0004: 30       HALT  
        0005: 30       HALT  
        0006: 30       HALT  
        0007: 30       HALT  
(0074) 
(0075)     org 08h                 ;Analog Column 0 Interrupt Vector
(0076)     // call	void_handler
(0077)     reti
        0008: 7E       RETI  
        0009: 30       HALT  
        000A: 30       HALT  
        000B: 30       HALT  
(0078) 
(0079)     org 0Ch                 ;Analog Column 1 Interrupt Vector
(0080)     // call	void_handler
(0081)     reti
        000C: 7E       RETI  
        000D: 30       HALT  
        000E: 30       HALT  
        000F: 30       HALT  
(0082) 
(0083)     org 10h                 ;Analog Column 2 Interrupt Vector
(0084)     // call	void_handler
(0085)     reti
        0010: 7E       RETI  
        0011: 30       HALT  
        0012: 30       HALT  
        0013: 30       HALT  
(0086) 
(0087)     org 14h                 ;Analog Column 3 Interrupt Vector
(0088)     // call	void_handler
(0089)     reti
        0014: 7E       RETI  
        0015: 30       HALT  
        0016: 30       HALT  
        0017: 30       HALT  
(0090)     
(0091)     org 18h                 ;VC3 Interrupt Vector
(0092)     // call	void_handler
(0093)     reti
        0018: 7E       RETI  
        0019: 30       HALT  
        001A: 30       HALT  
        001B: 30       HALT  
(0094)     
(0095)     org 1Ch                 ;GPIO Interrupt Vector
(0096) 	;ljmp	PSoC_GPIO_ISR
(0097) 	ljmp	_gpio_isr
        001C: 7D 0A BC LJMP  _gpio_isr
(0098)     reti
        001F: 7E       RETI  
(0099)     
(0100)     org 20h                 ;PSoC Block DBB00 Interrupt Vector
(0101)     // call	void_handler
(0102)     reti
        0020: 7E       RETI  
        0021: 30       HALT  
        0022: 30       HALT  
        0023: 30       HALT  
(0103) 
(0104)     org 24h                 ;PSoC Block DBB01 Interrupt Vector
(0105)     // call	void_handler
(0106)     reti
        0024: 7E       RETI  
        0025: 30       HALT  
        0026: 30       HALT  
        0027: 30       HALT  
(0107) 
(0108)     org 28h                 ;PSoC Block DCB02 Interrupt Vector
(0109)     // call	void_handler
(0110)     reti
        0028: 7E       RETI  
        0029: 30       HALT  
        002A: 30       HALT  
        002B: 30       HALT  
(0111) 
(0112)     org 2Ch                 ;PSoC Block DCB03 Interrupt Vector
(0113) 	;ljmp	_UART_1_RX_ISR
(0114) 	ljmp	_serial_rx_isr
        002C: 7D 16 79 LJMP  _serial_rx_isr
(0115)     reti
        002F: 7E       RETI  
(0116) 
(0117)     org 30h                 ;PSoC Block DBB10 Interrupt Vector
(0118)     // call	void_handler
(0119)     reti
        0030: 7E       RETI  
        0031: 30       HALT  
        0032: 30       HALT  
        0033: 30       HALT  
(0120) 
(0121)     org 34h                 ;PSoC Block DBB11 Interrupt Vector
(0122)     // call	void_handler
(0123)     reti
        0034: 7E       RETI  
        0035: 30       HALT  
        0036: 30       HALT  
        0037: 30       HALT  
(0124) 
(0125)     org 38h                 ;PSoC Block DCB12 Interrupt Vector
(0126) 	;ljmp	_UART_1_TX_ISR
(0127) 	ljmp	_serial_tx_isr
        0038: 7D 15 AE LJMP  _serial_tx_isr
(0128)     reti
        003B: 7E       RETI  
(0129) 
(0130)     org 3Ch                 ;PSoC Block DCB13 Interrupt Vector
(0131) 	;ljmp	_Timer8_1_ISR
(0132) 	ljmp	_timer_interrupt
        003C: 7D 1B E5 LJMP  _timer_interrupt
(0133)     reti
        003F: 7E       RETI  
        0040: 30       HALT  
        0041: 30       HALT  
        0042: 30       HALT  
        0043: 30       HALT  
        0044: 30       HALT  
        0045: 30       HALT  
        0046: 30       HALT  
        0047: 30       HALT  
        0048: 30       HALT  
        0049: 30       HALT  
        004A: 30       HALT  
        004B: 30       HALT  
        004C: 30       HALT  
        004D: 30       HALT  
        004E: 30       HALT  
        004F: 30       HALT  
        0050: 30       HALT  
        0051: 30       HALT  
        0052: 30       HALT  
        0053: 30       HALT  
        0054: 30       HALT  
        0055: 30       HALT  
        0056: 30       HALT  
        0057: 30       HALT  
        0058: 30       HALT  
        0059: 30       HALT  
        005A: 30       HALT  
        005B: 30       HALT  
        005C: 30       HALT  
        005D: 30       HALT  
        005E: 30       HALT  
        005F: 30       HALT  
(0134) 	
(0135)     // 40h through 5Fh are reserved for future products
(0136) 
(0137)     org 60h                 ;PSoC I2C Interrupt Vector
(0138)     // call	void_handler
(0139)     reti
        0060: 7E       RETI  
        0061: 30       HALT  
        0062: 30       HALT  
        0063: 30       HALT  
(0140) 
(0141)     org 64h                 ;Sleep Timer Interrupt Vector
(0142)     // call	void_handler
(0143)     reti
        0064: 7E       RETI  
        0065: 30       HALT  
        0066: 30       HALT  
        0067: 30       HALT  
(0144) 
(0145) ;-----------------------------------------------------------------------------
(0146) ;  Start of Execution
(0147) ;  CPU is operating at 3 MHz, change to 12 MHz
(0148) ;  IO Bank is Bank0
(0149) ;-----------------------------------------------------------------------------
(0150)     org 68h
(0151) __Start:
(0152) IF (WATCHDOG_ENABLE)
(0153)     M8C_EnableWatchDog      ;Enable the WDT if selected in Global Params
(0154) ENDIF
(0155) IF (SELECT_32K)
(0156)     or  reg[CPU_SCR1],CPU_SCR1_ECO_ALLOWED    ;ECO will be used in this project
(0157) ELSE
(0158)     and reg[CPU_SCR1],~CPU_SCR1_ECO_ALLOWED   ;Prevent ECO from being enabled
        0068: 41 FE FB AND   REG[254],251
(0159) ENDIF
(0160)     ;-------------------------------------------------------------------------
(0161)     ; Set the AGND Bypass bit. This is found in the BandGap Trim register, so
(0162)     ; the trim value must be read from the Trim Table. That is all that is 
(0163)     ; done for 5V operation if the AGND Bypass pin is chosen. For 3.3V
(0164)     ; operation the IMO Clock and BandGap trim registers always have to be set
(0165)     ; (they default to 5V trims).
(0166)     ;-------------------------------------------------------------------------
(0167) IF (SUPPLY_VOLTAGE)                ; 1 means 5.0V
(0168) IF (AGND_BYPASS)                   ; need to set the AGNDBYP bit in BDG_TR
(0169)     mov  [bSSC_TABLE_TableId],1    ; Point to the Trim table
(0170)     SSC_Action TABLE_READ          ; Perform a table read supervisor call
(0171)     M8C_SetBank1
(0172)     mov  A,[VOLTAGE_TRIM_5V]       ; Get the bandgap trim seting for 5V 
(0173)     or   A,AGND_BYPASS_JUST        ; OR in the bypass setting
(0174)     mov  reg[BDG_TR],A             ; Update the register value
(0175)     M8C_SetBank0
(0176) ENDIF
(0177) ELSE                               ; 0 means 3.3V
(0178)     mov  [bSSC_TABLE_TableId],1    ; Point to the Trim table
(0179)     SSC_Action TABLE_READ          ; Perform a table read supervisor call
(0180)     M8C_SetBank1
(0181)     mov  A,[OSCILLATOR_TRIM_3V]   
(0182)     mov  reg[IMO_TR],A             ; Load the 3V trim oscillator setting
(0183)     mov  A,[VOLTAGE_TRIM_3V]
(0184)     or   A,AGND_BYPASS_JUST        ; OR in the bypass setting
(0185)     mov  reg[BDG_TR],A             ; Load the bandgap trim setting for 3V
(0186)     M8C_SetBank0
(0187) ENDIF ;(SUPPLY_VOLTAGE)
(0188) 
(0189)     mov  [bSSC_KEY1],0             ; Lockout Flash and Supervisiory operations
        006B: 55 F8 00 MOV   [248],0
(0190)     mov  [bSSC_KEYSP],0      
        006E: 55 F9 00 MOV   [249],0
(0191) 
(0192)     mov  A,_stack_start           ; Set top of stack to end of used RAM
        0071: 50 37    MOV   A,55
(0193)     swap SP,A
        0073: 4E       SWAP  SP,A
(0194) 
(0195)     ;-------------------------------------------------------------------------
(0196)     ; If the user has requested the Crystal oscillator then turn it on and
(0197)     ; wait for it to stabilize and the system to switch over to it.  The wait
(0198)     ; will be one sleep timer period, approximately 1 second.
(0199)     ;-------------------------------------------------------------------------
(0200) 
(0201) IF (SELECT_32K & WAIT_FOR_32K)
(0202)     ; Start the ECO and and leave the PLL off
(0203)     ; Set SleepTimer to 1 sec to time the wait for the ECO to stabilize
(0204)     M8C_SetBank1
(0205)     mov  reg[OSC_CR0],(SELECT_32K_JUST | OSC_CR0_SLEEP_1Hz | OSC_CR0_CPU_12MHz) 
(0206)     M8C_SetBank0
(0207)     M8C_ClearWDTAndSleep            ; Reset the sleep timer to get a full second
(0208) 
(0209)     ; The sleep interrupt will be used for timing Xtal and PLL startup.
(0210)     or   reg[INT_MSK0],INT_MSK0_SLEEP
(0211) 
(0212)     ; Wait for a SleepTimer interrupt to tell that 1 sec has passed
(0213)     mov  reg[INT_VC],0              ; Clear all pending interrupts
(0214) .WaitFor1s:
(0215)     tst  reg[INT_CLR0],INT_MSK0_SLEEP   ; test the Interrupt Status
(0216)     jz  .WaitFor1s                  ; TimeOut occurs on Sleep Timer 1s
(0217) 
(0218) ELSE ;!(SELECT_32K & WAIT_FOR_32K)
(0219)     ; Either no ECO, or waiting for stable clock is to be done in main
(0220)     M8C_SetBank1
        0074: 71 10    OR    F,16
(0221)     mov  reg[OSC_CR0],(SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | OSC_CR0_CPU_12MHz)
        0076: 62 E0 02 MOV   REG[224],2
(0222)     M8C_SetBank0
        0079: 70 EF    AND   F,239
(0223)     M8C_ClearWDTAndSleep            ; Reset the watch dog
        007B: 62 E3 38 MOV   REG[227],56
(0224) 
(0225) ENDIF ;(SELECT_32K & WAIT_FOR_32K)
(0226) 
(0227)     ;-------------------------------------------------------------------------
(0228)     ; Crystal is now fully operational (assuming WAIT_FOR_32K was left 
(0229)     ; enabled). Now start up PLL lock mode if selected.
(0230)     ;-------------------------------------------------------------------------
(0231) IF (PLL_MODE)
(0232)     M8C_SetBank1
(0233)     mov  reg[OSC_CR0],(SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_3MHz)
(0234)     M8C_SetBank0
(0235)     M8C_ClearWDTAndSleep            ; Reset the sleep timer
(0236) 
(0237)     mov  reg[INT_VC],0              ; Clear all pending interrupts
(0238) .WaitFor16ms:
(0239)     tst  reg[INT_CLR0],INT_MSK0_SLEEP   ; test the Interrupt Status
(0240)     jz  .WaitFor16ms                ; TimeOut occurs on Sleep Timer 16ms
(0241) IF  (WAIT_FOR_32K)
(0242) ELSE ;!(WAIT_FOR_32K)
(0243)     ERROR_PSoC Disabling WAIT_FOR_32K requires that the PLL_Lock must be enabled in user code.
(0244) ENDIF ;(WAIT_FOR_32K)
(0245) ENDIF ;(PLL_MODE)
(0246) 
(0247)     ;-------------------------------------------------------------------------
(0248)     ; Set CT block RTopMux to OUT and RBotMux to AGND.  This closes leakage 
(0249)     ; paths through the CT blocks.
(0250)     ;-------------------------------------------------------------------------
(0251)     mov  reg[ACB00CR0],05h
        007E: 62 71 05 MOV   REG[113],5
(0252)     mov  reg[ACB01CR0],05h
        0081: 62 75 05 MOV   REG[117],5
(0253)     mov  reg[ACB02CR0],05h
        0084: 62 79 05 MOV   REG[121],5
(0254)     mov  reg[ACB03CR0],05h
        0087: 62 7D 05 MOV   REG[125],5
(0255) 
(0256)     ;-------------------------------------------------------------------------
(0257)     ; All the user selections and UserModule selections are now loaded,
(0258)     ; except CPU frequency (CPU is runing at 12 MHz).  Load the PSoC 
(0259)     ; configuration with a 12 MHz CPU clock to keep config time short.
(0260)     ;-------------------------------------------------------------------------
(0261)     lcall LoadConfigInit           ; Configure PSoC blocks per Dev Editor
        008A: 7C 08 DB LCALL 0x08DB
(0262) 
(0263) 
(0264) IF (C_LANGUAGE_SUPPORT)
(0265)     call InitCRunTime              ; Initialize for C language
        008D: 90 1C    CALL  0x00AB
(0266) ENDIF ;(C_LANGUAGE_SUPPORT)
(0267) 
(0268)     
(0269) IF (SUPPLY_VOLTAGE)
(0270)     ;-------------------------------------------------------------------------
(0271)     ; Nominal 5.0 V operating voltage is selected.
(0272)     ; Set the Precision Power-On Reset (PPOR) level for the operating voltage
(0273)     ; range selected. In addition, if the SMP is running make sure time was 
(0274)     ; given to let Vdd slew up to the set voltage before enabling the reset.
(0275)     ;-------------------------------------------------------------------------
(0276) 
(0277) IF (SWITCH_MODE_PUMP ^ 1)
(0278)     ;-------------------------------------------------------------------------
(0279)     ; If using the SMP at 5V, must wait for Vdd to slew from 3.1V to 5V
(0280)     ; The sleep interrupt will be used for timing Xtal and PLL startup.
(0281)     ;-------------------------------------------------------------------------
(0282)     or   reg[INT_MSK0],INT_MSK0_SLEEP   
(0283) 
(0284)     M8C_SetBank1
(0285)     and  reg[OSC_CR0],~OSC_CR0_SLEEP
(0286)     or   reg[OSC_CR0],OSC_CR0_SLEEP_512Hz
(0287)     M8C_SetBank0
(0288) 
(0289)     M8C_ClearWDTAndSleep         ; Reset the sleep timer
(0290) 
(0291)     mov  reg[INT_VC],0           ; Clear all pending interrupts
(0292) .WaitFor2ms:
(0293)     tst  reg[INT_CLR0],INT_MSK0_SLEEP   ; test the Interrupt Status
(0294)     jz  .WaitFor2ms              ; TimeOut occurs on Sleep Timer 2ms
(0295) ENDIF ;(SWITCH_MODE_PUMP ^ 1)
(0296) 
(0297) IF (CPU_CLOCK_JUST ^ OSC_CR0_CPU_24MHz) ; Clock is not 24MHz
(0298)     ;-------------------------------------------------------------------------
(0299)     ; <24 MHz operation is requested, so set PPOR to 3.0V.  If a PPOR level
(0300)     ;  of 4.5V is desired, then VLT_CR can be set in user code.
(0301)     ;-------------------------------------------------------------------------
(0302)     M8C_SetBank1
(0303)     and  reg[VLT_CR],~VLT_CR_PORLEV
(0304)     or   reg[VLT_CR],VLT_CR_3V0_POR
(0305)     M8C_SetBank0
(0306) 
(0307) ELSE ;!(CPU_CLOCK_JUST ^ OSC_CR0_CPU_24MHz)
(0308)     ;-------------------------------------------------------------------------
(0309)     ; 24 MHz operation, so Vdd >= 4.75V required.
(0310)     ;-------------------------------------------------------------------------
(0311)     M8C_SetBank1
        008F: 71 10    OR    F,16
(0312)     and  reg[VLT_CR],~VLT_CR_PORLEV
        0091: 41 E3 CF AND   REG[227],207
(0313)     or   reg[VLT_CR],VLT_CR_4V75_POR
        0094: 43 E3 20 OR    REG[227],32
(0314)     M8C_SetBank0
        0097: 70 EF    AND   F,239
(0315) ENDIF ;(CPU_CLOCK_JUST ^ OSC_CR0_CPU_24MHz)
(0316) 
(0317) ELSE ;!(SUPPLY_VOLTAGE)
(0318)     ;-------------------------------------------------------------------------
(0319)     ; Nominal 3.3 V operating voltage is selected, set the PPOR to 3.0V.
(0320)     ;-------------------------------------------------------------------------
(0321)     M8C_SetBank1
(0322)     and  reg[VLT_CR],~VLT_CR_PORLEV
(0323) //  or   reg[VLT_CR],VLT_CR_3V0_POR   ; not needed, 0b00 is 3.0V
(0324)     M8C_SetBank0
(0325) 
(0326) ENDIF ;(SUPPLY_VOLTAGE)
(0327) 
(0328)     ;-------------------------------------------------------------------------
(0329)     ; Disable the Sleep interrupt that was used for timing above.  In fact,
(0330)     ; no interrupts should be enabled now, so may as well clear the register.
(0331)     ;-------------------------------------------------------------------------
(0332)     mov  reg[INT_MSK0],0
        0099: 62 E0 00 MOV   REG[224],0
(0333) 
(0334)     ;-------------------------------------------------------------------------
(0335)     ; Everything has started OK. Now select requested CPU & sleep frequency.
(0336)     ;-------------------------------------------------------------------------
(0337)     M8C_SetBank1
        009C: 71 10    OR    F,16
(0338)     mov  reg[OSC_CR0],(SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | CPU_CLOCK_JUST)
        009E: 62 E0 03 MOV   REG[224],3
(0339)     M8C_SetBank0
        00A1: 70 EF    AND   F,239
(0340) 
(0341)     ;-------------------------------------------------------------------------
(0342)     ; Global Interrupt are NOT enabled, this should be done in main().
(0343)     ; LVD is set but will not occur unless Global Interrupts are enabled. 
(0344)     ; Global Interrupts should be as soon as possible in main().
(0345)     ;-------------------------------------------------------------------------
(0346)     mov  reg[INT_VC],0              ; Clear any pending interrupts which may
        00A3: 62 E2 00 MOV   REG[226],0
(0347)                                     ; have been set during the boot process. 
(0348)     lcall _main                     ; Call main
        00A6: 7C 0C 8F LCALL _main
(0349) 
(0350) __Exit:
(0351)     jmp  __Exit                     ; Wait here till power is turned off
        00A9: 8F FF    JMP   0x00A9
(0352) 
(0353) 
(0354) 
(0355) ;-----------------------------------------------------------------------------
(0356) ; C Runtime Environment Initialization
(0357) ; The following code is conditionally assembled.
(0358) ;-----------------------------------------------------------------------------
(0359) 
(0360) IF (C_LANGUAGE_SUPPORT)
(0361) 
(0362) InitCRunTime:
(0363)     ;-----------------------------
(0364)     ; clear bss segment
(0365)     ;-----------------------------
(0366)     mov  A,0
        00AB: 50 00    MOV   A,0
(0367)     mov  [__r0],<__bss_start
        00AD: 55 0E 0F MOV   [__r0],15
(0368) BssLoop:
(0369)     cmp  [__r0],<__bss_end
        00B0: 3C 0E 37 CMP   [__r0],55
(0370)     jz   BssDone
        00B3: A0 05    JZ    0x00B9
(0371)     mvi  [__r0],A
        00B5: 3F 0E    MVI   [__r0],A
(0372)     jmp  BssLoop
        00B7: 8F F8    JMP   0x00B0
(0373) BssDone:
(0374)     ;----------------------------
(0375)     ; copy idata to data segment
(0376)     ;----------------------------
(0377)     mov  A,>__idata_start
        00B9: 50 08    MOV   A,8
(0378)     mov  X,<__idata_start
        00BB: 57 D9    MOV   X,217
(0379)     mov  [__r0],<__data_start
        00BD: 55 0E 00 MOV   [__r0],0
(0380) IDataLoop:
(0381)     cmp  [__r0],<__data_end
        00C0: 3C 0E 00 CMP   [__r0],0
(0382)     jz   IDataDone
        00C3: A0 0B    JZ    0x00CF
(0383)     push A
        00C5: 08       PUSH  A
(0384)     romx
        00C6: 28       ROMX  
(0385)     mvi  [__r0],A
        00C7: 3F 0E    MVI   [__r0],A
(0386)     pop  A
        00C9: 18       POP   A
(0387)     inc  X
        00CA: 75       INC   X
(0388)     adc  A,0
        00CB: 09 00    ADC   A,0
(0389)     jmp  IDataLoop
        00CD: 8F F2    JMP   0x00C0
(0390) IDataDone:
(0391)     ret
        00CF: 7F       RET   
        00D0: 30       HALT  
        00D1: 30       HALT  
        00D2: 30       HALT  
        00D3: 30       HALT  
        00D4: 30       HALT  
        00D5: 30       HALT  
        00D6: 30       HALT  
        00D7: 30       HALT  
        00D8: 30       HALT  
        00D9: 30       HALT  
        00DA: 30       HALT  
        00DB: 30       HALT  
        00DC: 30       HALT  
        00DD: 30       HALT  
        00DE: 30       HALT  
        00DF: 30       HALT  
        00E0: 30       HALT  
        00E1: 30       HALT  
        00E2: 30       HALT  
        00E3: 30       HALT  
        00E4: 30       HALT  
        00E5: 30       HALT  
        00E6: 30       HALT  
        00E7: 30       HALT  
        00E8: 30       HALT  
        00E9: 30       HALT  
        00EA: 30       HALT  
        00EB: 30       HALT  
        00EC: 30       HALT  
        00ED: 30       HALT  
        00EE: 30       HALT  
        00EF: 30       HALT  
        00F0: 30       HALT  
        00F1: 30       HALT  
        00F2: 30       HALT  
        00F3: 30       HALT  
        00F4: 30       HALT  
        00F5: 30       HALT  
        00F6: 30       HALT  
        00F7: 30       HALT  
        00F8: 30       HALT  
        00F9: 30       HALT  
        00FA: 30       HALT  
        00FB: 30       HALT  
        00FC: 30       HALT  
        00FD: 30       HALT  
        00FE: 30       HALT  
        00FF: 30       HALT  
        0100: 00       SSC   
        0101: 00       SSC   
        0102: 00       SSC   
        0103: 00       SSC   
        0104: 00       SSC   
        0105: 00       SSC   
        0106: 00       SSC   
        0107: 00       SSC   
        0108: 00       SSC   
        0109: 00       SSC   
        010A: 00       SSC   
        010B: 00       SSC   
        010C: 00       SSC   
        010D: 00       SSC   
        010E: 00       SSC   
        010F: 00       SSC   
        0110: 00       SSC   
        0111: 00       SSC   
        0112: 00       SSC   
        0113: 00       SSC   
        0114: 00       SSC   
        0115: 00       SSC   
        0116: C0 F0    JC    0x0207
        0118: F0 C0    INDEX 0x01DA
        011A: 00       SSC   
        011B: 00       SSC   
        011C: 00       SSC   
        011D: 00       SSC   
        011E: 00       SSC   
        011F: 00       SSC   
        0120: 00       SSC   
        0121: 00       SSC   
        0122: 00       SSC   
        0123: 00       SSC   
        0124: 00       SSC   
        0125: 00       SSC   
        0126: 00       SSC   
        0127: 00       SSC   
        0128: 00       SSC   
        0129: 00       SSC   
        012A: 00       SSC   
        012B: 00       SSC   
        012C: 00       SSC   
        012D: 00       SSC   
        012E: 00       SSC   
        012F: 00       SSC   
        0130: 00       SSC   
        0131: 00       SSC   
        0132: 00       SSC   
        0133: 00       SSC   
        0134: 00       SSC   
        0135: 00       SSC   
        0136: 00       SSC   
        0137: 00       SSC   
        0138: 00       SSC   
        0139: 00       SSC   
        013A: 00       SSC   
        013B: 00       SSC   
        013C: 00       SSC   
        013D: 00       SSC   
        013E: 00       SSC   
        013F: 00       SSC   
        0140: 00       SSC   
        0141: 00       SSC   
        0142: 00       SSC   
        0143: 00       SSC   
        0144: 00       SSC   
        0145: 00       SSC   
        0146: 00       SSC   
        0147: 00       SSC   
        0148: 00       SSC   
        0149: 00       SSC   
        014A: 00       SSC   
        014B: 00       SSC   
        014C: 00       SSC   
        014D: 00       SSC   
        014E: 00       SSC   
        014F: 00       SSC   
        0150: 00       SSC   
        0151: 00       SSC   
        0152: 00       SSC   
        0153: 00       SSC   
        0154: 00       SSC   
        0155: 00       SSC   
        0156: 00       SSC   
        0157: 00       SSC   
        0158: 00       SSC   
        0159: 00       SSC   
        015A: 00       SSC   
        015B: 00       SSC   
        015C: 00       SSC   
        015D: 00       SSC   
        015E: 00       SSC   
        015F: 00       SSC   
        0160: 00       SSC   
        0161: 00       SSC   
        0162: 00       SSC   
        0163: 00       SSC   
        0164: 00       SSC   
        0165: 00       SSC   
        0166: 00       SSC   
        0167: 00       SSC   
        0168: 00       SSC   
        0169: 00       SSC   
        016A: 00       SSC   
        016B: 00       SSC   
        016C: 00       SSC   
        016D: 00       SSC   
        016E: 00       SSC   
        016F: 00       SSC   
        0170: 00       SSC   
        0171: 00       SSC   
        0172: 00       SSC   
        0173: 00       SSC   
        0174: 00       SSC   
        0175: 00       SSC   
        0176: 00       SSC   
        0177: 00       SSC   
        0178: 00       SSC   
        0179: 00       SSC   
        017A: 00       SSC   
        017B: 00       SSC   
        017C: 00       SSC   
        017D: 00       SSC   
        017E: 00       SSC   
        017F: 00       SSC   
        0180: 00       SSC   
        0181: 00       SSC   
        0182: 00       SSC   
        0183: 00       SSC   
        0184: 00       SSC   
        0185: 00       SSC   
        0186: 00       SSC   
        0187: 00       SSC   
        0188: 00       SSC   
        0189: 00       SSC   
        018A: 00       SSC   
        018B: 00       SSC   
        018C: 80 80    JMP   0x020D
        018E: 80 80    JMP   0x020F
        0190: 80 80    JMP   0x0211
        0192: 80 C0    JMP   0x0253
        0194: F0 FE    INDEX 0x0294
        0196: FF FF    INDEX 0x0197
        0198: FF FF    INDEX 0x0199
        019A: FF F8    INDEX 0x0194
        019C: C0 00    JC    0x019D
        019E: 00       SSC   
        019F: 00       SSC   
        01A0: 00       SSC   
        01A1: 00       SSC   
        01A2: 00       SSC   
        01A3: 00       SSC   
        01A4: 00       SSC   
        01A5: 00       SSC   
        01A6: 00       SSC   
        01A7: 00       SSC   
        01A8: 00       SSC   
        01A9: 00       SSC   
        01AA: 00       SSC   
        01AB: 00       SSC   
        01AC: 00       SSC   
        01AD: 00       SSC   
        01AE: 00       SSC   
        01AF: 00       SSC   
        01B0: 00       SSC   
        01B1: 00       SSC   
        01B2: 00       SSC   
        01B3: 00       SSC   
        01B4: 00       SSC   
        01B5: 00       SSC   
        01B6: 00       SSC   
        01B7: 00       SSC   
        01B8: 00       SSC   
        01B9: 00       SSC   
        01BA: 00       SSC   
        01BB: 00       SSC   
        01BC: 00       SSC   
        01BD: 00       SSC   
        01BE: 00       SSC   
        01BF: 00       SSC   
        01C0: 00       SSC   
        01C1: 00       SSC   
        01C2: 00       SSC   
        01C3: 00       SSC   
        01C4: 00       SSC   
        01C5: 00       SSC   
        01C6: 00       SSC   
        01C7: 00       SSC   
        01C8: 00       SSC   
        01C9: 00       SSC   
        01CA: 00       SSC   
        01CB: 00       SSC   
        01CC: 00       SSC   
        01CD: 00       SSC   
        01CE: 00       SSC   
        01CF: 00       SSC   
        01D0: 00       SSC   
        01D1: 00       SSC   
        01D2: 00       SSC   
        01D3: 00       SSC   
        01D4: 00       SSC   
        01D5: 00       SSC   
        01D6: 00       SSC   
        01D7: 00       SSC   
        01D8: 00       SSC   
        01D9: 00       SSC   
        01DA: 00       SSC   
        01DB: 00       SSC   
        01DC: 00       SSC   
        01DD: 00       SSC   
        01DE: 00       SSC   
        01DF: 00       SSC   
        01E0: 00       SSC   
        01E1: 00       SSC   
        01E2: 00       SSC   
        01E3: 00       SSC   
        01E4: 00       SSC   
        01E5: 00       SSC   
        01E6: 00       SSC   
        01E7: 00       SSC   
        01E8: 00       SSC   
        01E9: 00       SSC   
        01EA: 00       SSC   
        01EB: 00       SSC   
        01EC: 00       SSC   
        01ED: 00       SSC   
        01EE: 00       SSC   
        01EF: 00       SSC   
        01F0: 00       SSC   
        01F1: 00       SSC   
        01F2: 00       SSC   
        01F3: 00       SSC   
        01F4: 00       SSC   
        01F5: 00       SSC   
        01F6: 00       SSC   
        01F7: 00       SSC   
        01F8: 00       SSC   
        01F9: 00       SSC   
        01FA: 00       SSC   
        01FB: 00       SSC   
        01FC: 00       SSC   
        01FD: 00       SSC   
        01FE: 00       SSC   
        01FF: 00       SSC   
        0200: 00       SSC   
        0201: 00       SSC   
        0202: 00       SSC   
        0203: C0 E0    JC    0x02E4
        0205: F0 78    INDEX 0x027F
        0207: 3C 1E 0F CMP   [_serial_rx_buf],15
        020A: 07 07 03 ADD   [X+7],3
        020D: 03 03    ADD   A,[X+3]
        020F: 03 C3    ADD   A,[X-61]
        0211: FB FF    INDEX 0xFE12
        0213: 7F       RET   
        0214: 0F 3F FF ADC   [X+63],255
        0217: FF FF    INDEX 0x0218
        0219: FF FF    INDEX 0x021A
        021B: FF FF    INDEX 0x021C
        021D: FF F8    INDEX 0x0217
        021F: C0 00    JC    0x0220
        0221: 00       SSC   
        0222: 00       SSC   
        0223: 00       SSC   
        0224: 00       SSC   
        0225: 00       SSC   
        0226: 00       SSC   
        0227: 00       SSC   
        0228: 00       SSC   
        0229: 00       SSC   
        022A: 00       SSC   
        022B: 00       SSC   
        022C: 00       SSC   
        022D: 00       SSC   
        022E: 00       SSC   
        022F: 00       SSC   
        0230: 00       SSC   
        0231: 00       SSC   
        0232: 00       SSC   
        0233: 00       SSC   
        0234: 00       SSC   
        0235: 00       SSC   
        0236: 00       SSC   
        0237: 00       SSC   
        0238: 00       SSC   
        0239: 00       SSC   
        023A: 00       SSC   
        023B: 00       SSC   
        023C: 00       SSC   
        023D: 00       SSC   
        023E: 00       SSC   
        023F: 00       SSC   
        0240: 00       SSC   
        0241: 00       SSC   
        0242: 00       SSC   
        0243: 00       SSC   
        0244: 00       SSC   
        0245: 00       SSC   
        0246: 00       SSC   
        0247: 00       SSC   
        0248: 00       SSC   
        0249: 00       SSC   
        024A: 00       SSC   
        024B: 00       SSC   
        024C: 00       SSC   
        024D: 00       SSC   
        024E: 00       SSC   
        024F: 00       SSC   
        0250: 00       SSC   
        0251: 00       SSC   
        0252: 00       SSC   
        0253: 00       SSC   
        0254: 00       SSC   
        0255: 00       SSC   
        0256: 00       SSC   
        0257: 00       SSC   
        0258: 00       SSC   
        0259: 00       SSC   
        025A: 00       SSC   
        025B: 00       SSC   
        025C: 00       SSC   
        025D: 00       SSC   
        025E: 00       SSC   
        025F: 00       SSC   
        0260: 00       SSC   
        0261: 00       SSC   
        0262: 00       SSC   
        0263: 00       SSC   
        0264: 00       SSC   
        0265: 00       SSC   
        0266: 00       SSC   
        0267: 00       SSC   
        0268: 00       SSC   
        0269: 00       SSC   
        026A: 00       SSC   
        026B: 00       SSC   
        026C: 00       SSC   
        026D: 00       SSC   
        026E: 00       SSC   
        026F: 00       SSC   
        0270: 00       SSC   
        0271: 00       SSC   
        0272: 00       SSC   
        0273: 00       SSC   
        0274: 00       SSC   
        0275: 00       SSC   
        0276: 00       SSC   
        0277: 00       SSC   
        0278: 00       SSC   
        0279: 00       SSC   
        027A: 00       SSC   
        027B: 00       SSC   
        027C: 00       SSC   
        027D: 00       SSC   
        027E: 00       SSC   
        027F: 00       SSC   
        0280: 00       SSC   
        0281: 00       SSC   
        0282: FF FF    INDEX 0x0283
        0284: FF 01    INDEX 0x0187
        0286: 00       SSC   
        0287: 00       SSC   
        0288: 00       SSC   
        0289: 00       SSC   
        028A: 00       SSC   
        028B: 00       SSC   
        028C: 00       SSC   
        028D: C0 F8    JC    0x0386
        028F: FE 7F    INDEX 0x0110
        0291: 0F 01 00 ADC   [X+1],0
        0294: 00       SSC   
        0295: 00       SSC   
        0296: 01 0F    ADD   A,15
        0298: 3F FF    MVI   [255],A
        029A: FF FF    INDEX 0x029B
        029C: FF FF    INDEX 0x029D
        029E: FF FF    INDEX 0x029F
        02A0: FF F8    INDEX 0x029A
        02A2: C0 00    JC    0x02A3
        02A4: 00       SSC   
        02A5: 00       SSC   
        02A6: 00       SSC   
        02A7: 00       SSC   
        02A8: 00       SSC   
        02A9: 00       SSC   
        02AA: 00       SSC   
        02AB: 00       SSC   
        02AC: 00       SSC   
        02AD: 80 80    JMP   0x032E
        02AF: 80 80    JMP   0x0330
        02B1: 00       SSC   
        02B2: 00       SSC   
        02B3: 00       SSC   
        02B4: 80 80    JMP   0x0335
        02B6: 80 00    JMP   0x02B7
        02B8: 00       SSC   
        02B9: 00       SSC   
        02BA: 00       SSC   
        02BB: 00       SSC   
        02BC: 80 80    JMP   0x033D
        02BE: 80 00    JMP   0x02BF
        02C0: 00       SSC   
        02C1: 00       SSC   
        02C2: 00       SSC   
        02C3: 00       SSC   
        02C4: 00       SSC   
        02C5: 00       SSC   
        02C6: 00       SSC   
        02C7: 80 80    JMP   0x0348
        02C9: 80 00    JMP   0x02CA
        02CB: 00       SSC   
        02CC: 00       SSC   
        02CD: 00       SSC   
        02CE: 00       SSC   
        02CF: 00       SSC   
        02D0: 00       SSC   
        02D1: 00       SSC   
        02D2: 00       SSC   
        02D3: 80 80    JMP   0x0354
        02D5: 80 80    JMP   0x0356
        02D7: 80 00    JMP   0x02D8
        02D9: 00       SSC   
        02DA: 00       SSC   
        02DB: 00       SSC   
        02DC: 00       SSC   
        02DD: 00       SSC   
        02DE: 1C 3E    SBB   [62],A
        02E0: 7F       RET   
        02E1: 7F       RET   
        02E2: 7F       RET   
        02E3: 7F       RET   
        02E4: 3E 1C    MVI   A,[_serial_tx_buf+2]
        02E6: 00       SSC   
        02E7: 00       SSC   
        02E8: 00       SSC   
        02E9: 00       SSC   
        02EA: 00       SSC   
        02EB: 00       SSC   
        02EC: 00       SSC   
        02ED: 00       SSC   
        02EE: 00       SSC   
        02EF: 00       SSC   
        02F0: 00       SSC   
        02F1: 00       SSC   
        02F2: 00       SSC   
        02F3: 00       SSC   
        02F4: 00       SSC   
        02F5: 00       SSC   
        02F6: 00       SSC   
        02F7: 00       SSC   
        02F8: 00       SSC   
        02F9: 00       SSC   
        02FA: 00       SSC   
        02FB: 00       SSC   
        02FC: 00       SSC   
        02FD: 00       SSC   
        02FE: 00       SSC   
        02FF: 00       SSC   
        0300: 00       SSC   
        0301: 00       SSC   
        0302: 07 1F 3F ADD   [X+31],63
        0305: FC F0    INDEX 0xFFF7
        0307: C0 80    JC    0x0388
        0309: 80 C0    JMP   0x03CA
        030B: F8 FE    INDEX 0xFC0B
        030D: 7F       RET   
        030E: 0F 0F 0E ADC   [X+15],14
        0311: 0E 0E 0E ADC   [__r0],14
        0314: 0E 0E 0E ADC   [__r0],14
        0317: 8E CE    JMP   0x01E6
        0319: EF FF    JACC  0x0319
        031B: 7F       RET   
        031C: FF FF    INDEX 0x031D
        031E: FF FF    INDEX 0x031F
        0320: FF FF    INDEX 0x0321
        0322: FF FF    INDEX 0x0323
        0324: F8 C0    INDEX 0xFBE6
        0326: 00       SSC   
        0327: 00       SSC   
        0328: 00       SSC   
        0329: 00       SSC   
        032A: 00       SSC   
        032B: 00       SSC   
        032C: 03 FF    ADD   A,[X-1]
        032E: FF FF    INDEX 0x032F
        0330: FF FF    INDEX 0x0331
        0332: 0E 07 07 ADC   [__r7],7
        0335: FF FF    INDEX 0x0336
        0337: FF FE    INDEX 0x0337
        0339: FC 06    INDEX 0xFF41
        033B: 07 0F FF ADD   [X+15],255
        033E: FF FF    INDEX 0x033F
        0340: FE 00    INDEX 0x0142
        0342: F0 FC    INDEX 0x0440
        0344: FE FF    INDEX 0x0245
        0346: FF 03    INDEX 0x024B
        0348: 03 03    ADD   A,[X+3]
        034A: FF FF    INDEX 0x034B
        034C: FE FC    INDEX 0x024A
        034E: E0 01    JACC  0x0350
        0350: 03 FF    ADD   A,[X-1]
        0352: FF FF    INDEX 0x0353
        0354: FF FF    INDEX 0x0355
        0356: 07 07 FF ADD   [X+7],255
        0359: FF FF    INDEX 0x035A
        035B: FE FC    INDEX 0x0259
        035D: 00       SSC   
        035E: 00       SSC   
        035F: 03 07    ADD   A,[X+7]
        0361: FF FF    INDEX 0x0362
        0363: FF FF    INDEX 0x0364
        0365: 00       SSC   
        0366: F0 FC    INDEX 0x0464
        0368: FE FF    INDEX 0x0269
        036A: 8F 03    JMP   0x026E
        036C: 0F 3F 3F ADC   [X+63],63
        036F: 3E 3C    MVI   A,[60]
        0371: 00       SSC   
        0372: 7C FF FF LCALL 0xFFFF
        0375: FB F3    INDEX 0xFF6A
        0377: E3 C7    JACC  0x073F
        0379: BF 3F    JNZ   0x02B9
        037B: 00       SSC   
        037C: 00       SSC   
        037D: 00       SSC   
        037E: 00       SSC   
        037F: 00       SSC   
        0380: 00       SSC   
        0381: 00       SSC   
        0382: 00       SSC   
        0383: 00       SSC   
        0384: C0 C0    JC    0x0445
        0386: E1 F1    JACC  0x0578
        0388: FB FF    INDEX 0xFF89
        038A: FF FF    INDEX 0x038B
        038C: FF EE    INDEX 0x037C
        038E: CE CE    JC    0x025D
        0390: CE 0E    JC    0x019F
        0392: 0E 0E 0E ADC   [__r0],14
        0395: 07 07 03 ADD   [X+7],3
        0398: 03 C1    ADD   A,[X-63]
        039A: C0 C0    JC    0x045B
        039C: C1 FF    JC    0x059C
        039E: FF FF    INDEX 0x039F
        03A0: FF FF    INDEX 0x03A1
        03A2: FF FF    INDEX 0x03A3
        03A4: FF FF    INDEX 0x03A5
        03A6: FF F8    INDEX 0x03A0
        03A8: E0 C0    JACC  0x0469
        03AA: C0 00    JC    0x03AB
        03AC: C0 FF    JC    0x04AC
        03AE: FF FF    INDEX 0x03AF
        03B0: FF FF    INDEX 0x03B1
        03B2: C0 80    JC    0x0433
        03B4: C0 FF    JC    0x04B4
        03B6: FF FF    INDEX 0x03B7
        03B8: FF FF    INDEX 0x03B9
        03BA: C0 80    JC    0x043B
        03BC: E0 FF    JACC  0x04BC
        03BE: FF FF    INDEX 0x03BF
        03C0: FF C0    INDEX 0x0382
        03C2: 8F 3F    JMP   0x0302
        03C4: 7F       RET   
        03C5: FF FF    INDEX 0x03C6
        03C7: C0 C0    JC    0x0488
        03C9: C0 FF    JC    0x04C9
        03CB: FF 7F    INDEX 0x034C
        03CD: 3F 0F    MVI   [_gpio_var],A
        03CF: 80 C0    JMP   0x0490
        03D1: FF FF    INDEX 0x03D2
        03D3: FF FF    INDEX 0x03D4
        03D5: FF 80    INDEX 0x0357
        03D7: C0 FF    JC    0x04D7
        03D9: FF FF    INDEX 0x03DA
        03DB: FF FF    INDEX 0x03DC
        03DD: C0 00    JC    0x03DE
        03DF: 80 C0    JMP   0x04A0
        03E1: FF FF    INDEX 0x03E2
        03E3: FF FF    INDEX 0x03E4
        03E5: C0 8F    JC    0x0475
        03E7: 3F 7F    MVI   [127],A
        03E9: FF FF    INDEX 0x03EA
        03EB: F8 E0    INDEX 0xFCCD
        03ED: E0 E0    JACC  0x04CE
        03EF: 70 38    AND   F,56
        03F1: 00       SSC   
        03F2: FC F9    INDEX 0x00ED
        03F4: E3 C3    JACC  0x07B8
        03F6: C7 DF    JC    0x0BD6
        03F8: FF FF    INDEX 0x03F9
        03FA: 3F 00    MVI   [NO_SHADOW],A
        03FC: 00       SSC   
        03FD: 00       SSC   
        03FE: 00       SSC   
        03FF: 00       SSC   
        0400: 00       SSC   
        0401: 00       SSC   
        0402: 00       SSC   
        0403: 30       HALT  
        0404: 48 48 98 TST   [X+72],152
        0407: 20       POP   X
        0408: E0 20    JACC  0x0429
        040A: 20       POP   X
        040B: C0 00    JC    0x040C
        040D: C0 A0    JC    0x04AE
        040F: C0 00    JC    0x0410
        0411: C0 20    JC    0x0432
        0413: 20       POP   X
        0414: 00       SSC   
        0415: 20       POP   X
        0416: E8 00    JACC  0xFC17
        0418: 00       SSC   
        0419: A0 A0    JZ    0x04BA
        041B: C0 00    JC    0x041C
        041D: F8 00    INDEX 0xFC1F
        041F: E8 00    JACC  0xFC20
        0421: C0 A0    JC    0x04C2
        0423: 20       POP   X
        0424: 00       SSC   
        0425: F0 20    INDEX 0x0447
        0427: 00       SSC   
        0428: 00       SSC   
        0429: 00       SSC   
        042A: 00       SSC   
        042B: 20       POP   X
        042C: E8 00    JACC  0xFC2D
        042E: E0 40    JACC  0x046F
        0430: 20       POP   X
        0431: E0 00    JACC  0x0432
        0433: 00       SSC   
        0434: 00       SSC   
        0435: F0 08    INDEX 0x043F
        0437: 08       PUSH  A
        0438: 08       PUSH  A
        0439: F0 20    INDEX 0x045B
        043B: E0 20    JACC  0x045C
        043D: 20       POP   X
        043E: C0 20    JC    0x045F
        0440: F0 20    INDEX 0x0462
        0442: 00       SSC   
        0443: E8 00    JACC  0xFC44
        0445: C0 20    JC    0x0466
        0447: 21 01    AND   A,1
        0449: A1 60    JZ    0x05AA
        044B: C0 00    JC    0x044C
        044D: 08       PUSH  A
        044E: F8 00    INDEX 0xFC50
        0450: 00       SSC   
        0451: 00       SSC   
        0452: 00       SSC   
        0453: 00       SSC   
        0454: 00       SSC   
        0455: E0 98    JACC  0x04EE
        0457: E0 00    JACC  0x0458
        0459: 00       SSC   
        045A: 00       SSC   
        045B: E0 20    JACC  0x047C
        045D: E0 20    JACC  0x047E
        045F: C0 20    JC    0x0480
        0461: E0 20    JACC  0x0482
        0463: 20       POP   X
        0464: C0 00    JC    0x0465
        0466: F8 00    INDEX 0xFC68
        0468: E8 00    JACC  0xFC69
        046A: 20       POP   X
        046B: F1 29    INDEX 0x0596
        046D: 08       PUSH  A
        046E: 20       POP   X
        046F: E8 00    JACC  0xFC70
        0471: C0 A1    JC    0x0513
        0473: C0 00    JC    0x0474
        0475: E1 21    JACC  0x0597
        0477: 21 C0    AND   A,192
        0479: A0 20    JZ    0x049A
        047B: 00       SSC   
        047C: 00       SSC   
        047D: 00       SSC   
        047E: 00       SSC   
        047F: 00       SSC   
        0480: 00       SSC   
        0481: 00       SSC   
        0482: 00       SSC   
        0483: 03 02    ADD   A,[X+2]
        0485: 02 01    ADD   A,[__rY]
        0487: 08       PUSH  A
        0488: 0F 0A 02 ADC   [X+10],2
        048B: 01 00    ADD   A,0
        048D: 01 02    ADD   A,2
        048F: 02 00    ADD   A,[NO_SHADOW]
        0491: 01 02    ADD   A,2
        0493: 02 00    ADD   A,[NO_SHADOW]
        0495: 02 03    ADD   A,[__r11]
        0497: 02 00    ADD   A,[NO_SHADOW]
        0499: 03 02    ADD   A,[X+2]
        049B: 03 00    ADD   A,[X+0]
        049D: 03 00    ADD   A,[X+0]
        049F: 03 00    ADD   A,[X+0]
        04A1: 02 02    ADD   A,[__rX]
        04A3: 01 00    ADD   A,0
        04A5: 03 02    ADD   A,[X+2]
        04A7: 02 00    ADD   A,[NO_SHADOW]
        04A9: 00       SSC   
        04AA: 00       SSC   
        04AB: 02 03    ADD   A,[__r11]
        04AD: 02 03    ADD   A,[__r11]
        04AF: 02 00    ADD   A,[NO_SHADOW]
        04B1: 03 02    ADD   A,[X+2]
        04B3: 00       SSC   
        04B4: 00       SSC   
        04B5: 01 02    ADD   A,2
        04B7: 02 02    ADD   A,[__rX]
        04B9: 01 08    ADD   A,8
        04BB: 0F 0A 02 ADC   [X+10],2
        04BE: 01 00    ADD   A,0
        04C0: 03 02    ADD   A,[X+2]
        04C2: 02 03    ADD   A,[__r11]
        04C4: 02 01    ADD   A,[__rY]
        04C6: 02 02    ADD   A,[__rX]
        04C8: 00       SSC   
        04C9: 03 02    ADD   A,[X+2]
        04CB: 03 00    ADD   A,[X+0]
        04CD: 02 03    ADD   A,[__r11]
        04CF: 02 00    ADD   A,[NO_SHADOW]
        04D1: 00       SSC   
        04D2: 00       SSC   
        04D3: 02 03    ADD   A,[__r11]
        04D5: 00       SSC   
        04D6: 00       SSC   
        04D7: 02 03    ADD   A,[__r11]
        04D9: 02 00    ADD   A,[NO_SHADOW]
        04DB: 03 00    ADD   A,[X+0]
        04DD: 03 00    ADD   A,[X+0]
        04DF: 03 08    ADD   A,[X+8]
        04E1: 0F 0A 02 ADC   [X+10],2
        04E4: 01 00    ADD   A,0
        04E6: 03 00    ADD   A,[X+0]
        04E8: 03 00    ADD   A,[X+0]
        04EA: 02 03    ADD   A,[__r11]
        04EC: 02 00    ADD   A,[NO_SHADOW]
        04EE: 02 03    ADD   A,[__r11]
        04F0: 02 01    ADD   A,[__rY]
        04F2: 02 02    ADD   A,[__rX]
        04F4: 00       SSC   
        04F5: 03 00    ADD   A,[X+0]
        04F7: 00       SSC   
        04F8: 02 02    ADD   A,[__rX]
        04FA: 01 00    ADD   A,0
        04FC: 00       SSC   
        04FD: 00       SSC   
        04FE: 00       SSC   
        04FF: 00       SSC   
        0500: 55 50 20 MOV   [80],32
        0503: 20       POP   X
        0504: 00       SSC   
        0505: 20       POP   X
        0506: 44 4F 57 OR    REG[X+79],87
        0509: 4E       SWAP  SP,A
        050A: 20       POP   X
        050B: 00       SSC   
        050C: 20       POP   X
        050D: 55 50 20 MOV   [80],32
        0510: 20       POP   X
        0511: 20       POP   X
        0512: 00       SSC   
        0513: 20       POP   X
        0514: 45 4E 54 XOR   REG[78],84
        0517: 45 52 00 XOR   REG[82],0
        051A: 44 4F 57 OR    REG[X+79],87
        051D: 4E       SWAP  SP,A
        051E: 00       SSC   
        051F: 30       HALT  
        0520: 35 00    XOR   [X+0],A
        0522: 6F 2F    RRC   [X+47]
        0524: 70 20    AND   F,32
        0526: 50 77    MOV   A,119
        0528: 72 3A    XOR   F,58
        052A: 00       SSC   
        052B: 6D       RRC   A
        052C: 57 00    MOV   X,0
        052E: 69 2F    ASR   [X+47]
        0530: 70 20    AND   F,32
        0532: 50 77    MOV   A,119
        0534: 72 3A    XOR   F,58
        0536: 00       SSC   
        0537: 00       SSC   
        0538: 00       SSC   
        0539: 00       SSC   
        053A: 00       SSC   
        053B: 00       SSC   
        053C: 40       NOP   
        053D: 00       SSC   
        053E: 00       SSC   
        053F: 00       SSC   
        0540: 60 30    MOV   REG[48],A
        0542: 18       POP   A
        0543: 0C 06    ADC   [__r8],A
        0545: 02 00    ADD   A,[NO_SHADOW]
        0547: 00       SSC   
        0548: 7C 42 42 LCALL 0x4242
        054B: 3E 00    MVI   A,[NO_SHADOW]
        054D: 00       SSC   
        054E: 00       SSC   
        054F: 00       SSC   
        0550: 00       SSC   
        0551: 04 7E    ADD   [126],A
        0553: 00       SSC   
        0554: 00       SSC   
        0555: 00       SSC   
        0556: 00       SSC   
        0557: 00       SSC   
        0558: 00       SSC   
        0559: 44 62 52 OR    REG[X+98],82
        055C: 4C 00    SWAP  A,[NO_SHADOW]
        055E: 00       SSC   
        055F: 00       SSC   
        0560: 00       SSC   
        0561: 24 42    AND   [66],A
        0563: 4A 34 00 TST   REG[X+52],0
        0566: 00       SSC   
        0567: 00       SSC   
        0568: 30       HALT  
        0569: 28       ROMX  
        056A: 24 7E    AND   [126],A
        056C: 20       POP   X
        056D: 00       SSC   
        056E: 00       SSC   
        056F: 00       SSC   
        0570: 4E       SWAP  SP,A
        0571: 4A 4A 32 TST   REG[X+74],50
        0574: 00       SSC   
        0575: 00       SSC   
        0576: 00       SSC   
        0577: 00       SSC   
        0578: 3C 4A 4A CMP   [74],74
        057B: 32 00    XOR   A,[NO_SHADOW]
        057D: 00       SSC   
        057E: 00       SSC   
        057F: 00       SSC   
        0580: 02 62    ADD   A,[98]
        0582: 1A 06    SBB   A,[__r8]
        0584: 00       SSC   
        0585: 00       SSC   
        0586: 00       SSC   
        0587: 00       SSC   
        0588: 34 4A    XOR   [74],A
        058A: 4A 34 00 TST   REG[X+52],0
        058D: 00       SSC   
        058E: 00       SSC   
        058F: 00       SSC   
        0590: 1E 12 12 SBB   [_current_ptr],18
        0593: 7E       RETI  
        0594: 00       SSC   
        0595: 00       SSC   
        0596: 00       SSC   
        0597: 00       SSC   
        0598: 00       SSC   
        0599: 00       SSC   
        059A: 00       SSC   
        059B: 24 00    AND   [NO_SHADOW],A
        059D: 00       SSC   
        059E: 00       SSC   
        059F: 00       SSC   
        05A0: 00       SSC   
        05A1: 00       SSC   
        05A2: 40       NOP   
        05A3: 34 00    XOR   [NO_SHADOW],A
        05A5: 00       SSC   
        05A6: 00       SSC   
        05A7: 00       SSC   
        05A8: 10       PUSH  X
        05A9: 28       ROMX  
        05AA: 28       ROMX  
        05AB: 28       ROMX  
        05AC: 44 00 00 OR    REG[X+0],0
        05AF: 00       SSC   
        05B0: 28       ROMX  
        05B1: 28       ROMX  
        05B2: 28       ROMX  
        05B3: 28       ROMX  
        05B4: 28       ROMX  
        05B5: 00       SSC   
        05B6: 00       SSC   
        05B7: 00       SSC   
        05B8: 44 28 28 OR    REG[X+40],40
        05BB: 28       ROMX  
        05BC: 10       PUSH  X
        05BD: 00       SSC   
        05BE: 00       SSC   
        05BF: 00       SSC   
        05C0: 04 02    ADD   [__rX],A
        05C2: B2 12    JNZ   0x07D5
        05C4: 0C 00    ADC   [NO_SHADOW],A
        05C6: 00       SSC   
        05C7: 00       SSC   
        05C8: 7C C6 FA LCALL 0xC6FA
        05CB: 8E E6    JMP   0x04B2
        05CD: 3C 00 00 CMP   [NO_SHADOW],0
        05D0: 60 1C    MOV   REG[28],A
        05D2: 12 1C    SUB   A,[_serial_tx_buf+2]
        05D4: 60 00    MOV   REG[0],A
        05D6: 00       SSC   
        05D7: 00       SSC   
        05D8: 7E       RETI  
        05D9: 4A 4A 3C TST   REG[X+74],60
        05DC: 00       SSC   
        05DD: 00       SSC   
        05DE: 00       SSC   
        05DF: 00       SSC   
        05E0: 7C 82 82 LCALL 0x8282
        05E3: 82 44    JMP   0x0828
        05E5: 00       SSC   
        05E6: 00       SSC   
        05E7: 00       SSC   
        05E8: 7E       RETI  
        05E9: 42 42 42 AND   REG[X+66],66
        05EC: 3C 00 00 CMP   [NO_SHADOW],0
        05EF: 00       SSC   
        05F0: 7E       RETI  
        05F1: 4A 4A 4A TST   REG[X+74],74
        05F4: 42 00 00 AND   REG[X+0],0
        05F7: 00       SSC   
        05F8: 7E       RETI  
        05F9: 12 12    SUB   A,[_current_ptr]
        05FB: 02 00    ADD   A,[NO_SHADOW]
        05FD: 00       SSC   
        05FE: 00       SSC   
        05FF: 00       SSC   
        0600: 3C 42 42 CMP   [66],66
        0603: 52 34    MOV   A,[X+52]
        0605: 00       SSC   
        0606: 00       SSC   
        0607: 00       SSC   
        0608: 7E       RETI  
        0609: 08       PUSH  A
        060A: 08       PUSH  A
        060B: 08       PUSH  A
        060C: 7E       RETI  
        060D: 00       SSC   
        060E: 00       SSC   
        060F: 00       SSC   
        0610: 00       SSC   
        0611: 00       SSC   
        0612: 7E       RETI  
        0613: 00       SSC   
        0614: 00       SSC   
        0615: 00       SSC   
        0616: 00       SSC   
        0617: 00       SSC   
        0618: 60 40    MOV   REG[64],A
        061A: 40       NOP   
        061B: 3E 00    MVI   A,[NO_SHADOW]
        061D: 00       SSC   
        061E: 00       SSC   
        061F: 00       SSC   
        0620: 7E       RETI  
        0621: 08       PUSH  A
        0622: 14 22    SUB   [34],A
        0624: 40       NOP   
        0625: 00       SSC   
        0626: 00       SSC   
        0627: 00       SSC   
        0628: 7E       RETI  
        0629: 40       NOP   
        062A: 40       NOP   
        062B: 40       NOP   
        062C: 00       SSC   
        062D: 00       SSC   
        062E: 00       SSC   
        062F: 00       SSC   
        0630: 7E       RETI  
        0631: 04 18    ADD   [_wr_compl_var],A
        0633: 10       PUSH  X
        0634: 04 7E    ADD   [126],A
        0636: 00       SSC   
        0637: 00       SSC   
        0638: 7E       RETI  
        0639: 04 08    ADD   [__r6],A
        063B: 30       HALT  
        063C: 7E       RETI  
        063D: 00       SSC   
        063E: 00       SSC   
        063F: 00       SSC   
        0640: 3C 42 42 CMP   [66],66
        0643: 42 3C 00 AND   REG[X+60],0
        0646: 00       SSC   
        0647: 00       SSC   
        0648: 7E       RETI  
        0649: 0A 0A    ADC   A,[__r4]
        064B: 0E 00 00 ADC   [NO_SHADOW],0
        064E: 00       SSC   
        064F: 00       SSC   
        0650: 3C 42 42 CMP   [66],66
        0653: 62 5C 00 MOV   REG[92],0
        0656: 00       SSC   
        0657: 00       SSC   
        0658: 7E       RETI  
        0659: 12 12    SUB   A,[_current_ptr]
        065B: 32 4C    XOR   A,[76]
        065D: 00       SSC   
        065E: 00       SSC   
        065F: 00       SSC   
        0660: 00       SSC   
        0661: 2C 4A    OR    [74],A
        0663: 52 34    MOV   A,[X+52]
        0665: 00       SSC   
        0666: 00       SSC   
        0667: 00       SSC   
        0668: 02 02    ADD   A,[__rX]
        066A: 7E       RETI  
        066B: 02 02    ADD   A,[__rX]
        066D: 00       SSC   
        066E: 00       SSC   
        066F: 00       SSC   
        0670: 3E 40    MVI   A,[64]
        0672: 40       NOP   
        0673: 40       NOP   
        0674: 3E 00    MVI   A,[NO_SHADOW]
        0676: 00       SSC   
        0677: 00       SSC   
        0678: 0E 30 40 ADC   [_timer_vector],64
        067B: 30       HALT  
        067C: 0E 00 00 ADC   [NO_SHADOW],0
        067F: 00       SSC   
        0680: 1E 60 1C SBB   [96],28
        0683: 38 60    ADD   SP,96
        0685: 1E 00 00 SBB   [NO_SHADOW],0
        0688: 42 34 08 AND   REG[X+52],8
        068B: 34 42    XOR   [66],A
        068D: 00       SSC   
        068E: 00       SSC   
        068F: 00       SSC   
        0690: 02 0C    ADD   A,[__r2]
        0692: 70 0C    AND   F,12
        0694: 02 00    ADD   A,[NO_SHADOW]
        0696: 00       SSC   
        0697: 00       SSC   
        0698: 62 52 4A MOV   REG[82],74
        069B: 4A 46 42 TST   REG[X+70],66
        069E: 00       SSC   
        069F: 00       SSC   
        06A0: 00       SSC   
        06A1: 00       SSC   
        06A2: 00       SSC   
        06A3: FF 81    INDEX 0x0626
        06A5: 00       SSC   
        06A6: 00       SSC   
        06A7: 00       SSC   
        06A8: 00       SSC   
        06A9: 00       SSC   
        06AA: 06 38 C0 ADD   [_jiffies+2],192
        06AD: 00       SSC   
        06AE: 00       SSC   
        06AF: 00       SSC   
        06B0: 00       SSC   
        06B1: 81 FF    JMP   0x08B1
        06B3: 00       SSC   
        06B4: 00       SSC   
        06B5: 00       SSC   
        06B6: 00       SSC   
        06B7: 00       SSC   
        06B8: 00       SSC   
        06B9: 00       SSC   
        06BA: 0C 02    ADC   [__rX],A
        06BC: 0C 00    ADC   [NO_SHADOW],A
        06BE: 00       SSC   
        06BF: 00       SSC   
        06C0: 00       SSC   
        06C1: 40       NOP   
        06C2: 40       NOP   
        06C3: 40       NOP   
        06C4: 40       NOP   
        06C5: 40       NOP   
        06C6: 00       SSC   
        06C7: 00       SSC   
        06C8: 00       SSC   
        06C9: 00       SSC   
        06CA: 00       SSC   
        06CB: 06 08 00 ADD   [__r6],0
        06CE: 00       SSC   
        06CF: 00       SSC   
        06D0: 00       SSC   
        06D1: 64       ASL   A
        06D2: 54 54    MOV   [X+84],A
        06D4: 7C 00 00 LCALL 0x0000
        06D7: 00       SSC   
        06D8: 00       SSC   
        06D9: 7F       RET   
        06DA: 44 44 38 OR    REG[X+68],56
        06DD: 00       SSC   
        06DE: 00       SSC   
        06DF: 00       SSC   
        06E0: 00       SSC   
        06E1: 38 44    ADD   SP,68
        06E3: 44 28 00 OR    REG[X+40],0
        06E6: 00       SSC   
        06E7: 00       SSC   
        06E8: 00       SSC   
        06E9: 38 44    ADD   SP,68
        06EB: 44 7F 00 OR    REG[X+127],0
        06EE: 00       SSC   
        06EF: 00       SSC   
        06F0: 00       SSC   
        06F1: 38 54    ADD   SP,84
        06F3: 54 58    MOV   [X+88],A
        06F5: 00       SSC   
        06F6: 00       SSC   
        06F7: 00       SSC   
        06F8: 00       SSC   
        06F9: 04 7E    ADD   [126],A
        06FB: 05 00    ADD   [X+0],A
        06FD: 00       SSC   
        06FE: 00       SSC   
        06FF: 00       SSC   
        0700: 00       SSC   
        0701: 2E 51 51 OR    [81],81
        0704: 3F 00    MVI   [NO_SHADOW],A
        0706: 00       SSC   
        0707: 00       SSC   
        0708: 00       SSC   
        0709: 7F       RET   
        070A: 04 04    ADD   [__r10],A
        070C: 78       DEC   A
        070D: 00       SSC   
        070E: 00       SSC   
        070F: 00       SSC   
        0710: 00       SSC   
        0711: 00       SSC   
        0712: 00       SSC   
        0713: 7D 00 00 LJMP  0x0000
        0716: 00       SSC   
        0717: 00       SSC   
        0718: 00       SSC   
        0719: 40       NOP   
        071A: 80 7D    JMP   0x0798
        071C: 00       SSC   
        071D: 00       SSC   
        071E: 00       SSC   
        071F: 00       SSC   
        0720: 00       SSC   
        0721: 7F       RET   
        0722: 10       PUSH  X
        0723: 38 44    ADD   SP,68
        0725: 00       SSC   
        0726: 00       SSC   
        0727: 00       SSC   
        0728: 00       SSC   
        0729: 00       SSC   
        072A: 00       SSC   
        072B: 7F       RET   
        072C: 00       SSC   
        072D: 00       SSC   
        072E: 00       SSC   
        072F: 00       SSC   
        0730: 7C 04 04 LCALL 0x0404
        0733: 7C 04 04 LCALL 0x0404
        0736: 78       DEC   A
        0737: 00       SSC   
        0738: 00       SSC   
        0739: 7C 04 04 LCALL 0x0404
        073C: 78       DEC   A
        073D: 00       SSC   
        073E: 00       SSC   
        073F: 00       SSC   
        0740: 00       SSC   
        0741: 38 44    ADD   SP,68
        0743: 44 38 00 OR    REG[X+56],0
        0746: 00       SSC   
        0747: 00       SSC   
        0748: 00       SSC   
        0749: FE 22    INDEX 0x056D
        074B: 22 1C    AND   A,[_serial_tx_buf+2]
        074D: 00       SSC   
        074E: 00       SSC   
        074F: 00       SSC   
        0750: 00       SSC   
        0751: 1C 22    SBB   [34],A
        0753: 22 FE    AND   A,[254]
        0755: 00       SSC   
        0756: 00       SSC   
        0757: 00       SSC   
        0758: 00       SSC   
        0759: 00       SSC   
        075A: 7C 04 04 LCALL 0x0404
        075D: 00       SSC   
        075E: 00       SSC   
        075F: 00       SSC   
        0760: 00       SSC   
        0761: 48 54 54 TST   [X+84],84
        0764: 24 00    AND   [NO_SHADOW],A
        0766: 00       SSC   
        0767: 00       SSC   
        0768: 00       SSC   
        0769: 00       SSC   
        076A: 04 7E    ADD   [126],A
        076C: 44 00 00 OR    REG[X+0],0
        076F: 00       SSC   
        0770: 00       SSC   
        0771: 3C 40 40 CMP   [64],64
        0774: 7C 00 00 LCALL 0x0000
        0777: 00       SSC   
        0778: 00       SSC   
        0779: 04 38    ADD   [_jiffies+2],A
        077B: 40       NOP   
        077C: 38 04    ADD   SP,4
        077E: 00       SSC   
        077F: 00       SSC   
        0780: 00       SSC   
        0781: 3C 40 3C CMP   [64],60
        0784: 40       NOP   
        0785: 3C 00 00 CMP   [NO_SHADOW],0
        0788: 00       SSC   
        0789: 44 38 38 OR    REG[X+56],56
        078C: 44 00 00 OR    REG[X+0],0
        078F: 00       SSC   
        0790: 00       SSC   
        0791: 02 9C    ADD   A,[156]
        0793: 60 1C    MOV   REG[28],A
        0795: 02 00    ADD   A,[NO_SHADOW]
        0797: 00       SSC   
        0798: 00       SSC   
        0799: 00       SSC   
        079A: 64       ASL   A
        079B: 54 4C    MOV   [X+76],A
        079D: 00       SSC   
        079E: 00       SSC   
        079F: 00       SSC   
        07A0: 00       SSC   
        07A1: 00       SSC   
        07A2: 00       SSC   
        07A3: 00       SSC   
        07A4: 00       SSC   
        07A5: 00       SSC   
        07A6: 00       SSC   
        07A7: 00       SSC   
        07A8: 0C 12    ADC   [_current_ptr],A
        07AA: 12 0C    SUB   A,[__r2]
        07AC: 00       SSC   
        07AD: 00       SSC   
        07AE: 00       SSC   
        07AF: 00       SSC   
        07B0: 00       SSC   
        07B1: 00       SSC   
        07B2: 5E 00    MOV   A,REG[X+0]
        07B4: 00       SSC   
        07B5: 00       SSC   
        07B6: 00       SSC   
        07B7: 00       SSC   
FILE: lib\psocconfigtbl.asm
(0001) ; Generated by PSoC Designer ver 4.1 b931 : 21 January, 2004
(0002) ;
(0003) include "m8c.inc"
(0004) ;  Personalization tables 
(0005) export LoadConfigTBL_mwlike8_Bank1
(0006) export LoadConfigTBL_mwlike8_Bank0
(0007) export LoadConfigTBL_mwlike8_Ordered
(0008) AREA lit(rom, rel)
(0009) LoadConfigTBL_mwlike8_Ordered:
(0010) ;  Ordered Global Register values
(0011) 	M8C_SetBank1
        07B8: 71 10    OR    F,16
(0012) 	mov	reg[00h], ffh		; Port_0_DriveMode_0 register (PRT0DM0)
        07BA: 62 00 FF MOV   REG[0],255
(0013) 	mov	reg[01h], 00h		; Port_0_DriveMode_1 register (PRT0DM1)
        07BD: 62 01 00 MOV   REG[1],0
(0014) 	M8C_SetBank0
        07C0: 70 EF    AND   F,239
(0015) 	mov	reg[03h], 00h		; Port_0_DriveMode_2 register (PRT0DM2)
        07C2: 62 03 00 MOV   REG[3],0
(0016) 	mov	reg[02h], 00h		; Port_0_GlobalSelect register (PRT0GS)
        07C5: 62 02 00 MOV   REG[2],0
(0017) 	M8C_SetBank1
        07C8: 71 10    OR    F,16
(0018) 	mov	reg[02h], 00h		; Port_0_IntCtrl_0 register (PRT0IC0)
        07CA: 62 02 00 MOV   REG[2],0
(0019) 	mov	reg[03h], 00h		; Port_0_IntCtrl_1 register (PRT0IC1)
        07CD: 62 03 00 MOV   REG[3],0
(0020) 	M8C_SetBank0
        07D0: 70 EF    AND   F,239
(0021) 	mov	reg[01h], 00h		; Port_0_IntEn register (PRT0IE)
        07D2: 62 01 00 MOV   REG[1],0
(0022) 	M8C_SetBank1
        07D5: 71 10    OR    F,16
(0023) 	mov	reg[04h], ffh		; Port_1_DriveMode_0 register (PRT1DM0)
        07D7: 62 04 FF MOV   REG[4],255
(0024) 	mov	reg[05h], 00h		; Port_1_DriveMode_1 register (PRT1DM1)
        07DA: 62 05 00 MOV   REG[5],0
(0025) 	M8C_SetBank0
        07DD: 70 EF    AND   F,239
(0026) 	mov	reg[07h], 00h		; Port_1_DriveMode_2 register (PRT1DM2)
        07DF: 62 07 00 MOV   REG[7],0
(0027) 	mov	reg[06h], 00h		; Port_1_GlobalSelect register (PRT1GS)
        07E2: 62 06 00 MOV   REG[6],0
(0028) 	M8C_SetBank1
        07E5: 71 10    OR    F,16
(0029) 	mov	reg[06h], 00h		; Port_1_IntCtrl_0 register (PRT1IC0)
        07E7: 62 06 00 MOV   REG[6],0
(0030) 	mov	reg[07h], 00h		; Port_1_IntCtrl_1 register (PRT1IC1)
        07EA: 62 07 00 MOV   REG[7],0
(0031) 	M8C_SetBank0
        07ED: 70 EF    AND   F,239
(0032) 	mov	reg[05h], 00h		; Port_1_IntEn register (PRT1IE)
        07EF: 62 05 00 MOV   REG[5],0
(0033) 	M8C_SetBank1
        07F2: 71 10    OR    F,16
(0034) 	mov	reg[08h], ffh		; Port_2_DriveMode_0 register (PRT2DM0)
        07F4: 62 08 FF MOV   REG[8],255
(0035) 	mov	reg[09h], 00h		; Port_2_DriveMode_1 register (PRT2DM1)
        07F7: 62 09 00 MOV   REG[9],0
(0036) 	M8C_SetBank0
        07FA: 70 EF    AND   F,239
(0037) 	mov	reg[0bh], 00h		; Port_2_DriveMode_2 register (PRT2DM2)
        07FC: 62 0B 00 MOV   REG[11],0
(0038) 	mov	reg[0ah], 00h		; Port_2_GlobalSelect register (PRT2GS)
        07FF: 62 0A 00 MOV   REG[10],0
(0039) 	M8C_SetBank1
        0802: 71 10    OR    F,16
(0040) 	mov	reg[0ah], 00h		; Port_2_IntCtrl_0 register (PRT2IC0)
        0804: 62 0A 00 MOV   REG[10],0
(0041) 	mov	reg[0bh], 00h		; Port_2_IntCtrl_1 register (PRT2IC1)
        0807: 62 0B 00 MOV   REG[11],0
(0042) 	M8C_SetBank0
        080A: 70 EF    AND   F,239
(0043) 	mov	reg[09h], 00h		; Port_2_IntEn register (PRT2IE)
        080C: 62 09 00 MOV   REG[9],0
(0044) 	M8C_SetBank1
        080F: 71 10    OR    F,16
(0045) 	mov	reg[0ch], dfh		; Port_3_DriveMode_0 register (PRT3DM0)
        0811: 62 0C DF MOV   REG[12],223
(0046) 	mov	reg[0dh], 2ah		; Port_3_DriveMode_1 register (PRT3DM1)
        0814: 62 0D 2A MOV   REG[13],42
(0047) 	M8C_SetBank0
        0817: 70 EF    AND   F,239
(0048) 	mov	reg[0fh], 00h		; Port_3_DriveMode_2 register (PRT3DM2)
        0819: 62 0F 00 MOV   REG[15],0
(0049) 	mov	reg[0eh], a0h		; Port_3_GlobalSelect register (PRT3GS)
        081C: 62 0E A0 MOV   REG[14],160
(0050) 	M8C_SetBank1
        081F: 71 10    OR    F,16
(0051) 	mov	reg[0eh], 0ah		; Port_3_IntCtrl_0 register (PRT3IC0)
        0821: 62 0E 0A MOV   REG[14],10
(0052) 	mov	reg[0fh], 0ah		; Port_3_IntCtrl_1 register (PRT3IC1)
        0824: 62 0F 0A MOV   REG[15],10
(0053) 	M8C_SetBank0
        0827: 70 EF    AND   F,239
(0054) 	mov	reg[0dh], 0ah		; Port_3_IntEn register (PRT3IE)
        0829: 62 0D 0A MOV   REG[13],10
(0055) 	M8C_SetBank1
        082C: 71 10    OR    F,16
(0056) 	mov	reg[10h], ffh		; Port_4_DriveMode_0 register (PRT4DM0)
        082E: 62 10 FF MOV   REG[16],255
(0057) 	mov	reg[11h], 0ah		; Port_4_DriveMode_1 register (PRT4DM1)
        0831: 62 11 0A MOV   REG[17],10
(0058) 	M8C_SetBank0
        0834: 70 EF    AND   F,239
(0059) 	mov	reg[13h], 00h		; Port_4_DriveMode_2 register (PRT4DM2)
        0836: 62 13 00 MOV   REG[19],0
(0060) 	mov	reg[12h], 00h		; Port_4_GlobalSelect register (PRT4GS)
        0839: 62 12 00 MOV   REG[18],0
(0061) 	M8C_SetBank1
        083C: 71 10    OR    F,16
(0062) 	mov	reg[12h], 00h		; Port_4_IntCtrl_0 register (PRT4IC0)
        083E: 62 12 00 MOV   REG[18],0
(0063) 	mov	reg[13h], 00h		; Port_4_IntCtrl_1 register (PRT4IC1)
        0841: 62 13 00 MOV   REG[19],0
(0064) 	M8C_SetBank0
        0844: 70 EF    AND   F,239
(0065) 	mov	reg[11h], 00h		; Port_4_IntEn register (PRT4IE)
        0846: 62 11 00 MOV   REG[17],0
(0066) 	M8C_SetBank1
        0849: 71 10    OR    F,16
(0067) 	mov	reg[14h], 0fh		; Port_5_DriveMode_0 register (PRT5DM0)
        084B: 62 14 0F MOV   REG[20],15
(0068) 	mov	reg[15h], 08h		; Port_5_DriveMode_1 register (PRT5DM1)
        084E: 62 15 08 MOV   REG[21],8
(0069) 	M8C_SetBank0
        0851: 70 EF    AND   F,239
(0070) 	mov	reg[17h], 00h		; Port_5_DriveMode_2 register (PRT5DM2)
        0853: 62 17 00 MOV   REG[23],0
(0071) 	mov	reg[16h], 00h		; Port_5_GlobalSelect register (PRT5GS)
        0856: 62 16 00 MOV   REG[22],0
(0072) 	M8C_SetBank1
        0859: 71 10    OR    F,16
(0073) 	mov	reg[16h], 08h		; Port_5_IntCtrl_0 register (PRT5IC0)
        085B: 62 16 08 MOV   REG[22],8
(0074) 	mov	reg[17h], 08h		; Port_5_IntCtrl_1 register (PRT5IC1)
        085E: 62 17 08 MOV   REG[23],8
(0075) 	M8C_SetBank0
        0861: 70 EF    AND   F,239
(0076) 	mov	reg[15h], 08h		; Port_5_IntEn register (PRT5IE)
        0863: 62 15 08 MOV   REG[21],8
(0077) 	ret
        0866: 7F       RET   
        0867: 60 28    MOV   REG[40],A
        0869: 66 00    ASL   [X+0]
        086B: 63 15 65 MOV   REG[X+21],101
        086E: 00       SSC   
        086F: E6 00    JACC  0x0E70
        0871: E7 00    JACC  0x0F72
        0873: D6 00    JNC   0x0E74
        0875: B0 0C    JNZ   0x0882
        0877: B1 00    JNZ   0x0978
        0879: B2 00    JNZ   0x0A7A
        087B: B3 33    JNZ   0x0BAF
        087D: B4 33    JNZ   0x0CB1
        087F: B5 00    JNZ   0x0D80
        0881: B6 00    JNZ   0x0E82
        0883: B8 55    JNZ   0x00D9
        0885: B9 00    JNZ   0x0186
        0887: BA 10    JNZ   0x0298
        0889: BB 33    JNZ   0x03BD
        088B: BC 33    JNZ   0x04BF
        088D: BD 00    JNZ   0x058E
        088F: BE 80    JNZ   0x0710
        0891: 3F 04    MVI   [__r10],A
        0893: 3D A0 3E CMP   [X-96],62
        0896: 00       SSC   
        0897: 2F 00 2D OR    [X+0],45
        089A: 00       SSC   
        089B: 2E 00 3B OR    [NO_SHADOW],59
        089E: 00       SSC   
        089F: 39 00    CMP   A,0
        08A1: 3A 00    CMP   A,[NO_SHADOW]
        08A3: FF 61    INDEX 0x0806
        08A5: 00       SSC   
        08A6: 69 00    ASR   [X+0]
        08A8: 60 00    MOV   REG[0],A
        08AA: 62 00 67 MOV   REG[0],103
        08AD: 33 68    XOR   A,[X+104]
        08AF: 33 63    XOR   A,[X+99]
        08B1: 00       SSC   
        08B2: 66 00    ASL   [X+0]
        08B4: D1 00    JNC   0x09B5
        08B6: D3 00    JNC   0x0BB7
        08B8: D0 00    JNC   0x08B9
        08BA: D2 00    JNC   0x0ABB
        08BC: E1 50    JACC  0x0A0D
        08BE: E2 00    JACC  0x0ABF
        08C0: DF 19    JNC   0x07DA
        08C2: DE 01    JNC   0x06C4
        08C4: E3 87    JACC  0x0C4C
        08C6: 3C 20 3D CMP   [_serial_rx_buf+2],61
        08C9: 07 3E 40 ADD   [X+62],64
        08CC: 2C 05    OR    [__r9],A
        08CE: 2D D1    OR    [X-47],A
        08D0: 2E 00 38 OR    [NO_SHADOW],56
        08D3: 0D 39    ADC   [X+57],A
        08D5: 01 3A    ADD   A,58
        08D7: 07 FF 0C ADD   [X-1],12
        08DA: B9 7C    JNZ   0x0257
FILE: lib\psocconfig.asm
(0001) ; Generated by PSoC Designer ver 4.1 b931 : 21 January, 2004
(0002) ;
(0003) ;
(0004) ;  PSoCConfig.asm
(0005) ;
(0006) ;  Version 0.84
(0007) ;  Data: 19 December, 2000
(0008) ;  Copyright Cypress MicroSystems 2000
(0009) ;
(0010) ;  This file is generated by the Device Editor on Application Generation.
(0011) ;  It contains code which loads the configuration data table generated in
(0012) ;  the file PSoCConfigTBL.asm
(0013) ;  
(0014) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
(0015) ;  Edits to this file will not be preserved.
(0016) ;
(0017) include "m8c.inc"
(0018) include "GlobalParams.inc"
(0019) 
(0020) export LoadConfigInit
(0021) export _LoadConfigInit
(0022) export LoadConfig_mwlike8
(0023) export _LoadConfig_mwlike8
(0024) 
(0025) export NO_SHADOW
(0026) export _NO_SHADOW
(0027) 
(0028) FLAG_CFG_MASK:		equ	10h			;M8C flag register REG address bit mask
(0029) END_CONFIG_TABLE:	equ	ffh			;end of config table indicator	
(0030) 
(0031) AREA psoc_config(rom, rel)
(0032) 
(0033) _LoadConfigInit:
(0034)  LoadConfigInit:
(0035) 	
(0036) 	lcall	LoadConfigTBL_mwlike8_Ordered
        08DC: 07 B8 7C ADD   [X-72],124
(0037) 	lcall	LoadConfig_mwlike8
        08DF: 08       PUSH  A
        08E0: E2 7F    JACC  0x0B60
(0038) 
(0039) 	ret
        08E2: 08       PUSH  A
(0040) 
(0041) ;
(0042) ; Load Configuration mwlike8
(0043) ;
(0044) _LoadConfig_mwlike8:
(0045)  LoadConfig_mwlike8:
(0046)     push    a
(0047)     push    x
        08E3: 10       PUSH  X
(0048) 	M8C_SetBank0									;switch to bank 0
        08E4: 70 EF    AND   F,239
(0049) 	mov		a, 0
        08E6: 50 00    MOV   A,0
(0050) 	asr		a
        08E8: 67       ASR   A
(0051) 	mov		A, >LoadConfigTBL_mwlike8_Bank0	;load bank 0 table
        08E9: 50 08    MOV   A,8
(0052) 	mov		X, <LoadConfigTBL_mwlike8_Bank0
        08EB: 57 67    MOV   X,103
(0053) 	lcall	LoadConfig								;load the bank 0 values
        08ED: 7C 09 01 LCALL 0x0901
(0054) 	M8C_SetBank1									;set for bank 1
        08F0: 71 10    OR    F,16
(0055) 	mov		a, 1
        08F2: 50 01    MOV   A,1
(0056) 	asr		a
        08F4: 67       ASR   A
(0057) 	mov		A, >LoadConfigTBL_mwlike8_Bank1	;load bank 1 table
        08F5: 50 08    MOV   A,8
(0058) 	mov		X, <LoadConfigTBL_mwlike8_Bank1
        08F7: 57 A4    MOV   X,164
(0059) 	lcall	LoadConfig								;load the bank 1 values
        08F9: 7C 09 01 LCALL 0x0901
(0060) 	M8C_SetBank0									;switch to bank 0
        08FC: 70 EF    AND   F,239
(0061)     pop     x
        08FE: 20       POP   X
(0062)     pop     a
        08FF: 18       POP   A
(0063) 	ret
        0900: 7F       RET   
(0064) 
(0065) 
(0066) ;
(0067) ; LoadConfig
(0068) ;
(0069) ;  This function is not exported.  It assumes that the address of the table
(0070) ;  to be loaded is contained in the X and A registers as if a romx instruction
(0071) ;  is the next instruction to be executed, i.e. lower address in X and uppper
(0072) ;  address in A.  There is no return value.
(0073) ;
(0074) LoadConfig:
(0075) 	add		SP, 2					;set up temp vars
        0901: 38 02    ADD   SP,2
(0076) 	push	X
        0903: 10       PUSH  X
(0077) 	push	A
        0904: 08       PUSH  A
(0078) 	mov		X, SP
        0905: 4F       MOV   X,SP
(0079) 	mov		[X-4], 0
        0906: 56 FC 00 MOV   [X-4],0
(0080) 	jnc		LoadBank0Setup
        0909: D0 04    JNC   0x090E
(0081) 	mov		[X-4], 1
        090B: 56 FC 01 MOV   [X-4],1
(0082) LoadBank0Setup:
(0083) 	pop		A
        090E: 18       POP   A
(0084) 	pop		X
        090F: 20       POP   X
(0085) LoadConfigLp:
(0086) 	push	X						;save config table address on stack
        0910: 10       PUSH  X
(0087) 	push	A
        0911: 08       PUSH  A
(0088) 	M8C_SetBank0					;switch to bank 0
        0912: 70 EF    AND   F,239
(0089) 	M8C_ClearWDT					;clear the watchdog for long inits
        0914: 62 E3 00 MOV   REG[227],0
(0090) 	mov		X, SP					;check for bank 1 load
        0917: 4F       MOV   X,SP
(0091) 	tst		[X-4], 1
        0918: 48 FC 01 TST   [X-4],1
(0092) 	jz		LoadingBank0
        091B: A0 03    JZ    0x091F
(0093) 	M8C_SetBank1
        091D: 71 10    OR    F,16
(0094) LoadingBank0:
(0095) 	pop		A
        091F: 18       POP   A
(0096) 	pop		X
        0920: 20       POP   X
(0097) 	push	X
        0921: 10       PUSH  X
(0098) 	push	A
        0922: 08       PUSH  A
(0099) 	romx							;load config address
        0923: 28       ROMX  
(0100) 	cmp		A, END_CONFIG_TABLE		;check for end of table
        0924: 39 FF    CMP   A,255
(0101) 	jz		EndLoadConfig			;if so, end of load
        0926: A0 1A    JZ    0x0941
(0102) 	mov		X, SP					;save the address away
        0928: 4F       MOV   X,SP
(0103) 	mov		[X-3], A
        0929: 54 FD    MOV   [X-3],A
(0104) 	pop		A						;retrieve the table address
        092B: 18       POP   A
(0105) 	pop		X
        092C: 20       POP   X
(0106) 	inc		X						;advance to the data byte
        092D: 75       INC   X
(0107) 	jnc		NoOverFlow1				;check for overflow
        092E: D0 02    JNC   0x0931
(0108) 	inc		A						;if so, increment MSB
        0930: 74       INC   A
(0109) NoOverFlow1:	
(0110) 	push	X						;save the config table address again
        0931: 10       PUSH  X
(0111) 	push	A
        0932: 08       PUSH  A
(0112) 	romx							;load the config data
        0933: 28       ROMX  
(0113) 	mov		X, SP					;retrieve the config address
        0934: 4F       MOV   X,SP
(0114) 	mov		X, [X-3]
        0935: 59 FD    MOV   X,[X-3]
(0115) 	mov		reg[X], A				;write the config data
        0937: 61 00    MOV   REG[X+0],A
(0116) 	pop		A						;retrieve the table address
        0939: 18       POP   A
(0117) 	pop		X
        093A: 20       POP   X
(0118) 	inc		X						;advance to the next address
        093B: 75       INC   X
(0119) 	jnc		NoOverFlow2				;check for overflow
        093C: D0 02    JNC   0x093F
(0120) 	inc		A						;if so, increment MSB
        093E: 74       INC   A
(0121) NoOverFlow2:	
(0122) 	jmp		LoadConfigLp			;loop back
        093F: 8F D0    JMP   0x0910
(0123) EndLoadConfig:
(0124) 	pop		A						;clean up the stack
        0941: 18       POP   A
(0125) 	pop		X
        0942: 20       POP   X
(0126) 	add		SP, -2
        0943: 38 FE    ADD   SP,254
(0127) 	ret
        0945: 7F       RET   
FILE: lib\uart_1.asm
(0001) ;;*****************************************************************************
(0002) ;;*****************************************************************************
(0003) ;;  FILENAME:   UART_1.asm
(0004) ;;  Version: 4.2, Updated on 2003/11/18 at 15:02:35
(0005) ;;  Generated by PSoC Designer ver 4.1 b931 : 21 January, 2004
(0006) ;;
(0007) ;;  DESCRIPTION:  UART User Module software implementation file for the
(0008) ;;                22/24/25/26/27xxx families.
(0009) ;;
(0010) ;;
(0011) ;;  NOTE: User Module APIs conform to the fastcall convention for marshalling
(0012) ;;        arguments and observe the associated "Registers are volatile" policy.
(0013) ;;        This means it is the caller's responsibility to preserve any values
(0014) ;;        in the X and A registers that are still needed after the API
(0015) ;;        function returns. Even though these registers may be preserved now,
(0016) ;;        there is no guarantee they will be preserved in future releases.
(0017) ;;-----------------------------------------------------------------------------
(0018) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
(0019) ;;*****************************************************************************
(0020) ;;*****************************************************************************
(0021) 
(0022) 
(0023) include "m8c.inc"
(0024) include "UART_1.inc"
(0025) 
(0026) area text (ROM, REL)
(0027) 
(0028) ;-----------------------------------------------
(0029) ;  Global Symbols
(0030) ;-----------------------------------------------
(0031) ;-------------------------------------------------------------------
(0032) ;  Declare the functions global for both assembler and C compiler.
(0033) ;
(0034) ;  Note that there are two names for each API. First name is
(0035) ;  assembler reference. Name with underscore is name refence for
(0036) ;  C compiler.  Calling function in C source code does not require
(0037) ;  the underscore.
(0038) ;-------------------------------------------------------------------
(0039) export  UART_1_EnableInt
(0040) export _UART_1_EnableInt
(0041) export  UART_1_DisableInt
(0042) export _UART_1_DisableInt
(0043) 
(0044) export  UART_1_Start
(0045) export _UART_1_Start
(0046) export  UART_1_Stop
(0047) export _UART_1_Stop
(0048) export  UART_1_SendData
(0049) export _UART_1_SendData
(0050) export  UART_1_bReadTxStatus
(0051) export _UART_1_bReadTxStatus
(0052) export  UART_1_bReadRxData
(0053) export _UART_1_bReadRxData
(0054) export  UART_1_bReadRxStatus
(0055) export _UART_1_bReadRxStatus
(0056) 
(0057) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(0058) ;       WARNING WARNING WARNING
(0059) ; The following exports are for backwards
(0060) ; compatibility only and should not be used
(0061) ; for new designs.
(0062) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(0063) export  bUART_1_ReadTxStatus
(0064) export _bUART_1_ReadTxStatus
(0065) export  bUART_1_ReadRxData
(0066) export _bUART_1_ReadRxData
(0067) export  bUART_1_ReadRxStatus
(0068) export _bUART_1_ReadRxStatus
(0069) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(0070) ;             END WARNING
(0071) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(0072) 
(0073) area text (ROM,REL)
(0074) 
(0075) ;-----------------------------------------------
(0076) ;  EQUATES
(0077) ;-----------------------------------------------
(0078) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
(0079) 
(0080) AREA UserModules (ROM, REL)
(0081) .SECTION
(0082) ;-----------------------------------------------------------------------------
(0083) ;  FUNCTION NAME: UART_1_EnableInt
(0084) ;
(0085) ;  DESCRIPTION:
(0086) ;     Enables this UART's interrupt by setting the interrupt enable mask
(0087) ;     bit associated with this User Module. Remember to call the global
(0088) ;     interrupt enable function by using the macro: M8C_EnableGInt.
(0089) ;
(0090) ;  ARGUMENTS:
(0091) ;     none.
(0092) ;
(0093) ;  RETURNS:
(0094) ;     none.
(0095) ;
(0096) ;  SIDE EFFECTS:
(0097) ;     REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
(0098) ;
(0099) ;  THEORY of OPERATION OR PROCEDURE:
(0100) ;     Sets the specific user module interrupt enable mask bit in both the
(0101) ;     TX and RX blocks.
(0102) ;
(0103) ;-----------------------------------------------------------------------------
(0104)  UART_1_EnableInt:
(0105) _UART_1_EnableInt:
(0106)    M8C_EnableIntMask UART_1_TX_INT_REG, UART_1_TX_INT_MASK
        0946: 43 E1 40 OR    REG[225],64
(0107)    M8C_EnableIntMask UART_1_RX_INT_REG, UART_1_RX_INT_MASK
        0949: 43 E1 08 OR    REG[225],8
(0108)    ret
        094C: 7F       RET   
(0109) .ENDSECTION
(0110) 
(0111) .SECTION
(0112) ;-----------------------------------------------------------------------------
(0113) ;  FUNCTION NAME: UART_1_DisableInt
(0114) ;
(0115) ;  DESCRIPTION:
(0116) ;     Disables this UART's interrupt by clearing the interrupt enable mask bit
(0117) ;     associated with this User Module.
(0118) ;
(0119) ;  ARGUMENTS:
(0120) ;     none.
(0121) ;
(0122) ;  RETURNS:
(0123) ;     none.
(0124) ;
(0125) ;  SIDE EFFECTS:
(0126) ;     REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
(0127) ;
(0128) ;  THEORY of OPERATION OR PROCEDURE:
(0129) ;     Clears the specific user module interrupt enable mask bit in the TX
(0130) ;     and RX blocks.
(0131) ;
(0132) ;-----------------------------------------------------------------------------
(0133)  UART_1_DisableInt:
(0134) _UART_1_DisableInt:
(0135)    M8C_DisableIntMask UART_1_TX_INT_REG, UART_1_TX_INT_MASK
        094D: 41 E1 BF AND   REG[225],191
(0136)    M8C_DisableIntMask UART_1_RX_INT_REG, UART_1_RX_INT_MASK
        0950: 41 E1 F7 AND   REG[225],247
(0137)    ret
        0953: 7F       RET   
(0138) 
(0139) .ENDSECTION
(0140) 
(0141) .SECTION
(0142) ;-----------------------------------------------------------------------------
(0143) ;  FUNCTION NAME: UART_1_Start(BYTE bParity)
(0144) ;
(0145) ;  DESCRIPTION:
(0146) ;     Sets the start bit and parity in the Control register of this user module.
(0147) ;
(0148) ;  ARGUMENTS:
(0149) ;     BYTE bParity - parity setting for the Transmitter and receiver. Use defined masks.
(0150) ;        Passed in the A register.
(0151) ;
(0152) ;  RETURNS:
(0153) ;     none.
(0154) ;
(0155) ;  SIDE EFFECTS:
(0156) ;     REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
(0157) ;
(0158) ;  THEORY of OPERATION OR PROCEDURE:
(0159) ;     Set the specified parity and start bits in the Control register of the
(0160) ;     TX and RX blocks.
(0161) ;
(0162) ;-----------------------------------------------------------------------------
(0163)  UART_1_Start:
(0164) _UART_1_Start:
(0165)    or    A, bfCONTROL_REG_START_BIT
        0954: 29 01    OR    A,1
(0166)    mov   REG[UART_1_TX_CONTROL_REG], A
        0956: 60 3B    MOV   REG[59],A
(0167)    mov   REG[UART_1_RX_CONTROL_REG], A
        0958: 60 2F    MOV   REG[47],A
(0168) IF (UART_1_RXBUF_ENABLE)
(0169)    call  _UART_1_CmdReset
(0170) ENDIF
(0171)    ret
        095A: 7F       RET   
(0172) .ENDSECTION
(0173) 
(0174) .SECTION
(0175) ;-----------------------------------------------------------------------------
(0176) ;  FUNCTION NAME: UART_1_Stop
(0177) ;
(0178) ;  DESCRIPTION:
(0179) ;     Disables UART operation.
(0180) ;
(0181) ;  ARGUMENTS:
(0182) ;     none.
(0183) ;
(0184) ;  RETURNS:
(0185) ;     none.
(0186) ;
(0187) ;  SIDE EFFECTS:
(0188) ;     REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
(0189) ;
(0190) ;  THEORY of OPERATION OR PROCEDURE:
(0191) ;     Clear the start bit in the Control registers.
(0192) ;
(0193) ;-----------------------------------------------------------------------------
(0194)  UART_1_Stop:
(0195) _UART_1_Stop:
(0196)    and   REG[UART_1_TX_CONTROL_REG], ~bfCONTROL_REG_START_BIT
        095B: 41 3B FE AND   REG[59],254
(0197)    and   REG[UART_1_RX_CONTROL_REG], ~bfCONTROL_REG_START_BIT
        095E: 41 2F FE AND   REG[47],254
(0198)    ret
        0961: 7F       RET   
(0199) .ENDSECTION
(0200) 
(0201) .SECTION
(0202) ;-----------------------------------------------------------------------------
(0203) ;  FUNCTION NAME: UART_1_SendData
(0204) ;
(0205) ;  DESCRIPTION:
(0206) ;     Initiates a transmission of data.
(0207) ;
(0208) ;  ARGUMENTS:
(0209) ;     BYTE  TxData - data to transmit. PASSED in A register.
(0210) ;
(0211) ;  RETURNS:
(0212) ;     none.
(0213) ;
(0214) ;  SIDE EFFECTS:
(0215) ;     REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
(0216) ;
(0217) ;  THEORY of OPERATION OR PROCEDURE:
(0218) ;     Writes data to the TX buffer register.
(0219) ;
(0220) ;-----------------------------------------------------------------------------
(0221)  UART_1_SendData:
(0222) _UART_1_SendData:
(0223)         mov REG[UART_1_TX_BUFFER_REG], A
        0962: 60 39    MOV   REG[57],A
(0224)         ret
        0964: 7F       RET   
(0225) .ENDSECTION
(0226) 
(0227) .SECTION
(0228) ;-----------------------------------------------------------------------------
(0229) ;  FUNCTION NAME: UART_1_bReadTxStatus
(0230) ;
(0231) ;  DESCRIPTION:
(0232) ;     Reads the Tx Status bits in the Control/Status register.
(0233) ;;     REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
(0234) ;  ARGUMENTS:
(0235) ;     none.
(0236) ;
(0237) ;  RETURNS:
(0238) ;     BYTE  bTxStatus - transmit status data.  Use defined masks for detecting
(0239) ;           status bits (returned in A)
(0240) ;
(0241) ;  SIDE EFFECTS:
(0242) ;     REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
(0243) ;
(0244) ;  THEORY of OPERATION OR PROCEDURE:
(0245) ;     Read TX status and control register.
(0246) ;
(0247) ;-----------------------------------------------------------------------------
(0248)  UART_1_bReadTxStatus:
(0249) _UART_1_bReadTxStatus:
(0250)  bUART_1_ReadTxStatus:    ; For backwards compatibility only
(0251) _bUART_1_ReadTxStatus:    ; For backwards compatibility only
(0252)         mov A,  REG[UART_1_TX_CONTROL_REG]
        0965: 5D 3B    MOV   A,REG[59]
(0253)         ret
        0967: 7F       RET   
(0254) .ENDSECTION
(0255) 
(0256) .SECTION
(0257) ;-----------------------------------------------------------------------------
(0258) ;  FUNCTION NAME: UART_1_bReadRxData
(0259) ;
(0260) ;  DESCRIPTION:
(0261) ;     Reads the RX buffer register.  Should check the status regiser to make
(0262) ;     sure data is valid.
(0263) ;
(0264) ;  ARGUMENTS:
(0265) ;     none.
(0266) ;
(0267) ;  RETURNS:
(0268) ;     bRxData - returned in A.
(0269) ;
(0270) ;  SIDE EFFECTS:
(0271) ;     REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
(0272) ;
(0273) ;  THEORY of OPERATION OR PROCEDURE:
(0274) ;     none.
(0275) ;
(0276) ;-----------------------------------------------------------------------------
(0277)  UART_1_bReadRxData:
(0278) _UART_1_bReadRxData:
(0279)  bUART_1_ReadRxData:    ; For backwards compatibility only
(0280) _bUART_1_ReadRxData:    ; For backwards compatibility only
(0281)         mov A, REG[UART_1_RX_BUFFER_REG]
        0968: 5D 2E    MOV   A,REG[46]
(0282)         ret
        096A: 7F       RET   
(0283) .ENDSECTION
(0284) 
(0285) .SECTION
(0286) ;-----------------------------------------------------------------------------
(0287) ;  FUNCTION NAME: UART_1_bReadRxStatus
(0288) ;
(0289) ;  DESCRIPTION:
(0290) ;     Reads the RX Status bits in the Control/Status register.
(0291) ;
(0292) ;  ARGUMENTS:
(0293) ;     none.
(0294) ;
(0295) ;  RETURNS:
(0296) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
(0297) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
(0298) ;           returned in A.
(0299) ;
(0300) ;  SIDE EFFECTS:
(0301) ;     REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
(0302) ;
(0303) ;  THEORY of OPERATION OR PROCEDURE:
(0304) ;     Read the status and control register.
(0305) ;
(0306) ;-----------------------------------------------------------------------------
(0307)  UART_1_bReadRxStatus:
(0308) _UART_1_bReadRxStatus:
(0309)  bUART_1_ReadRxStatus:     ; For backwards compatibility only
(0310) _bUART_1_ReadRxStatus:     ; For backwards compatibility only
(0311)         mov A,  REG[UART_1_RX_CONTROL_REG]
        096B: 5D 2F    MOV   A,REG[47]
(0312)         ret
        096D: 7F       RET   
FILE: lib\timer8_1.asm
(0001) ;;*****************************************************************************
(0002) ;;*****************************************************************************
(0003) ;;  FILENAME: Timer8_1.asm
(0004) ;;   Version: 2.2, Updated on 2003/11/10 at 16:40:54
(0005) ;;  Generated by PSoC Designer ver 4.1 b931 : 21 January, 2004
(0006) ;;
(0007) ;;  DESCRIPTION: Timer8 User Module software implementation file
(0008) ;;               for the 22/24/27/28xxx PSoC family of devices
(0009) ;;
(0010) ;;  NOTE: User Module APIs conform to the fastcall convention for marshalling
(0011) ;;        arguments and observe the associated "Registers are volatile" policy.
(0012) ;;        This means it is the caller's responsibility to preserve any values
(0013) ;;        in the X and A registers that are still needed after the API
(0014) ;;        function returns. Even though these registers may be preserved now,
(0015) ;;        there is no guarantee they will be preserved in future releases.
(0016) ;;-----------------------------------------------------------------------------
(0017) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
(0018) ;;*****************************************************************************
(0019) ;;*****************************************************************************
(0020) 
(0021) include "m8c.inc"
(0022) include "Timer8_1.inc"
(0023) 
(0024) ;-----------------------------------------------
(0025) ;  Global Symbols
(0026) ;-----------------------------------------------
(0027) export  Timer8_1_EnableInt
(0028) export _Timer8_1_EnableInt
(0029) export  Timer8_1_DisableInt
(0030) export _Timer8_1_DisableInt
(0031) export  Timer8_1_Start
(0032) export _Timer8_1_Start
(0033) export  Timer8_1_Stop
(0034) export _Timer8_1_Stop
(0035) export  Timer8_1_WritePeriod
(0036) export _Timer8_1_WritePeriod
(0037) export  Timer8_1_WriteCompareValue
(0038) export _Timer8_1_WriteCompareValue
(0039) export  Timer8_1_bReadCompareValue
(0040) export _Timer8_1_bReadCompareValue
(0041) export  Timer8_1_bReadTimer
(0042) export _Timer8_1_bReadTimer
(0043) export  Timer8_1_bReadTimerSaveCV
(0044) export _Timer8_1_bReadTimerSaveCV
(0045) 
(0046) ; The following functions are deprecated and subject to omission in future releases
(0047) ;
(0048) export  bTimer8_1_ReadCompareValue  ; deprecated
(0049) export _bTimer8_1_ReadCompareValue  ; deprecated
(0050) export  bTimer8_1_ReadTimer         ; deprecated
(0051) export _bTimer8_1_ReadTimer         ; deprecated
(0052) export  bTimer8_1_ReadTimerSaveCV   ; deprecated
(0053) export _bTimer8_1_ReadTimerSaveCV   ; deprecated
(0054) 
(0055) export  bTimer8_1_ReadCounter       ; obsolete
(0056) export _bTimer8_1_ReadCounter       ; obsolete
(0057) export  bTimer8_1_CaptureCounter    ; obsolete
(0058) export _bTimer8_1_CaptureCounter    ; obsolete
(0059) 
(0060) 
(0061) AREA bss (RAM,REL)
(0062) 
(0063) ;-----------------------------------------------
(0064) ;  Constant Definitions
(0065) ;-----------------------------------------------
(0066) 
(0067) 
(0068) ;-----------------------------------------------
(0069) ; Variable Allocation
(0070) ;-----------------------------------------------
(0071) 
(0072) 
(0073) AREA UserModules (ROM, REL)
(0074) 
(0075) .SECTION
(0076) ;-----------------------------------------------------------------------------
(0077) ;  FUNCTION NAME: Timer8_1_EnableInt
(0078) ;
(0079) ;  DESCRIPTION:
(0080) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
(0081) ;     associated with this User Module. This function has no effect until and
(0082) ;     unless the global interrupts are enabled (for example by using the
(0083) ;     macro M8C_EnableGInt).
(0084) ;-----------------------------------------------------------------------------
(0085) ;
(0086) ;  ARGUMENTS:    None.
(0087) ;  RETURNS:      Nothing.
(0088) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
(0089) ;
(0090)  Timer8_1_EnableInt:
(0091) _Timer8_1_EnableInt:
(0092)    Timer8_1_EnableInt_M
        096E: 43 E1 80 OR    REG[225],128
(0093)    ret
        0971: 7F       RET   
(0094) 
(0095) .ENDSECTION
(0096) 
(0097) 
(0098) .SECTION
(0099) ;-----------------------------------------------------------------------------
(0100) ;  FUNCTION NAME: Timer8_1_DisableInt
(0101) ;
(0102) ;  DESCRIPTION:
(0103) ;     Disables this timer's interrupt by clearing the interrupt enable
(0104) ;     mask bit associated with this User Module.
(0105) ;-----------------------------------------------------------------------------
(0106) ;
(0107) ;  ARGUMENTS:    None
(0108) ;  RETURNS:      Nothing
(0109) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
(0110) ;
(0111)  Timer8_1_DisableInt:
(0112) _Timer8_1_DisableInt:
(0113)    Timer8_1_DisableInt_M
        0972: 41 E1 7F AND   REG[225],127
(0114)    ret
        0975: 7F       RET   
(0115) 
(0116) .ENDSECTION
(0117) 
(0118) 
(0119) .SECTION
(0120) ;-----------------------------------------------------------------------------
(0121) ;  FUNCTION NAME: Timer8_1_Start
(0122) ;
(0123) ;  DESCRIPTION:
(0124) ;     Sets the start bit in the Control register of this user module.  The
(0125) ;     timer will begin counting on the next input clock.
(0126) ;-----------------------------------------------------------------------------
(0127) ;
(0128) ;  ARGUMENTS:    None
(0129) ;  RETURNS:      Nothing
(0130) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
(0131) ;
(0132)  Timer8_1_Start:
(0133) _Timer8_1_Start:
(0134)    Timer8_1_Start_M
        0976: 43 3F 01 OR    REG[63],1
(0135)    ret
        0979: 7F       RET   
(0136) 
(0137) .ENDSECTION
(0138) 
(0139) 
(0140) .SECTION
(0141) ;-----------------------------------------------------------------------------
(0142) ;  FUNCTION NAME: Timer8_1_Stop
(0143) ;
(0144) ;  DESCRIPTION:
(0145) ;     Disables timer operation by clearing the start bit in the Control
(0146) ;     register.
(0147) ;-----------------------------------------------------------------------------
(0148) ;
(0149) ;  ARGUMENTS:    None
(0150) ;  RETURNS:      Nothing
(0151) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
(0152) ;
(0153)  Timer8_1_Stop:
(0154) _Timer8_1_Stop:
(0155)    Timer8_1_Stop_M
        097A: 41 3F FE AND   REG[63],254
(0156)    ret
        097D: 7F       RET   
(0157) 
(0158) .ENDSECTION
(0159) 
(0160) 
(0161) .SECTION
(0162) ;-----------------------------------------------------------------------------
(0163) ;  FUNCTION NAME: Timer8_1_WritePeriod
(0164) ;
(0165) ;  DESCRIPTION:
(0166) ;     Write the 8-bit period value into the Period register (DR1). If the
(0167) ;     Timer user module is stopped, then this value will also be latched
(0168) ;     into the Count register (DR0).
(0169) ;-----------------------------------------------------------------------------
(0170) ;
(0171) ;  ARGUMENTS: fastcall BYTE bPeriodValue (passed in A)
(0172) ;  RETURNS:   Nothing
(0173) ;  SIDE EFFECTS:
(0174) ;     REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
(0175) ;
(0176)  Timer8_1_WritePeriod:
(0177) _Timer8_1_WritePeriod:
(0178)    mov   reg[Timer8_1_PERIOD_REG], A
        097E: 60 3D    MOV   REG[61],A
(0179)    ret
        0980: 7F       RET   
(0180) 
(0181) .ENDSECTION
(0182) 
(0183) 
(0184) .SECTION
(0185) ;-----------------------------------------------------------------------------
(0186) ;  FUNCTION NAME: Timer8_1_WriteCompareValue
(0187) ;
(0188) ;  DESCRIPTION:
(0189) ;     Writes compare value into the Compare register (DR2).
(0190) ;
(0191) ;     NOTE! The Timer user module must be STOPPED in order to write the
(0192) ;           Compare register. (Call Timer8_1_Stop to disable).
(0193) ;-----------------------------------------------------------------------------
(0194) ;
(0195) ;  ARGUMENTS:    fastcall BYTE bCompareValue (passed in A)
(0196) ;  RETURNS:      Nothing
(0197) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
(0198) ;
(0199)  Timer8_1_WriteCompareValue:
(0200) _Timer8_1_WriteCompareValue:
(0201)    mov   reg[Timer8_1_COMPARE_REG], A
        0981: 60 3E    MOV   REG[62],A
(0202)    ret
        0983: 7F       RET   
(0203) 
(0204) .ENDSECTION
(0205) 
(0206) 
(0207) .SECTION
(0208) ;-----------------------------------------------------------------------------
(0209) ;  FUNCTION NAME: Timer8_1_bReadCompareValue
(0210) ;
(0211) ;  DESCRIPTION:
(0212) ;     Reads the Compare register.
(0213) ;-----------------------------------------------------------------------------
(0214) ;
(0215) ;  ARGUMENTS:    None
(0216) ;  RETURNS:      fastcall BYTE bCompareValue (value of DR2 in the A register)
(0217) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
(0218) ;
(0219)  Timer8_1_bReadCompareValue:
(0220) _Timer8_1_bReadCompareValue:
(0221)  bTimer8_1_ReadCompareValue:                     ; this name deprecated
(0222) _bTimer8_1_ReadCompareValue:                     ; this name deprecated
(0223)    mov   A, reg[Timer8_1_COMPARE_REG]
        0984: 5D 3E    MOV   A,REG[62]
(0224)    ret
        0986: 7F       RET   
(0225) 
(0226) .ENDSECTION
(0227) 
(0228) 
(0229) .SECTION
(0230) ;-----------------------------------------------------------------------------
(0231) ;  FUNCTION NAME: Timer8_1_bReadTimerSaveCV
(0232) ;
(0233) ;  DESCRIPTION:
(0234) ;     Returns the value in the Count register (DR0), preserving the
(0235) ;     value in the compare register (DR2).
(0236) ;-----------------------------------------------------------------------------
(0237) ;
(0238) ;  ARGUMENTS: None
(0239) ;  RETURNS:   fastcall BYTE bCount (value of DR0 in the A register)
(0240) ;  SIDE EFFECTS:
(0241) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
(0242) ;     2) If enabled, Global interrupts are momentarily disabled.
(0243) ;     3) The user module is stopped momentarily while the compare value is
(0244) ;        restored.  This may cause the Count register to miss one or more
(0245) ;        counts depending on the input clock speed.
(0246) ;     4) REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
(0247) ;
(0248) ;  THEORY of OPERATION:
(0249) ;     1) Read and save the Compare register.
(0250) ;     2) Read the Count register, causing its data to be latched into
(0251) ;        the Compare register.
(0252) ;     3) Read and save the Counter value, now in the Compare register,
(0253) ;        to the buffer.
(0254) ;     4) Disable global interrupts
(0255) ;     5) Halt the timer
(0256) ;     6) Restore the Compare register values
(0257) ;     7) Start the Timer again
(0258) ;     8) Restore global interrupt state
(0259) ;
(0260)  Timer8_1_bReadTimerSaveCV:
(0261) _Timer8_1_bReadTimerSaveCV:
(0262)  bTimer8_1_ReadTimerSaveCV:                      ; this name deprecated
(0263) _bTimer8_1_ReadTimerSaveCV:                      ; this name deprecated
(0264)  bTimer8_1_ReadCounter:                          ; this name deprecated
(0265) _bTimer8_1_ReadCounter:                          ; this name deprecated
(0266) 
(0267) CpuFlags:      equ   0
(0268) bCount:        equ   1
(0269) 
(0270)    mov   X, SP                                   ; X <- stack frame pointer
        0987: 4F       MOV   X,SP
(0271)    add   SP, 2                                   ; Reserve space for flags, count
        0988: 38 02    ADD   SP,2
(0272)    mov   A, reg[Timer8_1_CONTROL_REG]            ; save the Control register
        098A: 5D 3F    MOV   A,REG[63]
(0273)    push  A
        098C: 08       PUSH  A
(0274)    mov   A, reg[Timer8_1_COMPARE_REG]            ; save the Compare register
        098D: 5D 3E    MOV   A,REG[62]
(0275)    push  A
        098F: 08       PUSH  A
(0276)    mov   A, reg[Timer8_1_COUNTER_REG]            ; synchronous copy DR2 <- DR0
        0990: 5D 3C    MOV   A,REG[60]
(0277)                                                  ; This may cause an interrupt!
(0278)    mov   A, reg[Timer8_1_COMPARE_REG]            ; Now grab DR2 (DR0) and save
        0992: 5D 3E    MOV   A,REG[62]
(0279)    mov   [X+bCount], A
        0994: 54 01    MOV   [X+1],A
(0280)    mov   A, 0                                    ; Guess the global interrupt state
        0996: 50 00    MOV   A,0
(0281)    tst   reg[CPU_SCR0], CPU_SCR0_GIE_MASK        ; Currently Disabled?
        0998: 49 FF 80 TST   REG[255],128
(0282)    jz    .SetupStatusFlag                        ;   Yes, guess was correct
        099B: A0 03    JZ    0x099F
(0283)    mov   A, FLAG_GLOBAL_IE                       ;    No, modify our guess
        099D: 50 01    MOV   A,1
(0284) .SetupStatusFlag:                                ; and ...
(0285)    mov   [X+CpuFlags], A                         ;   StackFrame[0] <- Flag Reg image
        099F: 54 00    MOV   [X+0],A
(0286)    M8C_DisableGInt                               ; Disable interrupts globally
        09A1: 70 FE    AND   F,254
(0287)    Timer8_1_Stop_M                               ; Stop the timer
        09A3: 41 3F FE AND   REG[63],254
(0288)    pop   A                                       ; Restore the Compare register
        09A6: 18       POP   A
(0289)    mov   reg[Timer8_1_COMPARE_REG], A
        09A7: 60 3E    MOV   REG[62],A
(0290)    pop   A                                       ; restore start state of the timer
        09A9: 18       POP   A
(0291)    mov   reg[Timer8_1_CONTROL_REG], A
        09AA: 60 3F    MOV   REG[63],A
(0292)    pop   A                                       ; Return result stored in stack frame
        09AC: 18       POP   A
(0293)    reti                                          ; Flag Reg <- StackFrame[0]
        09AD: 7E       RETI  
(0294) 
(0295) .ENDSECTION
(0296) 
(0297) 
(0298) .SECTION
(0299) ;-----------------------------------------------------------------------------
(0300) ;  FUNCTION NAME: Timer8_1_bReadTimer
(0301) ;
(0302) ;  DESCRIPTION:
(0303) ;     Performs a software capture of the Count register.  A synchronous
(0304) ;     read of the Count register is performed.  The timer is NOT stopped.
(0305) ;
(0306) ;     WARNING - this will cause loss of data in the Compare register.
(0307) ;-----------------------------------------------------------------------------
(0308) ;
(0309) ;  ARGUMENTS:    None
(0310) ;  RETURNS:      fastcall BYTE bCount, (value of DR0 in the A register)
(0311) ;  SIDE EFFECTS:
(0312) ;     May cause an interrupt.
(0313) ;     REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
(0314) ;
(0315) ;  THEORY of OPERATION:
(0316) ;     1) Read the Count register - this causes the count value to be
(0317) ;        latched into the Compare register.
(0318) ;     2) Read and return the Count register values from the Compare
(0319) ;        registers into the return buffer.
(0320) ;
(0321)  Timer8_1_bReadTimer:
(0322) _Timer8_1_bReadTimer:
(0323)  bTimer8_1_ReadTimer:                            ; this name deprecated
(0324) _bTimer8_1_ReadTimer:                            ; this name deprecated
(0325)  bTimer8_1_CaptureCounter:                       ; this name deprecated
(0326) _bTimer8_1_CaptureCounter:                       ; this name deprecated
(0327) 
(0328)    mov   A, reg[Timer8_1_COUNTER_REG]            ; synchronous copy DR2 <- DR0
        09AE: 5D 3C    MOV   A,REG[60]
(0329)                                                  ; This may cause an interrupt!
(0330)    mov   A, reg[Timer8_1_COMPARE_REG]            ; Return DR2 (actually DR0)
        09B0: 5D 3E    MOV   A,REG[62]
(0331)    ret
        09B2: 7F       RET   
FILE: .\cirbuf.c
(0001) /*	Copyright (C) 2004 cheng chung yan <yan@amonics.com> for 8-bit system linlike8
(0002)  *	lib C in linlike8 8 bit system
(0003)  *
(0004)  *	cirbuf.c
(0005)  *
(0006)  *	Design Concept
(0007)  *		Make a circular buffer template.
(0008)  *		this is only a template, not for real code to work, please implement this code into your application area.
(0009)  *
(0010)  *			| wr ptr
(0011)  *		top	V			       bottom
(0012)  *		|<------------------------------------>| buffer		wr and rd ptr, they both must go upward, then circular
(0013)  *				^					wr ptr must go prior rd
(0014)  *				| rd ptr
(0015)  *
(0016)  *  Testing Procedures
(0017)  *	before you compile, you must copy whole directory of linlike8/ to your local home
(0018)  *	compile this file in linux gcc environment : " make cirbuf_to_run.o"
(0019)  *	testing by : "main_compile_dir/cirbuf_to_run.o"
(0020)  *
(0021)  */
(0022) 
(0023) unsigned char pre_wr_cir254buf(unsigned char wr, unsigned char rd, unsigned char max)
(0024) {
_pre_wr_cir254buf:
  wr_backup            --> X+0
  max                  --> X-6
  rd                   --> X-5
  wr                   --> X-4
__text_start:
        09B3: 10       PUSH  X
        09B4: 4F       MOV   X,SP
        09B5: 38 01    ADD   SP,1
(0025) 	unsigned char wr_backup = wr + 1;
        09B7: 52 FC    MOV   A,[X-4]
        09B9: 01 01    ADD   A,1
        09BB: 54 00    MOV   [X+0],A
(0026) 	if (wr_backup==max) wr_backup = 0;
        09BD: 52 00    MOV   A,[X+0]
        09BF: 3B FA    CMP   A,[X-6]
        09C1: B0 04    JNZ   0x09C6
        09C3: 56 00 00 MOV   [X+0],0
(0027) 	if (wr_backup==rd) return 255;
        09C6: 52 00    MOV   A,[X+0]
        09C8: 3B FB    CMP   A,[X-5]
        09CA: B0 05    JNZ   0x09D0
        09CC: 50 FF    MOV   A,255
        09CE: 80 03    JMP   0x09D2
(0028) 	else return wr_backup;
        09D0: 52 00    MOV   A,[X+0]
        09D2: 38 FF    ADD   SP,255
        09D4: 20       POP   X
        09D5: 7F       RET   
(0029) }
(0030) 
(0031) unsigned char pre_rd_cir254buf(unsigned char wr, unsigned char rd, unsigned char max)
(0032) {
_pre_rd_cir254buf:
  rd_backup            --> X+0
  max                  --> X-6
  rd                   --> X-5
  wr                   --> X-4
        09D6: 10       PUSH  X
        09D7: 4F       MOV   X,SP
        09D8: 38 01    ADD   SP,1
(0033) 	unsigned char rd_backup;
(0034) 	if (rd==wr) return 255;
        09DA: 52 FB    MOV   A,[X-5]
        09DC: 3B FC    CMP   A,[X-4]
        09DE: B0 05    JNZ   0x09E4
        09E0: 50 FF    MOV   A,255
        09E2: 80 12    JMP   0x09F5
(0035) 	else {
(0036) 		rd_backup = rd + 1;
        09E4: 52 FB    MOV   A,[X-5]
        09E6: 01 01    ADD   A,1
        09E8: 54 00    MOV   [X+0],A
(0037) 		if (rd_backup==max) rd_backup = 0;
        09EA: 52 00    MOV   A,[X+0]
        09EC: 3B FA    CMP   A,[X-6]
        09EE: B0 04    JNZ   0x09F3
        09F0: 56 00 00 MOV   [X+0],0
(0038) 		return rd_backup;
        09F3: 52 00    MOV   A,[X+0]
        09F5: 38 FF    ADD   SP,255
        09F7: 20       POP   X
        09F8: 7F       RET   
FILE: .\fork.c
(0001) /*
(0002)  *	linlike8/kernel/fork.c
(0003)  *
(0004)  *	10-04-2004	yan	create this following linux
(0005)  *
(0006)  *	fork new process
(0007)  */
(0008) 
(0009) #include "app.h"
(0010) #include "sched.h"
(0011) #include "current.h"									// MUST be placed after sched.h
(0012) #include "system.h"									// MUST be placed after sched.h
(0013) 
(0014) #if (CONTEXT_SW==1)
(0015) 		// process_num - hardcode number, beware to not double
(0016) 		// get the previous process stack size, then cal. the new process stack starting point
(0017) void do_fork(unsigned char process_num, unsigned char prev_stack_size, p_func process)
(0018) {
_do_fork:
  process              --> X-7
  prev_stack_size      --> X-5
  process_num          --> X-4
        09F9: 10       PUSH  X
        09FA: 4F       MOV   X,SP
(0019) 	//task[process_num] = *current;							// allocate memory for new process, then copy the existing process content to new one
(0020) 	task[process_num].stack_ptr = task[process_num-1].stack_ptr + prev_stack_size;
        09FB: 52 FC    MOV   A,[X-4]
        09FD: 53 0D    MOV   [__r1],A
        09FF: 55 0E 00 MOV   [__r0],0
        0A02: 65 0D    ASL   [__r1]
        0A04: 6B 0E    RLC   [__r0]
        0A06: 06 0D 13 ADD   [__r1],19
        0A09: 0E 0E 00 ADC   [__r0],0
        0A0C: 52 FC    MOV   A,[X-4]
        0A0E: 53 0B    MOV   [__r3],A
        0A10: 55 0C 00 MOV   [__r2],0
        0A13: 16 0B 01 SUB   [__r3],1
        0A16: 1E 0C 00 SBB   [__r2],0
        0A19: 65 0B    ASL   [__r3]
        0A1B: 6B 0C    RLC   [__r2]
        0A1D: 06 0B 13 ADD   [__r3],19
        0A20: 0E 0C 00 ADC   [__r2],0
        0A23: 3E 0B    MVI   A,[__r3]
        0A25: 53 0C    MOV   [__r2],A
        0A27: 52 FB    MOV   A,[X-5]
        0A29: 04 0C    ADD   [__r2],A
        0A2B: 51 0C    MOV   A,[__r2]
        0A2D: 3F 0D    MVI   [__r1],A
(0021) 	place_process_stack();
        0A2F: 52 FC    MOV   A,[X-4]
        0A31: 53 0D    MOV   [__r1],A
        0A33: 55 0E 00 MOV   [__r0],0
        0A36: 65 0D    ASL   [__r1]
        0A38: 6B 0E    RLC   [__r0]
        0A3A: 06 0D 13 ADD   [__r1],19
        0A3D: 0E 0E 00 ADC   [__r0],0
        0A40: 3E 0D    MVI   A,[__r1]
        0A42: 53 0D    MOV   [__r1],A
        0A44: 55 0E 00 MOV   [__r0],0
        0A47: 52 FA    MOV   A,[X-6]
        0A49: 53 0B    MOV   [__r3],A
        0A4B: 52 F9    MOV   A,[X-7]
        0A4D: 10       PUSH  X
        0A4E: 08       PUSH  A
        0A4F: 58 0B    MOV   X,[__r3]
        0A51: 28       ROMX  
        0A52: 53 0C    MOV   [__r2],A
        0A54: 18       POP   A
        0A55: 75       INC   X
        0A56: 09 00    ADC   A,0
        0A58: 28       ROMX  
        0A59: 53 0B    MOV   [__r3],A
        0A5B: 20       POP   X
        0A5C: 51 0C    MOV   A,[__r2]
        0A5E: 3F 0D    MVI   [__r1],A
        0A60: 51 0B    MOV   A,[__r3]
        0A62: 3F 0D    MVI   [__r1],A
        0A64: 52 FC    MOV   A,[X-4]
        0A66: 53 0D    MOV   [__r1],A
        0A68: 65 0D    ASL   [__r1]
        0A6A: 6B 0E    RLC   [__r0]
        0A6C: 06 0D 13 ADD   [__r1],19
        0A6F: 0E 0E 00 ADC   [__r0],0
        0A72: 3E 0D    MVI   A,[__r1]
        0A74: 7A 0D    DEC   [__r1]
        0A76: 01 03    ADD   A,3
        0A78: 3F 0D    MVI   [__r1],A
(0022) 	wake_up_process((&task[process_num]));
        0A7A: 52 FC    MOV   A,[X-4]
        0A7C: 53 0D    MOV   [__r1],A
        0A7E: 55 0E 00 MOV   [__r0],0
        0A81: 65 0D    ASL   [__r1]
        0A83: 6B 0E    RLC   [__r0]
        0A85: 06 0D 14 ADD   [__r1],20
        0A88: 0E 0E 00 ADC   [__r0],0
        0A8B: 50 00    MOV   A,0
        0A8D: 3F 0D    MVI   [__r1],A
(0023) 	//return ;	return 0 as parent, return pid as child
(0024) }
        0A8F: 20       POP   X
        0A90: 7F       RET   
FILE: .\interrupt.h
(0001) /*
(0002)  *	header of interrupt
(0003)  *	
(0004)  *	include/linlike8/interrupt.h
(0005)  *
(0006)  *	29-04-2004	yan	create this following linux
(0007)  *
(0008)  *	Remarks
(0009)  *		must be placed after hardirq.h
(0010)  */
(0011) 
(0012) extern unsigned char softirq_vec;
(0013) 
(0014) enum {
(0015) 	TIMER_BH = 0,									// timer is always has interrupt, so let it to chk and do 1st to reduce each interrupt time consuming
(0016) 	GPIO_BH
(0017) };
(0018) 
(0019) extern void do_softirq(void);
(0020) 
(0021) static void mark_bh(unsigned char nr)
(0022) {
_mark_bh:
  nr                   --> X-4
  nr                   --> X-4
  nr                   --> X-4
        0A91: 10       PUSH  X
        0A92: 4F       MOV   X,SP
(0023) 	softirq_vec |= (0x01 << nr);
        0A93: 55 0E 01 MOV   [__r0],1
        0A96: 52 FC    MOV   A,[X-4]
        0A98: 21 07    AND   A,7
        0A9A: A0 06    JZ    0x0AA1
        0A9C: 65 0E    ASL   [__r0]
        0A9E: 78       DEC   A
        0A9F: BF FC    JNZ   0x0A9C
        0AA1: 51 27    MOV   A,[_softirq_vec]
        0AA3: 2A 0E    OR    A,[__r0]
        0AA5: 53 27    MOV   [_softirq_vec],A
(0024) }
        0AA7: 20       POP   X
        0AA8: 7F       RET   
FILE: .\gpio.c
(0001) /*
(0002)  * Copyright (c) 24-05-2004 cheng chung yan yan@amonics.com> for 8-bit system
(0003)  *
(0004)  * this module is gpio in cypress psoc, driver specification. So each arch. has different codes here
(0005)  * 
(0006)  * date		author		reason
(0007)  * 26-07-2004	yan		not user friendly : when rotary key running in circular, ENTER key can't detected by interrupt
(0008)  *						    it is because rotary pin mode set as low level interrupt trigger in psoc. 
(0009)  *						    when circular running of rotary key, it is level interrupt until completed rotary one key.
(0010)  *						    so, change the interrupt mode of rotary pin as any changing in psoc
(0011)  * 27-07-2004	yan		gpio interrupt of psoc detect one interrupt from rotary key, but can't detect another enter key at same time
(0012)  *				so, remove the enter key from interrupt mode, change to scan mode in each timer isr
(0013)  * 03-08-2004	yan		improve the rotary encoder
(0014)  */
(0015) 
(0016) #include "app.h"									// this linlike8
(0017) #include <m8c.h>									// M8C_EnableIntMask()
(0018) #include "interrupt.h"									// mark_bh()
(0019) #include "gpio.h"									//
(0020) #if (KB_MOD==1)
(0021) 	#include "kb.h"									// kb hw driver(application dependent, so diff. appl. has diff. kb.h)
(0022) 	#include "gpio_kb_app.h"							// kb app.
(0023) 	#include "sched.h"									// schedule_timeout()
(0024) 	#include "timer.h"									// timer_list
(0025) #endif
(0026) 
(0027) //#include "psoc_gpio_bit.h"								// led_hw_off()
(0028) 
(0029) struct gpio_data gpio_var;
(0030) //#if (KB_MOD==1)
(0031) //struct timer_list deboucing_timer;
(0032) //void kb_deboudcing(void);
(0033) //#endif
(0034) 
(0035) void gpio_open(void)
(0036) {
(0037) #if (KB_MOD==1)
(0038)         UPPER_KEY_SET_HIGH;								// init. all pins -- logic high since pull high internal
_gpio_open:
        0AA9: 43 14 08 OR    REG[20],8
(0039)         ENTER_KEY_SET_HIGH;
        0AAC: 43 0C 02 OR    REG[12],2
(0040) 	DOWN_KEY_SET_HIGH;
        0AAF: 43 0C 08 OR    REG[12],8
(0041) 	gpio_var.key_deb_f = 0;								// 0 as clr key flag
        0AB2: 26 0F FD AND   [_gpio_var],253
(0042) 	gpio_var.key_fr_hi_lo = 1;							// init. in pull-high for scan key
        0AB5: 2E 0F 04 OR    [_gpio_var],4
(0043) 	#if (PUSH_KEY==1)
(0044) 	gpio_var.key_fr_hi_lo |= 0x06;
(0045) 	#endif
(0046) #endif
(0047)         M8C_EnableIntMask( INT_MSK0, INT_MSK0_GPIO );					// prepare GPIO
        0AB8: 43 E0 20 OR    REG[224],32
(0048) }
        0ABB: 7F       RET   
(0049) 
(0050) #pragma	interrupt_handler	gpio_isr						// shouald add this isr name at boot.asm from PSoC Designer
(0051) void gpio_isr(void)
(0052) {
_gpio_isr:
        0ABC: 08       PUSH  A
        0ABD: 51 0E    MOV   A,[__r0]
        0ABF: 08       PUSH  A
        0AC0: 51 0D    MOV   A,[__r1]
        0AC2: 08       PUSH  A
        0AC3: 51 0C    MOV   A,[__r2]
        0AC5: 08       PUSH  A
        0AC6: 51 0B    MOV   A,[__r3]
        0AC8: 08       PUSH  A
        0AC9: 51 0A    MOV   A,[__r4]
        0ACB: 08       PUSH  A
        0ACC: 51 09    MOV   A,[__r5]
        0ACE: 08       PUSH  A
        0ACF: 51 08    MOV   A,[__r6]
        0AD1: 08       PUSH  A
        0AD2: 51 07    MOV   A,[__r7]
        0AD4: 08       PUSH  A
        0AD5: 51 06    MOV   A,[__r8]
        0AD7: 08       PUSH  A
        0AD8: 51 05    MOV   A,[__r9]
        0ADA: 08       PUSH  A
        0ADB: 51 04    MOV   A,[__r10]
        0ADD: 08       PUSH  A
        0ADE: 51 03    MOV   A,[__r11]
        0AE0: 08       PUSH  A
        0AE1: 51 02    MOV   A,[__rX]
        0AE3: 08       PUSH  A
        0AE4: 51 01    MOV   A,[__rY]
        0AE6: 08       PUSH  A
        0AE7: 51 00    MOV   A,[NO_SHADOW]
        0AE9: 08       PUSH  A
(0053) 	
(0054) 	// fast interrupt
(0055) 	
(0056) #if (KB_MOD==1)
(0057) //unsigned char i;
(0058) //buz_hw_on;
(0059) //led_hw_off;
(0060) 	// scan key (this source change back to compatible all platform later)
(0061) 	//******************************************************************************
(0062) //	if (gpio_var.key_fr_hi_lo!=(ENTER_KEY_DET&&1)) {
(0063) //	if (!ENTER_KEY_DET) {
(0064) //		gpio_var.scan_key_event = 0;// interrupt from push button
(0065) 	#if (ROTARY_KEY==1)
(0066) 	if (UPPER_KEY_DET) {								// after interrupt(rising) from pin A
        0AEA: 49 14 08 TST   REG[20],8
        0AED: A0 2F    JZ    0x0B1D
(0067) 		if (DOWN_KEY_DET) {							//	if pin B is high, anti-clockwise
        0AEF: 49 0C 08 TST   REG[12],8
        0AF2: A0 0F    JZ    0x0B02
(0068) 			gpio_var.scan_key_event = 1;
        0AF4: 51 0F    MOV   A,[_gpio_var]
        0AF6: 21 E7    AND   A,231
        0AF8: 53 0E    MOV   [__r0],A
        0AFA: 2E 0E 08 OR    [__r0],8
        0AFD: 5F 0F 0E MOV   [_gpio_var],[__r0]
(0069) 		} else {								//	if pin B is low, clockwise
        0B00: 80 10    JMP   0x0B11
(0070) 			gpio_var.scan_key_event = 2;
        0B02: 51 0F    MOV   A,[_gpio_var]
        0B04: 21 E7    AND   A,231
        0B06: 53 0E    MOV   [__r0],A
        0B08: 2E 0E 10 OR    [__r0],16
        0B0B: 5F 0F 0E MOV   [_gpio_var],[__r0]
(0071) 			DOWN_KEY_SET_HIGH;
        0B0E: 43 0C 08 OR    REG[12],8
(0072) 		}
(0073) 		UPPER_KEY_INTR_FALLING;							//	enable pin A interrupt(falling)
        0B11: 71 10    OR    F,16
        0B13: 43 16 08 OR    REG[22],8
        0B16: 41 17 F7 AND   REG[23],247
        0B19: 70 EF    AND   F,239
(0074) 	} else {									// after interrupt(falling) from pin A
        0B1B: 80 0E    JMP   0x0B2A
(0075) 		UPPER_KEY_INTR_RISING;							//	enable pin A interrupt(rising)
        0B1D: 71 10    OR    F,16
        0B1F: 41 16 F7 AND   REG[22],247
        0B22: 43 17 08 OR    REG[23],8
        0B25: 70 EF    AND   F,239
(0076) 		UPPER_KEY_SET_HIGH;
        0B27: 43 14 08 OR    REG[20],8
(0077) 	}
(0078) //	UPPER_KEY_SET_HIGH;
(0079) 	ENTER_KEY_SET_HIGH;							//	restore to high level
        0B2A: 43 0C 02 OR    REG[12],2
(0080) 	DOWN_KEY_SET_HIGH;
        0B2D: 43 0C 08 OR    REG[12],8
(0081) 	#endif
(0082) 
(0083) #endif
(0084) 	
(0085) 	mark_bh(GPIO_BH);								// enable bh gpio task
        0B30: 50 01    MOV   A,1
        0B32: 08       PUSH  A
        0B33: 9F 5C    CALL  _mark_bh
        0B35: 38 FF    ADD   SP,255
(0086) 	do_softirq();									// botton half of interrupt, if needed, enable interrupt in 2nd-half
        0B37: 7C 19 16 LCALL _do_softirq
(0087) //led_hw_on;
(0088) }
        0B3A: 18       POP   A
        0B3B: 53 00    MOV   [NO_SHADOW],A
        0B3D: 18       POP   A
        0B3E: 53 01    MOV   [__rY],A
        0B40: 18       POP   A
        0B41: 53 02    MOV   [__rX],A
        0B43: 18       POP   A
        0B44: 53 03    MOV   [__r11],A
        0B46: 18       POP   A
        0B47: 53 04    MOV   [__r10],A
        0B49: 18       POP   A
        0B4A: 53 05    MOV   [__r9],A
        0B4C: 18       POP   A
        0B4D: 53 06    MOV   [__r8],A
        0B4F: 18       POP   A
        0B50: 53 07    MOV   [__r7],A
        0B52: 18       POP   A
        0B53: 53 08    MOV   [__r6],A
        0B55: 18       POP   A
        0B56: 53 09    MOV   [__r5],A
        0B58: 18       POP   A
        0B59: 53 0A    MOV   [__r4],A
        0B5B: 18       POP   A
        0B5C: 53 0B    MOV   [__r3],A
        0B5E: 18       POP   A
        0B5F: 53 0C    MOV   [__r2],A
        0B61: 18       POP   A
        0B62: 53 0D    MOV   [__r1],A
        0B64: 18       POP   A
        0B65: 53 0E    MOV   [__r0],A
        0B67: 18       POP   A
        0B68: 7E       RETI  
(0089) 
(0090) void gpio_softirq(void)
(0091) {
_gpio_softirq:
  i                    --> X+2
  i                    --> X+2
        0B69: 10       PUSH  X
        0B6A: 4F       MOV   X,SP
        0B6B: 38 03    ADD   SP,3
(0092) 	
(0093) #if (KB_MOD==1) 
(0094) 	switch (gpio_var.scan_key_event) {
        0B6D: 5F 0D 0F MOV   [__r1],[_gpio_var]
        0B70: 55 0E 00 MOV   [__r0],0
        0B73: 68 0E    ASR   [__r0]
        0B75: 6E 0D    RRC   [__r1]
        0B77: 68 0E    ASR   [__r0]
        0B79: 6E 0D    RRC   [__r1]
        0B7B: 68 0E    ASR   [__r0]
        0B7D: 6E 0D    RRC   [__r1]
        0B7F: 26 0D 03 AND   [__r1],3
        0B82: 26 0E 00 AND   [__r0],0
        0B85: 51 0D    MOV   A,[__r1]
        0B87: 54 01    MOV   [X+1],A
        0B89: 51 0E    MOV   A,[__r0]
        0B8B: 54 00    MOV   [X+0],A
        0B8D: 3D 00 00 CMP   [X+0],0
        0B90: B0 06    JNZ   0x0B97
        0B92: 3D 01 01 CMP   [X+1],1
        0B95: A0 0D    JZ    0x0BA3
        0B97: 3D 00 00 CMP   [X+0],0
        0B9A: B0 06    JNZ   0x0BA1
        0B9C: 3D 01 02 CMP   [X+1],2
        0B9F: A0 79    JZ    0x0C19
        0BA1: 80 E9    JMP   0x0C8B
(0095) //		case 0 : 
(0096) //			 if (gpio_var.key_deb_f==0) {
(0097) 					// setting deboucing timer
(0098) //				deboucing_timer.data.timer_function = (p_func) kb_deboudcing;//after solve the problem, put back into alarm()
(0099) //				if (malarm((p_func) kb_deboudcing, 10, &deboucing_timer)>=0)		// 10mSec is enough for push key deboucing
(0100) //					gpio_var.key_deb_f = 1; 
(0101) //			 }
(0102) //			break;
(0103) 	#if (ROTARY_KEY==1)
(0104) 		case 1 : 
(0105) 			// appl. level code here for DOWN key in DOWN case
(0106) 			 APP_DOWN_KEY_DOWN_CASE;
        0BA3: 50 02    MOV   A,2
        0BA5: 08       PUSH  A
        0BA6: 51 2D    MOV   A,[_ptr_events_vect]
        0BA8: 67       ASR   A
        0BA9: 67       ASR   A
        0BAA: 67       ASR   A
        0BAB: 67       ASR   A
        0BAC: 21 0F    AND   A,15
        0BAE: 08       PUSH  A
        0BAF: 51 2D    MOV   A,[_ptr_events_vect]
        0BB1: 21 0F    AND   A,15
        0BB3: 08       PUSH  A
        0BB4: 7C 09 B3 LCALL _pre_wr_cir254buf
        0BB7: 38 FD    ADD   SP,253
        0BB9: 54 02    MOV   [X+2],A
        0BBB: 39 FF    CMP   A,255
        0BBD: A0 54    JZ    0x0C12
        0BBF: 5F 0D 2D MOV   [__r1],[_ptr_events_vect]
        0BC2: 55 0E 00 MOV   [__r0],0
        0BC5: 26 0D 0F AND   [__r1],15
        0BC8: 26 0E 00 AND   [__r0],0
        0BCB: 06 0D 2E ADD   [__r1],46
        0BCE: 0E 0E 00 ADC   [__r0],0
        0BD1: 3E 0D    MVI   A,[__r1]
        0BD3: 7A 0D    DEC   [__r1]
        0BD5: 53 0C    MOV   [__r2],A
        0BD7: 26 0C F8 AND   [__r2],248
        0BDA: 2E 0C 02 OR    [__r2],2
        0BDD: 51 0C    MOV   A,[__r2]
        0BDF: 3F 0D    MVI   [__r1],A
        0BE1: 5F 0D 2D MOV   [__r1],[_ptr_events_vect]
        0BE4: 55 0E 00 MOV   [__r0],0
        0BE7: 26 0D 0F AND   [__r1],15
        0BEA: 26 0E 00 AND   [__r0],0
        0BED: 06 0D 2E ADD   [__r1],46
        0BF0: 0E 0E 00 ADC   [__r0],0
        0BF3: 3E 0D    MVI   A,[__r1]
        0BF5: 7A 0D    DEC   [__r1]
        0BF7: 53 0C    MOV   [__r2],A
        0BF9: 26 0C E7 AND   [__r2],231
        0BFC: 2E 0C 10 OR    [__r2],16
        0BFF: 51 0C    MOV   A,[__r2]
        0C01: 3F 0D    MVI   [__r1],A
        0C03: 51 2D    MOV   A,[_ptr_events_vect]
        0C05: 21 F0    AND   A,240
        0C07: 53 0E    MOV   [__r0],A
        0C09: 52 02    MOV   A,[X+2]
        0C0B: 21 0F    AND   A,15
        0C0D: 2C 0E    OR    [__r0],A
        0C0F: 5F 2D 0E MOV   [_ptr_events_vect],[__r0]
(0107) 			 gpio_var.scan_key_event = 0;					// clr the previous key-in
        0C12: 26 0F E7 AND   [_gpio_var],231
        0C15: 51 0F    MOV   A,[_gpio_var]
(0108) 			break;
        0C17: 80 73    JMP   0x0C8B
(0109) 		case 2 : 
(0110) 			// appl. level code here for UP key in DOWN case
(0111) 			 APP_UP_KEY_DOWN_CASE;
        0C19: 50 02    MOV   A,2
        0C1B: 08       PUSH  A
        0C1C: 51 2D    MOV   A,[_ptr_events_vect]
        0C1E: 67       ASR   A
        0C1F: 67       ASR   A
        0C20: 67       ASR   A
        0C21: 67       ASR   A
        0C22: 21 0F    AND   A,15
        0C24: 08       PUSH  A
        0C25: 51 2D    MOV   A,[_ptr_events_vect]
        0C27: 21 0F    AND   A,15
        0C29: 08       PUSH  A
        0C2A: 7C 09 B3 LCALL _pre_wr_cir254buf
        0C2D: 38 FD    ADD   SP,253
        0C2F: 54 02    MOV   [X+2],A
        0C31: 39 FF    CMP   A,255
        0C33: A0 54    JZ    0x0C88
        0C35: 5F 0D 2D MOV   [__r1],[_ptr_events_vect]
        0C38: 55 0E 00 MOV   [__r0],0
        0C3B: 26 0D 0F AND   [__r1],15
        0C3E: 26 0E 00 AND   [__r0],0
        0C41: 06 0D 2E ADD   [__r1],46
        0C44: 0E 0E 00 ADC   [__r0],0
        0C47: 3E 0D    MVI   A,[__r1]
        0C49: 7A 0D    DEC   [__r1]
        0C4B: 53 0C    MOV   [__r2],A
        0C4D: 26 0C F8 AND   [__r2],248
        0C50: 2E 0C 02 OR    [__r2],2
        0C53: 51 0C    MOV   A,[__r2]
        0C55: 3F 0D    MVI   [__r1],A
        0C57: 5F 0D 2D MOV   [__r1],[_ptr_events_vect]
        0C5A: 55 0E 00 MOV   [__r0],0
        0C5D: 26 0D 0F AND   [__r1],15
        0C60: 26 0E 00 AND   [__r0],0
        0C63: 06 0D 2E ADD   [__r1],46
        0C66: 0E 0E 00 ADC   [__r0],0
        0C69: 3E 0D    MVI   A,[__r1]
        0C6B: 7A 0D    DEC   [__r1]
        0C6D: 53 0C    MOV   [__r2],A
        0C6F: 26 0C E7 AND   [__r2],231
        0C72: 2E 0C 08 OR    [__r2],8
        0C75: 51 0C    MOV   A,[__r2]
        0C77: 3F 0D    MVI   [__r1],A
        0C79: 51 2D    MOV   A,[_ptr_events_vect]
        0C7B: 21 F0    AND   A,240
        0C7D: 53 0E    MOV   [__r0],A
        0C7F: 52 02    MOV   A,[X+2]
        0C81: 21 0F    AND   A,15
        0C83: 2C 0E    OR    [__r0],A
        0C85: 5F 2D 0E MOV   [_ptr_events_vect],[__r0]
(0112) 			 gpio_var.scan_key_event = 0;					// clr the previous key-in
        0C88: 26 0F E7 AND   [_gpio_var],231
(0113) 			break;
(0114) 	#endif
(0115) 	}
(0116) #endif
(0117) 
(0118) }
        0C8B: 38 FD    ADD   SP,253
        0C8D: 20       POP   X
        0C8E: 7F       RET   
FILE: .\main.c
(0001) /*
(0002)  *	linlike8/arch/cypress_psoc/boot/boot.c
(0003)  *
(0004)  *	13-04-2004	yan	create this following linux
(0005)  *
(0006)  *	hardware driver in cpu dependent
(0007)  */
(0008) 
(0009) void main()
(0010) {
(0011) 		// cpu hardware init
(0012) 		// goto init kernel
(0013) 	asm("ljmp _start_kernel");//start_kernel();					
_main:
        0C8F: 7D 0C 93 LJMP  _start_kernel
(0014) 	//for (;;);									// main should never return here, but just in case, we know what happens.
(0015) }
        0C92: 7F       RET   
FILE: .\maink.c
(0001) /*
(0002)  *	init/main.c
(0003)  *
(0004)  *	09-04-2004	yan	create this following linux
(0005)  *
(0006)  */
(0007) 
(0008) #include "app.h"
(0009) #include "sched.h"
(0010) #include "system.h"
(0011) 
(0012) void start_kernel(void);
(0013) extern void setup_arch(void);
(0014) extern void sched_init(void);
(0015) extern void softirq_init(void);
(0016) #if (TIMER_MOD==1)
(0017) extern void time_init(void);
(0018) #endif
(0019) #if (CONTEXT_SW==1)
(0020) void kernel_thread(void);
(0021) #endif
(0022) 
(0023) void start_kernel(void)
(0024) {
(0025) 	setup_arch();
_start_kernel:
        0C93: 7C 19 0E LCALL _setup_arch
(0026) 	sched_init();									// <-+ this subr. must place as same layer of process0()
        0C96: 7C 14 9F LCALL _sched_init
(0027) 	//fork_init();									//   |
(0028) 	softirq_init();									//   |
        0C99: 7C 19 15 LCALL _softirq_init
(0029) 	#if (TIMER_MOD==1)
(0030) 	time_init();									//   |		// must place after sched_int(), since after timer init, sched can be start to work
        0C9C: 7C 1B DC LCALL _time_init
(0031) 	#endif
(0032) #if (CONTEXT_SW==1)
(0033) 	kernel_thread();								//   |
        0C9F: 90 06    CALL  _kernel_thread
(0034) #endif
(0035) 	sti();										//   |		// start interrupt, kernel start ??? diff. to linux
        0CA1: 71 01    OR    F,1
(0036) 	idle_process();//for (;;);//cpu_idle();						   <-+ this subr. must place as same layer of sched_init()
        0CA3: 7C 1B AF LCALL _mwlike8_server
(0037) }
        0CA6: 7F       RET   
(0038) 
(0039) 		// should place at arch/XXX/process.c
(0040) #if (CONTEXT_SW==1)
(0041) void kernel_thread(void)
(0042) {
(0043) 	do_fork(1, PROCESS0_SYS_APP_STACK_SIZE, (p_func) &init_process);				// create init process
_kernel_thread:
        0CA7: 50 08    MOV   A,8
        0CA9: 08       PUSH  A
        0CAA: 50 D9    MOV   A,217
        0CAC: 08       PUSH  A
        0CAD: 50 53    MOV   A,83
        0CAF: 08       PUSH  A
        0CB0: 50 01    MOV   A,1
        0CB2: 08       PUSH  A
        0CB3: 7C 09 F9 LCALL _do_fork
        0CB6: 38 FC    ADD   SP,252
(0044) }
        0CB8: 7F       RET   
FILE: .\mw_pro1.c
(0001) #include "app.h"
(0002) 
(0003) #ifdef I386_LINUX
(0004) #include <stdio.h>
(0005) #include <stdlib.h>
(0006) #define MWINCLUDECOLORS
(0007) #include "microwin/nano-X.h"
(0008) #endif
(0009) #ifdef CYPRESS_PSOC
(0010) #include "nano-X.h"
(0011) #include "sched.h"
(0012) #include "timer.h"
(0013) #include "printf.h"
(0014) #endif
(0015) 
(0016) #ifdef I386_LINUX
(0017) GR_WINDOW_ID  wid;
(0018) GR_GC_ID      gc;
(0019) GR_BITMAP eyeclose_bits[] = {
(0020) 	0xfffe, 0x00ff, 0xfe00, 0xfff0, 0x001f, 0xfe00, 0xffc0, 0x0007, 
(0021) 	0xfe00, 0xff01, 0xff01, 0xfe00, 0xfe0f, 0xffe0, 0xfe00, 0xfc3f, 
(0022) 	0xfff8, 0x7e00, 0xf87f, 0xfffc, 0x3e00, 0xf0ff, 0xfffe, 0x1e00, 
(0023) 	0xe1ff, 0xffff, 0x0e00, 0xe3ff, 0xffff, 0x8e00, 0xc7ff, 0xffff, 
(0024) 	0xc600, 0xc7ff, 0xffff, 0xc600, 0x8fff, 0xffff, 0xe200, 0x8fff, 
(0025) 	0xffff, 0xe200, 0x8fff, 0xffff, 0xe200, 0x1fff, 0xffff, 0xf000, 
(0026) 	0x1fff, 0xffff, 0xf000, 0x1fff, 0xffff, 0xf000, 0x1fff, 0xffff, 
(0027) 	0xf000, 0x1fff, 0xffff, 0xf000, 0x1fff, 0xffff, 0xf000, 0x1fff, 
(0028) 	0xffff, 0xf000, 0x01ff, 0xfffe, 0x0000, 0x0001, 0xff00, 0x0000, 
(0029) 	0x8000, 0x0000, 0x0200, 0x8800, 0x0000, 0x2200, 0x8ff0, 0x001f, 
(0030) 	0xe200, 0xc7ff, 0xffff, 0xc600, 0xc7ff, 0xffff, 0xc600, 0xe3ff, 
(0031) 	0xffff, 0x8e00, 0xe1ff, 0xffff, 0x0e00, 0xf0ff, 0xfffe, 0x1e00, 
(0032) 	0xf87f, 0xfffc, 0x3e00, 0xfc3f, 0xfff8, 0x7e00, 0xfe0f, 0xffe0, 
(0033) 	0xfe00, 0xff01, 0xff01, 0xfe00, 0xffc0, 0x0007, 0xfe00, 0xfff0, 
(0034) 	0x001f, 0xfe00, 0xfffe, 0x00ff, 0xfe00, };
(0035) #endif
(0036) #ifdef CYPRESS_PSOC
(0037) const unsigned char AmonicsLogo[]=
(0038) { 
(0039) 
(0040) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Page:1
(0041) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0042) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xF0, 
(0043) 	0xF0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0044) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0045) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0046) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0047) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0048) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0049) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0050) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0051) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0052) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0053) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0054) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0055) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0056) 	
(0057) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Page:2
(0058) 	0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 
(0059) 	0x80, 0x80, 0x80, 0xC0, 0xF0, 0xFE, 0xFF, 0xFF, 
(0060) 	0xFF, 0xFF, 0xFF, 0xF8, 0xC0, 0x00, 0x00, 0x00, 
(0061) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0062) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0063) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0064) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0065) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0066) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0067) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0068) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0069) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0070) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0071) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0072) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0073) 	
(0074) 	0x00, 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0x78, 0x3C, // Page:3
(0075) 	0x1E, 0x0F, 0x07, 0x07, 0x03, 0x03, 0x03, 0x03, 
(0076) 	0xC3, 0xFB, 0xFF, 0x7F, 0x0F, 0x3F, 0xFF, 0xFF, 
(0077) 	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0xC0, 
(0078) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0079) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0080) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0081) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0082) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0083) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0084) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0085) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0086) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0087) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0088) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0089) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0090) 	
(0091) 	0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, // Page:4
(0092) 	0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xF8, 0xFE, 
(0093) 	0x7F, 0x0F, 0x01, 0x00, 0x00, 0x00, 0x01, 0x0F, 
(0094) 	0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
(0095) 	0xFF, 0xF8, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0096) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 
(0097) 	0x80, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 
(0098) 	0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 
(0099) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
(0100) 	0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0101) 	0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 
(0102) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x3E, 
(0103) 	0x7F, 0x7F, 0x7F, 0x7F, 0x3E, 0x1C, 0x00, 0x00, 
(0104) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0105) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0106) 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0107) 	
(0108) 	0x00, 0x00, 0x07, 0x1F, 0x3F, 0xFC, 0xF0, 0xC0, // Page:5
(0109) 	0x80, 0x80, 0xC0, 0xF8, 0xFE, 0x7F, 0x0F, 0x0F, 
(0110) 	0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x8E, 
(0111) 	0xCE, 0xEF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 
(0112) 	0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0xC0, 0x00, 0x00, 
(0113) 	0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 
(0114) 	0xFF, 0xFF, 0x0E, 0x07, 0x07, 0xFF, 0xFF, 0xFF, 
(0115) 	0xFE, 0xFC, 0x06, 0x07, 0x0F, 0xFF, 0xFF, 0xFF, 
(0116) 	0xFE, 0x00, 0xF0, 0xFC, 0xFE, 0xFF, 0xFF, 0x03, 
(0117) 	0x03, 0x03, 0xFF, 0xFF, 0xFE, 0xFC, 0xE0, 0x01, 
(0118) 	0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x07, 
(0119) 	0xFF, 0xFF, 0xFF, 0xFE, 0xFC, 0x00, 0x00, 0x03, 
(0120) 	0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xF0, 0xFC, 
(0121) 	0xFE, 0xFF, 0x8F, 0x03, 0x0F, 0x3F, 0x3F, 0x3E, 
(0122) 	0x3C, 0x00, 0x7C, 0xFF, 0xFF, 0xFB, 0xF3, 0xE3, 
(0123) 	0xC7, 0xBF, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0124) 	
(0125) 	0x00, 0x00, 0x00, 0x00, 0xC0, 0xC0, 0xE1, 0xF1, // Page:6
(0126) 	0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xEE, 0xCE, 0xCE, 
(0127) 	0xCE, 0x0E, 0x0E, 0x0E, 0x0E, 0x07, 0x07, 0x03, 
(0128) 	0x03, 0xC1, 0xC0, 0xC0, 0xC1, 0xFF, 0xFF, 0xFF, 
(0129) 	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 
(0130) 	0xE0, 0xC0, 0xC0, 0x00, 0xC0, 0xFF, 0xFF, 0xFF, 
(0131) 	0xFF, 0xFF, 0xC0, 0x80, 0xC0, 0xFF, 0xFF, 0xFF, 
(0132) 	0xFF, 0xFF, 0xC0, 0x80, 0xE0, 0xFF, 0xFF, 0xFF, 
(0133) 	0xFF, 0xC0, 0x8F, 0x3F, 0x7F, 0xFF, 0xFF, 0xC0, 
(0134) 	0xC0, 0xC0, 0xFF, 0xFF, 0x7F, 0x3F, 0x0F, 0x80, 
(0135) 	0xC0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0xC0, 
(0136) 	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x80, 
(0137) 	0xC0, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x8F, 0x3F, 
(0138) 	0x7F, 0xFF, 0xFF, 0xF8, 0xE0, 0xE0, 0xE0, 0x70, 
(0139) 	0x38, 0x00, 0xFC, 0xF9, 0xE3, 0xC3, 0xC7, 0xDF, 
(0140) 	0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0141) 	
(0142) 	0x00, 0x00, 0x00, 0x30, 0x48, 0x48, 0x98, 0x20, // Page:7
(0143) 	0xE0, 0x20, 0x20, 0xC0, 0x00, 0xC0, 0xA0, 0xC0, 
(0144) 	0x00, 0xC0, 0x20, 0x20, 0x00, 0x20, 0xE8, 0x00, 
(0145) 	0x00, 0xA0, 0xA0, 0xC0, 0x00, 0xF8, 0x00, 0xE8, 
(0146) 	0x00, 0xC0, 0xA0, 0x20, 0x00, 0xF0, 0x20, 0x00, 
(0147) 	0x00, 0x00, 0x00, 0x20, 0xE8, 0x00, 0xE0, 0x40, 
(0148) 	0x20, 0xE0, 0x00, 0x00, 0x00, 0xF0, 0x08, 0x08, 
(0149) 	0x08, 0xF0, 0x20, 0xE0, 0x20, 0x20, 0xC0, 0x20, 
(0150) 	0xF0, 0x20, 0x00, 0xE8, 0x00, 0xC0, 0x20, 0x21, 
(0151) 	0x01, 0xA1, 0x60, 0xC0, 0x00, 0x08, 0xF8, 0x00, 
(0152) 	0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x98, 0xE0, 
(0153) 	0x00, 0x00, 0x00, 0xE0, 0x20, 0xE0, 0x20, 0xC0, 
(0154) 	0x20, 0xE0, 0x20, 0x20, 0xC0, 0x00, 0xF8, 0x00, 
(0155) 	0xE8, 0x00, 0x20, 0xF1, 0x29, 0x08, 0x20, 0xE8, 
(0156) 	0x00, 0xC0, 0xA1, 0xC0, 0x00, 0xE1, 0x21, 0x21, 
(0157) 	0xC0, 0xA0, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
(0158) 	
(0159) 	0x00, 0x00, 0x00, 0x03, 0x02, 0x02, 0x01, 0x08, // Page:8
(0160) 	0x0F, 0x0A, 0x02, 0x01, 0x00, 0x01, 0x02, 0x02, 
(0161) 	0x00, 0x01, 0x02, 0x02, 0x00, 0x02, 0x03, 0x02, 
(0162) 	0x00, 0x03, 0x02, 0x03, 0x00, 0x03, 0x00, 0x03, 
(0163) 	0x00, 0x02, 0x02, 0x01, 0x00, 0x03, 0x02, 0x02, 
(0164) 	0x00, 0x00, 0x00, 0x02, 0x03, 0x02, 0x03, 0x02, 
(0165) 	0x00, 0x03, 0x02, 0x00, 0x00, 0x01, 0x02, 0x02, 
(0166) 	0x02, 0x01, 0x08, 0x0F, 0x0A, 0x02, 0x01, 0x00, 
(0167) 	0x03, 0x02, 0x02, 0x03, 0x02, 0x01, 0x02, 0x02, 
(0168) 	0x00, 0x03, 0x02, 0x03, 0x00, 0x02, 0x03, 0x02, 
(0169) 	0x00, 0x00, 0x00, 0x02, 0x03, 0x00, 0x00, 0x02, 
(0170) 	0x03, 0x02, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
(0171) 	0x08, 0x0F, 0x0A, 0x02, 0x01, 0x00, 0x03, 0x00, 
(0172) 	0x03, 0x00, 0x02, 0x03, 0x02, 0x00, 0x02, 0x03, 
(0173) 	0x02, 0x01, 0x02, 0x02, 0x00, 0x03, 0x00, 0x00, 
(0174) 	0x02, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00
(0175) 
(0176) };
(0177) extern unsigned char ClearPaper[];
(0178) #endif
(0179) 
(0180) void mwlike8_process1(void)
(0181) {
_mwlike8_process1:
  vec                  --> X+4
  a                    --> X+2
  timeout_task         --> X+1
  event                --> X+0
        0CB9: 10       PUSH  X
        0CBA: 4F       MOV   X,SP
        0CBB: 38 16    ADD   SP,22
(0182) 	
(0183) 	GR_EVENT	event;		// current event
(0184) 	#define	TIME_OUT_INIT		0
(0185) 	#define	TIME_OUT_INIT1		TIME_OUT_INIT + 1
(0186) 	#define	TIME_OUT_INIT2		TIME_OUT_INIT1 + 1
(0187) 	#define	TIME_OUT_INIT3		TIME_OUT_INIT2 + 1
(0188) 	#define	TIME_OUT_STATIC_SCR	TIME_OUT_INIT3 + 1
(0189) 	#define	TIME_OUT_		TIME_OUT_STATIC_SCR + 1
(0190) 	unsigned char timeout_task = TIME_OUT_INIT;
        0CBD: 56 01 00 MOV   [X+1],0
(0191) 	
(0192) 						 int a = 0;
        0CC0: 56 03 00 MOV   [X+3],0
        0CC3: 56 02 00 MOV   [X+2],0
(0193) 						 char vec[10];
(0194) 	
(0195) #ifdef I386_LINUX
(0196)     if (GrOpen() < 0)
(0197)     {
(0198)         fprintf (stderr, "GrOpen failed");
(0199)         exit (1);
(0200)     }
(0201) 
(0202)     wid = GrNewWindowEx (GR_WM_PROPS_APPFRAME |
(0203)                          GR_WM_PROPS_CAPTION  |
(0204)                          GR_WM_PROPS_CLOSEBOX,
(0205)                          "H W H",
(0206)                          GR_ROOT_WINDOW_ID, 
(0207)                          1, 1, 100, 40, WHITE);
(0208) 
(0209)     GrSelectEvents (wid, GR_EVENT_MASK_EXPOSURE | 
(0210)                          GR_EVENT_MASK_CLOSE_REQ);
(0211) 			 
(0212)     gc = GrNewGC();
(0213)     GrSetGCUseBackground(gc, GR_FALSE);
(0214)     GrSetGCForeground(gc, RED);
(0215) 
(0216)     //GrMapWindow (wid);
(0217) 	GrBitmap(wid, gc, 0, 0, 39, 39, eyeclose_bits);
(0218) #endif
(0219) #ifdef CYPRESS_PSOC
(0220) 	msleep(100);									// let mwlinke8 server has enough time to init.
        0CC6: 50 0A    MOV   A,10
        0CC8: 08       PUSH  A
        0CC9: 7C 15 38 LCALL _schedule_timeout
(0221) //	GrMapWindow();
(0222) 	GrBitmap(AmonicsLogo);
        0CCC: 50 01    MOV   A,1
        0CCE: 08       PUSH  A
        0CCF: 50 00    MOV   A,0
        0CD1: 08       PUSH  A
        0CD2: 7C 1F D8 LCALL _GrBitmapDrv
        0CD5: 38 FD    ADD   SP,253
(0223) 	buz_one_shot();
        0CD7: 2E 2C 04 OR    [_io_bit_ctrl],4
        0CDA: 51 2C    MOV   A,[_io_bit_ctrl]
        0CDC: 82 B5    JMP   0x0F92
(0224) #endif
(0225)     
(0226) 	while (1) {
(0227) 		GrGetNextEventTimeout(&event, 300);					// check events
        0CDE: 50 01    MOV   A,1
        0CE0: 08       PUSH  A
        0CE1: 50 2C    MOV   A,44
        0CE3: 08       PUSH  A
        0CE4: 51 0E    MOV   A,[__r0]
        0CE6: 08       PUSH  A
        0CE7: 10       PUSH  X
        0CE8: 7C 19 4D LCALL _GrGetNextEventTimeout
        0CEB: 38 FC    ADD   SP,252
(0228) 		switch (event.type) {
        0CED: 52 00    MOV   A,[X+0]
        0CEF: 53 0D    MOV   [__r1],A
        0CF1: 55 0E 00 MOV   [__r0],0
        0CF4: 26 0D 07 AND   [__r1],7
        0CF7: 26 0E 00 AND   [__r0],0
        0CFA: 51 0D    MOV   A,[__r1]
        0CFC: 54 0F    MOV   [X+15],A
        0CFE: 51 0E    MOV   A,[__r0]
        0D00: 54 0E    MOV   [X+14],A
        0D02: 3D 0E 00 CMP   [X+14],0
        0D05: B0 06    JNZ   0x0D0C
        0D07: 3D 0F 01 CMP   [X+15],1
        0D0A: A2 87    JZ    0x0F92
        0D0C: 3D 0E 00 CMP   [X+14],0
        0D0F: B0 06    JNZ   0x0D16
        0D11: 3D 0F 02 CMP   [X+15],2
        0D14: A1 25    JZ    0x0E3A
        0D16: 3D 0E 00 CMP   [X+14],0
        0D19: B0 06    JNZ   0x0D20
        0D1B: 3D 0F 03 CMP   [X+15],3
        0D1E: A1 C8    JZ    0x0EE7
        0D20: 3D 0E 00 CMP   [X+14],0
        0D23: B0 06    JNZ   0x0D2A
        0D25: 3D 0F 04 CMP   [X+15],4
        0D28: A0 03    JZ    0x0D2C
        0D2A: 82 67    JMP   0x0F92
(0229) 			case GR_EVENT_TYPE_EXPOSURE:					// display init. screen on startup
(0230) 				break;
(0231) 	
(0232) #ifdef I386_LINUX
(0233) 			case GR_EVENT_TYPE_CLOSE_REQ:
(0234) 				GrClose();
(0235) 				exit(0);
(0236) #endif
(0237) 	
(0238) 			case GR_EVENT_TYPE_TIMEOUT:
(0239) 			
(0240) 		// display each regular time
(0241) 				 switch (timeout_task) {
        0D2C: 52 01    MOV   A,[X+1]
        0D2E: 54 11    MOV   [X+17],A
        0D30: 56 10 00 MOV   [X+16],0
        0D33: 3D 10 00 CMP   [X+16],0
        0D36: B0 06    JNZ   0x0D3D
        0D38: 3D 11 00 CMP   [X+17],0
        0D3B: A0 35    JZ    0x0D71
        0D3D: 3D 10 00 CMP   [X+16],0
        0D40: B0 06    JNZ   0x0D47
        0D42: 3D 11 01 CMP   [X+17],1
        0D45: A0 30    JZ    0x0D76
        0D47: 3D 10 00 CMP   [X+16],0
        0D4A: B0 06    JNZ   0x0D51
        0D4C: 3D 11 02 CMP   [X+17],2
        0D4F: A0 2B    JZ    0x0D7B
        0D51: 3D 10 00 CMP   [X+16],0
        0D54: B0 06    JNZ   0x0D5B
        0D56: 3D 11 03 CMP   [X+17],3
        0D59: A0 26    JZ    0x0D80
        0D5B: 3D 10 00 CMP   [X+16],0
        0D5E: B0 06    JNZ   0x0D65
        0D60: 3D 11 04 CMP   [X+17],4
        0D63: A0 2C    JZ    0x0D90
        0D65: 3D 10 00 CMP   [X+16],0
        0D68: B0 06    JNZ   0x0D6F
        0D6A: 3D 11 05 CMP   [X+17],5
        0D6D: A0 8D    JZ    0x0DFB
        0D6F: 82 22    JMP   0x0F92
(0242) 					case TIME_OUT_INIT :				//	for around 1 sec for logo
(0243) 						 timeout_task = TIME_OUT_INIT1;
        0D71: 56 01 01 MOV   [X+1],1
(0244) 						break;
        0D74: 82 1D    JMP   0x0F92
(0245) 					case TIME_OUT_INIT1 :
(0246) 						 timeout_task = TIME_OUT_INIT2;
        0D76: 56 01 02 MOV   [X+1],2
(0247) 						break;
        0D79: 82 18    JMP   0x0F92
(0248) 					case TIME_OUT_INIT2 :
(0249) 						 timeout_task = TIME_OUT_INIT3;
        0D7B: 56 01 03 MOV   [X+1],3
(0250) 						break;
        0D7E: 82 13    JMP   0x0F92
(0251) 					case TIME_OUT_INIT3 :				
(0252) #ifdef CYPRESS_PSOC
(0253) 						 GrBitmap(ClearPaper);
        0D80: 50 07    MOV   A,7
        0D82: 08       PUSH  A
        0D83: 50 B7    MOV   A,183
        0D85: 08       PUSH  A
        0D86: 7C 1F D8 LCALL _GrBitmapDrv
        0D89: 38 FE    ADD   SP,254
(0254) #endif
(0255) 						 timeout_task = TIME_OUT_STATIC_SCR;
        0D8B: 56 01 04 MOV   [X+1],4
(0256) 						break;
        0D8E: 82 03    JMP   0x0F92
(0257) 					case TIME_OUT_STATIC_SCR :
(0258) 						 GrText_const(0,0,"i/p Pwr:", 8, 0);GrText_const(14,0,"mW", 2, 0);
        0D90: 50 00    MOV   A,0
        0D92: 08       PUSH  A
        0D93: 50 08    MOV   A,8
        0D95: 08       PUSH  A
        0D96: 50 00    MOV   A,0
        0D98: 08       PUSH  A
        0D99: 08       PUSH  A
        0D9A: 50 05    MOV   A,5
        0D9C: 08       PUSH  A
        0D9D: 50 2E    MOV   A,46
        0D9F: 08       PUSH  A
        0DA0: 50 00    MOV   A,0
        0DA2: 08       PUSH  A
        0DA3: 08       PUSH  A
        0DA4: 7C 1B 46 LCALL _GrText
        0DA7: 50 00    MOV   A,0
        0DA9: 08       PUSH  A
        0DAA: 50 02    MOV   A,2
        0DAC: 08       PUSH  A
        0DAD: 50 00    MOV   A,0
        0DAF: 08       PUSH  A
        0DB0: 08       PUSH  A
        0DB1: 50 05    MOV   A,5
        0DB3: 08       PUSH  A
        0DB4: 50 2B    MOV   A,43
        0DB6: 08       PUSH  A
        0DB7: 50 00    MOV   A,0
        0DB9: 08       PUSH  A
        0DBA: 50 0E    MOV   A,14
        0DBC: 08       PUSH  A
        0DBD: 7C 1B 46 LCALL _GrText
        0DC0: 38 F0    ADD   SP,240
(0259) 						 GrText_const(0,1,"o/p Pwr:", 8, 0);GrText_const(14,1,"mW", 2, 0);
        0DC2: 50 00    MOV   A,0
        0DC4: 08       PUSH  A
        0DC5: 50 08    MOV   A,8
        0DC7: 08       PUSH  A
        0DC8: 50 00    MOV   A,0
        0DCA: 08       PUSH  A
        0DCB: 08       PUSH  A
        0DCC: 50 05    MOV   A,5
        0DCE: 08       PUSH  A
        0DCF: 50 22    MOV   A,34
        0DD1: 08       PUSH  A
        0DD2: 50 01    MOV   A,1
        0DD4: 08       PUSH  A
        0DD5: 50 00    MOV   A,0
        0DD7: 08       PUSH  A
        0DD8: 7C 1B 46 LCALL _GrText
        0DDB: 50 00    MOV   A,0
        0DDD: 08       PUSH  A
        0DDE: 50 02    MOV   A,2
        0DE0: 08       PUSH  A
        0DE1: 50 00    MOV   A,0
        0DE3: 08       PUSH  A
        0DE4: 08       PUSH  A
        0DE5: 50 05    MOV   A,5
        0DE7: 08       PUSH  A
        0DE8: 50 2B    MOV   A,43
        0DEA: 08       PUSH  A
        0DEB: 50 01    MOV   A,1
        0DED: 08       PUSH  A
        0DEE: 50 0E    MOV   A,14
        0DF0: 08       PUSH  A
        0DF1: 7C 1B 46 LCALL _GrText
        0DF4: 38 F0    ADD   SP,240
(0260) 						 timeout_task = TIME_OUT_;
        0DF6: 56 01 05 MOV   [X+1],5
(0261) 						break;
        0DF9: 81 98    JMP   0x0F92
(0262) 					case TIME_OUT_ :
(0263) #ifdef CYPRESS_PSOC
(0264) 						// bug in overflow, a = 32767 only
(0265) 						 print_integer(vec, "05", a);
        0DFB: 52 02    MOV   A,[X+2]
        0DFD: 08       PUSH  A
        0DFE: 52 03    MOV   A,[X+3]
        0E00: 08       PUSH  A
        0E01: 50 05    MOV   A,5
        0E03: 08       PUSH  A
        0E04: 50 1F    MOV   A,31
        0E06: 08       PUSH  A
        0E07: 5A 0D    MOV   [__r1],X
        0E09: 06 0D 04 ADD   [__r1],4
        0E0C: 51 0E    MOV   A,[__r0]
        0E0E: 08       PUSH  A
        0E0F: 51 0D    MOV   A,[__r1]
        0E11: 08       PUSH  A
        0E12: 7C 14 77 LCALL _print_integer
(0266) 						 GrText_buf(3,3,vec, 5, 0);
        0E15: 50 00    MOV   A,0
        0E17: 08       PUSH  A
        0E18: 50 05    MOV   A,5
        0E1A: 08       PUSH  A
        0E1B: 5A 0D    MOV   [__r1],X
        0E1D: 06 0D 04 ADD   [__r1],4
        0E20: 51 0E    MOV   A,[__r0]
        0E22: 08       PUSH  A
        0E23: 51 0D    MOV   A,[__r1]
        0E25: 08       PUSH  A
        0E26: 50 00    MOV   A,0
        0E28: 08       PUSH  A
        0E29: 08       PUSH  A
        0E2A: 50 03    MOV   A,3
        0E2C: 08       PUSH  A
        0E2D: 08       PUSH  A
        0E2E: 7C 1B 46 LCALL _GrText
        0E31: 38 F2    ADD   SP,242
(0267) 						 a++;
        0E33: 77 03    INC   [X+3]
        0E35: 0F 02 00 ADC   [X+2],0
(0268) #endif
(0269) #ifdef I386_LINUX
(0270) 						 GrText (wid, gc, 50, 50,
(0271) 							"H W C#2",  -1, GR_TFASCII);
(0272) #endif
(0273) 						break;
(0274) 				 }
(0275) 				 
(0276) 				break;
        0E38: 81 59    JMP   0x0F92
(0277) 			case GR_EVENT_TYPE_KEY_DOWN :
(0278) 				 GrText_const(1,5,"DOWN", 4, 0);
        0E3A: 50 00    MOV   A,0
        0E3C: 08       PUSH  A
        0E3D: 50 04    MOV   A,4
        0E3F: 08       PUSH  A
        0E40: 50 00    MOV   A,0
        0E42: 08       PUSH  A
        0E43: 08       PUSH  A
        0E44: 50 05    MOV   A,5
        0E46: 08       PUSH  A
        0E47: 50 1A    MOV   A,26
        0E49: 08       PUSH  A
        0E4A: 50 05    MOV   A,5
        0E4C: 08       PUSH  A
        0E4D: 50 01    MOV   A,1
        0E4F: 08       PUSH  A
        0E50: 7C 1B 46 LCALL _GrText
        0E53: 38 F8    ADD   SP,248
(0279) 				 switch (event.keystroke.ch) {
        0E55: 52 00    MOV   A,[X+0]
        0E57: 53 0D    MOV   [__r1],A
        0E59: 55 0E 00 MOV   [__r0],0
        0E5C: 68 0E    ASR   [__r0]
        0E5E: 6E 0D    RRC   [__r1]
        0E60: 68 0E    ASR   [__r0]
        0E62: 6E 0D    RRC   [__r1]
        0E64: 68 0E    ASR   [__r0]
        0E66: 6E 0D    RRC   [__r1]
        0E68: 26 0D 03 AND   [__r1],3
        0E6B: 26 0E 00 AND   [__r0],0
        0E6E: 51 0D    MOV   A,[__r1]
        0E70: 54 13    MOV   [X+19],A
        0E72: 51 0E    MOV   A,[__r0]
        0E74: 54 12    MOV   [X+18],A
        0E76: 3D 12 00 CMP   [X+18],0
        0E79: B0 06    JNZ   0x0E80
        0E7B: 3D 13 00 CMP   [X+19],0
        0E7E: A0 17    JZ    0x0E96
        0E80: 3D 12 00 CMP   [X+18],0
        0E83: B0 06    JNZ   0x0E8A
        0E85: 3D 13 01 CMP   [X+19],1
        0E88: A0 28    JZ    0x0EB1
        0E8A: 3D 12 00 CMP   [X+18],0
        0E8D: B0 06    JNZ   0x0E94
        0E8F: 3D 13 02 CMP   [X+19],2
        0E92: A0 39    JZ    0x0ECC
        0E94: 80 FD    JMP   0x0F92
(0280) 					 case GR_KEY_ENTER : 
(0281) 						 GrText_const(5,5," ENTER", 6, 0);
        0E96: 50 00    MOV   A,0
        0E98: 08       PUSH  A
        0E99: 50 06    MOV   A,6
        0E9B: 08       PUSH  A
        0E9C: 50 00    MOV   A,0
        0E9E: 08       PUSH  A
        0E9F: 08       PUSH  A
        0EA0: 50 05    MOV   A,5
        0EA2: 08       PUSH  A
        0EA3: 50 13    MOV   A,19
        0EA5: 08       PUSH  A
        0EA6: 50 05    MOV   A,5
        0EA8: 08       PUSH  A
        0EA9: 08       PUSH  A
        0EAA: 7C 1B 46 LCALL _GrText
        0EAD: 38 F8    ADD   SP,248
(0282) 						break;
        0EAF: 80 E2    JMP   0x0F92
(0283) 					 case GR_SPECIAL_KEY_ARROW_UP : 
(0284) 						 GrText_const(5,5," UP   ", 6, 0);
        0EB1: 50 00    MOV   A,0
        0EB3: 08       PUSH  A
        0EB4: 50 06    MOV   A,6
        0EB6: 08       PUSH  A
        0EB7: 50 00    MOV   A,0
        0EB9: 08       PUSH  A
        0EBA: 08       PUSH  A
        0EBB: 50 05    MOV   A,5
        0EBD: 08       PUSH  A
        0EBE: 50 0C    MOV   A,12
        0EC0: 08       PUSH  A
        0EC1: 50 05    MOV   A,5
        0EC3: 08       PUSH  A
        0EC4: 08       PUSH  A
        0EC5: 7C 1B 46 LCALL _GrText
        0EC8: 38 F8    ADD   SP,248
(0285) 						break;
        0ECA: 80 C7    JMP   0x0F92
(0286) 					 case GR_SPECIAL_KEY_ARROW_DOWN : 
(0287) 						 GrText_const(5,5," DOWN ", 6, 0);
        0ECC: 50 00    MOV   A,0
        0ECE: 08       PUSH  A
        0ECF: 50 06    MOV   A,6
        0ED1: 08       PUSH  A
        0ED2: 50 00    MOV   A,0
        0ED4: 08       PUSH  A
        0ED5: 08       PUSH  A
        0ED6: 50 05    MOV   A,5
        0ED8: 08       PUSH  A
        0ED9: 50 05    MOV   A,5
        0EDB: 08       PUSH  A
        0EDC: 50 05    MOV   A,5
        0EDE: 08       PUSH  A
        0EDF: 08       PUSH  A
        0EE0: 7C 1B 46 LCALL _GrText
        0EE3: 38 F8    ADD   SP,248
(0288) 						break;
(0289) 				 }
(0290) 				break;
        0EE5: 80 AC    JMP   0x0F92
(0291) 			case GR_EVENT_TYPE_KEY_UP :
(0292) 				 GrText_const(1,5,"UP  ", 4, 0);
        0EE7: 50 00    MOV   A,0
        0EE9: 08       PUSH  A
        0EEA: 50 04    MOV   A,4
        0EEC: 08       PUSH  A
        0EED: 50 00    MOV   A,0
        0EEF: 08       PUSH  A
        0EF0: 08       PUSH  A
        0EF1: 50 05    MOV   A,5
        0EF3: 08       PUSH  A
        0EF4: 50 00    MOV   A,0
        0EF6: 08       PUSH  A
        0EF7: 50 05    MOV   A,5
        0EF9: 08       PUSH  A
        0EFA: 50 01    MOV   A,1
        0EFC: 08       PUSH  A
        0EFD: 7C 1B 46 LCALL _GrText
        0F00: 38 F8    ADD   SP,248
(0293) 				 switch (event.keystroke.ch) {
        0F02: 52 00    MOV   A,[X+0]
        0F04: 53 0D    MOV   [__r1],A
        0F06: 55 0E 00 MOV   [__r0],0
        0F09: 68 0E    ASR   [__r0]
        0F0B: 6E 0D    RRC   [__r1]
        0F0D: 68 0E    ASR   [__r0]
        0F0F: 6E 0D    RRC   [__r1]
        0F11: 68 0E    ASR   [__r0]
        0F13: 6E 0D    RRC   [__r1]
        0F15: 26 0D 03 AND   [__r1],3
        0F18: 26 0E 00 AND   [__r0],0
        0F1B: 51 0D    MOV   A,[__r1]
        0F1D: 54 15    MOV   [X+21],A
        0F1F: 51 0E    MOV   A,[__r0]
        0F21: 54 14    MOV   [X+20],A
        0F23: 3D 14 00 CMP   [X+20],0
        0F26: B0 06    JNZ   0x0F2D
        0F28: 3D 15 00 CMP   [X+21],0
        0F2B: A0 17    JZ    0x0F43
        0F2D: 3D 14 00 CMP   [X+20],0
        0F30: B0 06    JNZ   0x0F37
        0F32: 3D 15 01 CMP   [X+21],1
        0F35: A0 28    JZ    0x0F5E
        0F37: 3D 14 00 CMP   [X+20],0
        0F3A: B0 06    JNZ   0x0F41
        0F3C: 3D 15 02 CMP   [X+21],2
        0F3F: A0 39    JZ    0x0F79
        0F41: 80 50    JMP   0x0F92
(0294) 					 case GR_KEY_ENTER : 
(0295) 						 GrText_const(5,5," ENTER", 6, 0);
        0F43: 50 00    MOV   A,0
        0F45: 08       PUSH  A
        0F46: 50 06    MOV   A,6
        0F48: 08       PUSH  A
        0F49: 50 00    MOV   A,0
        0F4B: 08       PUSH  A
        0F4C: 08       PUSH  A
        0F4D: 50 05    MOV   A,5
        0F4F: 08       PUSH  A
        0F50: 50 13    MOV   A,19
        0F52: 08       PUSH  A
        0F53: 50 05    MOV   A,5
        0F55: 08       PUSH  A
        0F56: 08       PUSH  A
        0F57: 7C 1B 46 LCALL _GrText
        0F5A: 38 F8    ADD   SP,248
(0296) 						break;
        0F5C: 80 35    JMP   0x0F92
(0297) 					 case GR_SPECIAL_KEY_ARROW_UP : 
(0298) 						 GrText_const(5,5," UP   ", 6, 0);
        0F5E: 50 00    MOV   A,0
        0F60: 08       PUSH  A
        0F61: 50 06    MOV   A,6
        0F63: 08       PUSH  A
        0F64: 50 00    MOV   A,0
        0F66: 08       PUSH  A
        0F67: 08       PUSH  A
        0F68: 50 05    MOV   A,5
        0F6A: 08       PUSH  A
        0F6B: 50 0C    MOV   A,12
        0F6D: 08       PUSH  A
        0F6E: 50 05    MOV   A,5
        0F70: 08       PUSH  A
        0F71: 08       PUSH  A
        0F72: 7C 1B 46 LCALL _GrText
        0F75: 38 F8    ADD   SP,248
(0299) 						break;
        0F77: 80 1A    JMP   0x0F92
(0300) 					 case GR_SPECIAL_KEY_ARROW_DOWN : 
(0301) 						 GrText_const(5,5," DOWN ", 6, 0);
        0F79: 50 00    MOV   A,0
        0F7B: 08       PUSH  A
        0F7C: 50 06    MOV   A,6
        0F7E: 08       PUSH  A
        0F7F: 50 00    MOV   A,0
        0F81: 08       PUSH  A
        0F82: 08       PUSH  A
        0F83: 50 05    MOV   A,5
        0F85: 08       PUSH  A
        0F86: 50 05    MOV   A,5
        0F88: 08       PUSH  A
        0F89: 50 05    MOV   A,5
        0F8B: 08       PUSH  A
        0F8C: 08       PUSH  A
        0F8D: 7C 1B 46 LCALL _GrText
        0F90: 38 F8    ADD   SP,248
        0F92: 8D 4B    JMP   0x0CDE
(0302) 						break;
(0303) 				 }
(0304) 				break;
(0305) 		}
(0306) 	}
(0307) }
        0F94: 38 EA    ADD   SP,234
        0F96: 20       POP   X
        0F97: 7F       RET   
FILE: .\printf.c
(0001) /*  Copyright (C) 2004		cheng chung yan	<yan@amonics.com> for 8-bit system
(0002) *  lib C in 8 bit system
(0003) *
(0004) *  This library is free software; you can redistribute it and/or
(0005) *  modify it under the terms of the GNU Library General Public
(0006) *  License as published by the Free Software Foundation; either
(0007) *  version 2 of the License, or (at your option) any later version.
(0008) *
(0009) *  This library is distributed in the hope that it will be useful,
(0010) *  but WITHOUT ANY WARRANTY; without even the implied warranty of
(0011) *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
(0012) *  Library General Public License for more details.
(0013) *
(0014) *  You should have received a copy of the GNU Library General Public
(0015) *  License along with this library; if not, write to the Free
(0016) *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
(0017) *
(0018) *  Design Concept
(0019) *	transfer info. to string and place into the buffer which pointed by a char pointer
(0020) *	support reentrant
(0021) *
(0022) *  Testing Procedures
(0023) *	before you compile, you must copy whole directory of ucliblike8/ to your local home
(0024) *	compile this file in linux gcc environment : "make printf.o" in ucliblike8/
(0025) *	testing by : "main_compile_dir/printf.o" in ucliblike8/
(0026) *
(0027) *  Features
(0028) *	printf format specific
(0029) *		- as left justify
(0030) *		0 as pad zero / empty
(0031) *		number as width for display
(0032) *	print integer & floating point with
(0033) *		left justify
(0034) *		pad zero / empty
(0035) *		width
(0036) *		negative num
(0037) *		base 10 only
(0038) *	floating point
(0039) *		range: -99999.0 to 99999.0
(0040) *		Maximum decimal digit range: 5 decimal digit
(0041) *		Maximum width range=-9 to 9
(0042) *		must entry the width no. of decimal point & the width no.of integer
(0043) *
(0044) *  Examples
(0045) *	print_integer
(0046) *		display negative number with zero for empty position and 4 digital width
(0047) *			unsigned char vec_buf[6];
(0048) *			print_integer(vec_buf, "04", -45);
(0049) *			printf("%s\n",vec_buf);
(0050) *		display number with left justify and 5 digital width
(0051) *			unsigned char vec_buf[6];
(0052) *			print_integer(vec_buf, "-5", 23);
(0053) *			printf("%s\n",vec_buf);
(0054) *	print_float
(0055) *		display negative number with zero for empty position and 5 digital width, 3 decimal points
(0056) *			unsigned char vec_buf[13];
(0057) *			print_float(vec_buf, "05.3", -13.5);
(0058) *			printf("%s\n",vec_buf);
(0059) *		display number with left justify and 5 digital width, 3 decimal points
(0060) *			unsigned char vec_buf[13];
(0061) *			print_float(vec_buf, "-5.2", 23.3);
(0062) *			printf("%s\n",vec_buf);
(0063) *
(0064) *  Pay Attention
(0065) *	MUST input a valid format flag, no chk in coding
(0066) *	width data must great than the real width of number
(0067) *	MUST provide enough buffer (char* out) to hold the char. data, eg. 3456, must provide 5 bytes including '\0'
(0068) *
(0069) */
(0070) 
(0071) #include "printf.h"
(0072) 
(0073) struct format_flag {
(0074) 	unsigned	pad_left :1 ;							// 0 - right justify, 1 - left justify
(0075) 	unsigned	pad_zero :1 ;							// 0 - blank space for empty digit, 1 - '0' for empty digit
(0076) 	unsigned	neg :1 ;							// 0 - +ve number, 1 - '0' - -ve number
(0077) 	unsigned	width :5 ;							// max. 32 digit placement
(0078) #if (FLOAT==1)
(0079) //	signed		width :5;
(0080) 	unsigned	dp :1 ;								// 0 - no decimal, 1 - have decimal
(0081) 
(0082) 	unsigned	decimal :5 ;							// max. 32 digit placement
(0083) 
(0084) 	unsigned	fulldec :1 ;							// 0 - no full decimal, 1 - full decimal
(0085) 	unsigned	add_zero :3 ;							// max 8 digit placement
(0086) #endif
(0087) };
(0088) 
(0089) struct format_flag format_manipulate(const char* flag_ptr)
(0090) {
_format_manipulate:
  flag                 --> X+0
  flag_ptr             --> X-7
        0F98: 10       PUSH  X
        0F99: 4F       MOV   X,SP
        0F9A: 38 03    ADD   SP,3
(0091) 	struct format_flag flag;
(0092) 
(0093) 	flag.pad_left = 0;
        0F9C: 52 00    MOV   A,[X+0]
        0F9E: 21 FE    AND   A,254
        0FA0: 54 00    MOV   [X+0],A
(0094) 	flag.pad_zero = 0;
        0FA2: 52 00    MOV   A,[X+0]
        0FA4: 21 FD    AND   A,253
        0FA6: 54 00    MOV   [X+0],A
(0095) 	flag.neg = 0;
        0FA8: 52 00    MOV   A,[X+0]
        0FAA: 21 FB    AND   A,251
        0FAC: 54 00    MOV   [X+0],A
(0096) 	flag.width = 0;
        0FAE: 52 00    MOV   A,[X+0]
        0FB0: 21 07    AND   A,7
        0FB2: 54 00    MOV   [X+0],A
(0097) #if (FLOAT==1)
(0098) 	flag.dp = 0;
(0099) 	flag.decimal = 0;
(0100) 	flag.fulldec = 0;
(0101) 	flag.add_zero = 0;
(0102) #endif
(0103) 
(0104) 	for (;*flag_ptr;flag_ptr++) {
        0FB4: 80 62    JMP   0x1017
(0105) 		switch (*flag_ptr) {
        0FB6: 52 FA    MOV   A,[X-6]
        0FB8: 53 0D    MOV   [__r1],A
        0FBA: 52 F9    MOV   A,[X-7]
        0FBC: 10       PUSH  X
        0FBD: 58 0D    MOV   X,[__r1]
        0FBF: 28       ROMX  
        0FC0: 20       POP   X
        0FC1: 54 02    MOV   [X+2],A
        0FC3: 56 01 00 MOV   [X+1],0
        0FC6: 3D 01 00 CMP   [X+1],0
        0FC9: B0 06    JNZ   0x0FD0
        0FCB: 3D 02 2D CMP   [X+2],45
        0FCE: A0 0D    JZ    0x0FDC
        0FD0: 3D 01 00 CMP   [X+1],0
        0FD3: B0 06    JNZ   0x0FDA
        0FD5: 3D 02 30 CMP   [X+2],48
        0FD8: A0 0B    JZ    0x0FE4
        0FDA: 80 11    JMP   0x0FEC
(0106) 			case '-' : 							// left justify
(0107) 				 flag.pad_left = 1;
        0FDC: 52 00    MOV   A,[X+0]
        0FDE: 29 01    OR    A,1
        0FE0: 54 00    MOV   [X+0],A
(0108) 				break;
        0FE2: 80 2F    JMP   0x1012
(0109) 			case '0' : 							// pad zero / empty
(0110) 				 flag.pad_zero = 1;
        0FE4: 52 00    MOV   A,[X+0]
        0FE6: 29 02    OR    A,2
        0FE8: 54 00    MOV   [X+0],A
(0111) 				break;
        0FEA: 80 27    JMP   0x1012
(0112) #if (FLOAT==1)
(0113) 			case '.' :
(0114) 				 flag.dp= 1;
(0115) 				 flag_ptr++;
(0116) 				 flag.decimal = *flag_ptr - '0';
(0117) 				break;
(0118) #endif
(0119) 			default :							// number
(0120) 				 flag.width = *flag_ptr - '0';
        0FEC: 52 00    MOV   A,[X+0]
        0FEE: 21 07    AND   A,7
        0FF0: 53 0E    MOV   [__r0],A
        0FF2: 52 FA    MOV   A,[X-6]
        0FF4: 53 0B    MOV   [__r3],A
        0FF6: 52 F9    MOV   A,[X-7]
        0FF8: 10       PUSH  X
        0FF9: 58 0B    MOV   X,[__r3]
        0FFB: 28       ROMX  
        0FFC: 20       POP   X
        0FFD: 53 0C    MOV   [__r2],A
        0FFF: 16 0C 30 SUB   [__r2],48
        1002: 26 0C 1F AND   [__r2],31
        1005: 51 0C    MOV   A,[__r2]
        1007: 64       ASL   A
        1008: 64       ASL   A
        1009: 64       ASL   A
        100A: 21 F8    AND   A,248
        100C: 2C 0E    OR    [__r0],A
        100E: 51 0E    MOV   A,[__r0]
        1010: 54 00    MOV   [X+0],A
        1012: 77 FA    INC   [X-6]
        1014: 0F F9 00 ADC   [X-7],0
        1017: 52 FA    MOV   A,[X-6]
        1019: 53 0D    MOV   [__r1],A
        101B: 52 F9    MOV   A,[X-7]
        101D: 10       PUSH  X
        101E: 58 0D    MOV   X,[__r1]
        1020: 28       ROMX  
        1021: 20       POP   X
        1022: 39 00    CMP   A,0
        1024: BF 91    JNZ   0x0FB6
(0121) 				 // ATTENTION ATTENTION ATTENTION
(0122) 				 //	this input is programmer job to input a valid number
(0123) 				 //	we just want to reduce code size and execution speed, so ignore the checking for programming fault, we assume this must be a number
(0124) 		}
(0125) 	}
(0126) 
(0127) 
(0128) 	return flag;
        1026: 52 FC    MOV   A,[X-4]
        1028: 53 0D    MOV   [__r1],A
        102A: 5A 0B    MOV   [__r3],X
        102C: 3E 0B    MVI   A,[__r3]
        102E: 3F 0D    MVI   [__r1],A
        1030: 38 FD    ADD   SP,253
        1032: 20       POP   X
        1033: 7F       RET   
(0129) }
(0130) 
(0131) #if (INTEGER==1)
(0132) void print_i(char* out, struct format_flag flag, int i)
(0133) {
_print_i:
  tmp                  --> X+2
  j                    --> X+1
  padchar              --> X+0
  i                    --> X-9
  flag                 --> X-7
  out                  --> X-5
        1034: 10       PUSH  X
        1035: 4F       MOV   X,SP
        1036: 38 03    ADD   SP,3
(0134) 	#define	base	10
(0135) 	char padchar;
(0136) 
(0137) #if (FLOAT==1)
(0138) 	if (flag.fulldec) goto next;
(0139) #endif
(0140) 
(0141) 	*(out + flag.width--) = '\0';							// place a NULL at the end of string
        1038: 52 FA    MOV   A,[X-6]
        103A: 53 0D    MOV   [__r1],A
        103C: 3E 0D    MVI   A,[__r1]
        103E: 53 0D    MOV   [__r1],A
        1040: 55 0E 00 MOV   [__r0],0
        1043: 68 0E    ASR   [__r0]
        1045: 6E 0D    RRC   [__r1]
        1047: 68 0E    ASR   [__r0]
        1049: 6E 0D    RRC   [__r1]
        104B: 68 0E    ASR   [__r0]
        104D: 6E 0D    RRC   [__r1]
        104F: 26 0D 1F AND   [__r1],31
        1052: 26 0E 00 AND   [__r0],0
        1055: 52 FA    MOV   A,[X-6]
        1057: 53 0B    MOV   [__r3],A
        1059: 52 FA    MOV   A,[X-6]
        105B: 53 09    MOV   [__r5],A
        105D: 3E 09    MVI   A,[__r5]
        105F: 53 0A    MOV   [__r4],A
        1061: 26 0A 07 AND   [__r4],7
        1064: 51 0D    MOV   A,[__r1]
        1066: 11 01    SUB   A,1
        1068: 53 07    MOV   [__r7],A
        106A: 51 0E    MOV   A,[__r0]
        106C: 19 00    SBB   A,0
        106E: 5F 08 07 MOV   [__r6],[__r7]
        1071: 26 08 1F AND   [__r6],31
        1074: 51 08    MOV   A,[__r6]
        1076: 64       ASL   A
        1077: 64       ASL   A
        1078: 64       ASL   A
        1079: 21 F8    AND   A,248
        107B: 2C 0A    OR    [__r4],A
        107D: 51 0A    MOV   A,[__r4]
        107F: 3F 0B    MVI   [__r3],A
        1081: 52 FC    MOV   A,[X-4]
        1083: 04 0D    ADD   [__r1],A
        1085: 52 FB    MOV   A,[X-5]
        1087: 0C 0E    ADC   [__r0],A
        1089: 50 00    MOV   A,0
        108B: 3F 0D    MVI   [__r1],A
(0142) 
(0143) next:	if (i<0) {									// -ve number
        108D: 52 F7    MOV   A,[X-9]
        108F: 31 80    XOR   A,128
        1091: 53 01    MOV   [__rY],A
        1093: 50 00    MOV   A,0
        1095: 31 80    XOR   A,128
        1097: 53 00    MOV   [NO_SHADOW],A
        1099: 55 02 00 MOV   [__rX],0
        109C: 52 F8    MOV   A,[X-8]
        109E: 11 00    SUB   A,0
        10A0: 2C 02    OR    [__rX],A
        10A2: 51 01    MOV   A,[__rY]
        10A4: 1A 00    SBB   A,[NO_SHADOW]
        10A6: 2C 02    OR    [__rX],A
        10A8: D0 21    JNC   0x10CA
        10AA: 51 02    MOV   A,[__rX]
        10AC: A0 1D    JZ    0x10CA
(0144) 		i = -i;
        10AE: 52 F8    MOV   A,[X-8]
        10B0: 73       CPL   A
        10B1: 11 FF    SUB   A,255
        10B3: 54 F8    MOV   [X-8],A
        10B5: 52 F7    MOV   A,[X-9]
        10B7: 73       CPL   A
        10B8: 19 FF    SBB   A,255
        10BA: 54 F7    MOV   [X-9],A
(0145) 		flag.neg = 1;
        10BC: 52 FA    MOV   A,[X-6]
        10BE: 53 0D    MOV   [__r1],A
        10C0: 52 FA    MOV   A,[X-6]
        10C2: 53 0B    MOV   [__r3],A
        10C4: 3E 0B    MVI   A,[__r3]
        10C6: 29 04    OR    A,4
        10C8: 3F 0D    MVI   [__r1],A
(0146) 	}
(0147) 	if (i==0) *(out + flag.width--) = '0';						//if i=0
        10CA: 3D F7 00 CMP   [X-9],0
        10CD: B0 E6    JNZ   0x11B4
        10CF: 3D F8 00 CMP   [X-8],0
        10D2: B0 E1    JNZ   0x11B4
        10D4: 52 FA    MOV   A,[X-6]
        10D6: 53 0D    MOV   [__r1],A
        10D8: 3E 0D    MVI   A,[__r1]
        10DA: 53 0D    MOV   [__r1],A
        10DC: 55 0E 00 MOV   [__r0],0
        10DF: 68 0E    ASR   [__r0]
        10E1: 6E 0D    RRC   [__r1]
        10E3: 68 0E    ASR   [__r0]
        10E5: 6E 0D    RRC   [__r1]
        10E7: 68 0E    ASR   [__r0]
        10E9: 6E 0D    RRC   [__r1]
        10EB: 26 0D 1F AND   [__r1],31
        10EE: 26 0E 00 AND   [__r0],0
        10F1: 52 FA    MOV   A,[X-6]
        10F3: 53 0B    MOV   [__r3],A
        10F5: 52 FA    MOV   A,[X-6]
        10F7: 53 09    MOV   [__r5],A
        10F9: 3E 09    MVI   A,[__r5]
        10FB: 53 0A    MOV   [__r4],A
        10FD: 26 0A 07 AND   [__r4],7
        1100: 51 0D    MOV   A,[__r1]
        1102: 11 01    SUB   A,1
        1104: 53 07    MOV   [__r7],A
        1106: 51 0E    MOV   A,[__r0]
        1108: 19 00    SBB   A,0
        110A: 5F 08 07 MOV   [__r6],[__r7]
        110D: 26 08 1F AND   [__r6],31
        1110: 51 08    MOV   A,[__r6]
        1112: 64       ASL   A
        1113: 64       ASL   A
        1114: 64       ASL   A
        1115: 21 F8    AND   A,248
        1117: 2C 0A    OR    [__r4],A
        1119: 51 0A    MOV   A,[__r4]
        111B: 3F 0B    MVI   [__r3],A
        111D: 52 FC    MOV   A,[X-4]
        111F: 04 0D    ADD   [__r1],A
        1121: 52 FB    MOV   A,[X-5]
        1123: 0C 0E    ADC   [__r0],A
        1125: 50 30    MOV   A,48
        1127: 3F 0D    MVI   [__r1],A
        1129: 80 8A    JMP   0x11B4
(0148) 
(0149) 	while (i) {									// convert the integer number to string
(0150) 		*(out + flag.width--) = (i % base) + '0';
        112B: 52 FA    MOV   A,[X-6]
        112D: 53 0D    MOV   [__r1],A
        112F: 3E 0D    MVI   A,[__r1]
        1131: 53 0D    MOV   [__r1],A
        1133: 55 0E 00 MOV   [__r0],0
        1136: 68 0E    ASR   [__r0]
        1138: 6E 0D    RRC   [__r1]
        113A: 68 0E    ASR   [__r0]
        113C: 6E 0D    RRC   [__r1]
        113E: 68 0E    ASR   [__r0]
        1140: 6E 0D    RRC   [__r1]
        1142: 26 0D 1F AND   [__r1],31
        1145: 26 0E 00 AND   [__r0],0
        1148: 52 FA    MOV   A,[X-6]
        114A: 53 0B    MOV   [__r3],A
        114C: 52 FA    MOV   A,[X-6]
        114E: 53 09    MOV   [__r5],A
        1150: 3E 09    MVI   A,[__r5]
        1152: 53 0A    MOV   [__r4],A
        1154: 26 0A 07 AND   [__r4],7
        1157: 51 0D    MOV   A,[__r1]
        1159: 11 01    SUB   A,1
        115B: 53 07    MOV   [__r7],A
        115D: 51 0E    MOV   A,[__r0]
        115F: 19 00    SBB   A,0
        1161: 5F 08 07 MOV   [__r6],[__r7]
        1164: 26 08 1F AND   [__r6],31
        1167: 51 08    MOV   A,[__r6]
        1169: 64       ASL   A
        116A: 64       ASL   A
        116B: 64       ASL   A
        116C: 21 F8    AND   A,248
        116E: 2C 0A    OR    [__r4],A
        1170: 51 0A    MOV   A,[__r4]
        1172: 3F 0B    MVI   [__r3],A
        1174: 52 FC    MOV   A,[X-4]
        1176: 04 0D    ADD   [__r1],A
        1178: 52 FB    MOV   A,[X-5]
        117A: 0C 0E    ADC   [__r0],A
        117C: 50 00    MOV   A,0
        117E: 08       PUSH  A
        117F: 50 0A    MOV   A,10
        1181: 08       PUSH  A
        1182: 52 F7    MOV   A,[X-9]
        1184: 08       PUSH  A
        1185: 52 F8    MOV   A,[X-8]
        1187: 08       PUSH  A
        1188: 7C 21 A9 LCALL __divmod_16X16_16
        118B: 38 FE    ADD   SP,254
        118D: 18       POP   A
        118E: 53 0B    MOV   [__r3],A
        1190: 18       POP   A
        1191: 53 0C    MOV   [__r2],A
        1193: 06 0B 30 ADD   [__r3],48
        1196: 0E 0C 00 ADC   [__r2],0
        1199: 51 0B    MOV   A,[__r3]
        119B: 3F 0D    MVI   [__r1],A
(0151) 		i /= base;
        119D: 50 00    MOV   A,0
        119F: 08       PUSH  A
        11A0: 50 0A    MOV   A,10
        11A2: 08       PUSH  A
        11A3: 52 F7    MOV   A,[X-9]
        11A5: 08       PUSH  A
        11A6: 52 F8    MOV   A,[X-8]
        11A8: 08       PUSH  A
        11A9: 7C 21 A9 LCALL __divmod_16X16_16
        11AC: 18       POP   A
        11AD: 54 F8    MOV   [X-8],A
        11AF: 18       POP   A
        11B0: 54 F7    MOV   [X-9],A
        11B2: 38 FE    ADD   SP,254
        11B4: 3D F7 00 CMP   [X-9],0
        11B7: BF 73    JNZ   0x112B
        11B9: 3D F8 00 CMP   [X-8],0
        11BC: BF 6E    JNZ   0x112B
(0152) 	}
(0153) 	if (flag.neg) *(out + flag.width--) = '-';
        11BE: 52 FA    MOV   A,[X-6]
        11C0: 53 0D    MOV   [__r1],A
        11C2: 3E 0D    MVI   A,[__r1]
        11C4: 53 0E    MOV   [__r0],A
        11C6: 68 0E    ASR   [__r0]
        11C8: 68 0E    ASR   [__r0]
        11CA: 26 0E 01 AND   [__r0],1
        11CD: A0 56    JZ    0x1224
        11CF: 52 FA    MOV   A,[X-6]
        11D1: 53 0D    MOV   [__r1],A
        11D3: 3E 0D    MVI   A,[__r1]
        11D5: 53 0D    MOV   [__r1],A
        11D7: 55 0E 00 MOV   [__r0],0
        11DA: 68 0E    ASR   [__r0]
        11DC: 6E 0D    RRC   [__r1]
        11DE: 68 0E    ASR   [__r0]
        11E0: 6E 0D    RRC   [__r1]
        11E2: 68 0E    ASR   [__r0]
        11E4: 6E 0D    RRC   [__r1]
        11E6: 26 0D 1F AND   [__r1],31
        11E9: 26 0E 00 AND   [__r0],0
        11EC: 52 FA    MOV   A,[X-6]
        11EE: 53 0B    MOV   [__r3],A
        11F0: 52 FA    MOV   A,[X-6]
        11F2: 53 09    MOV   [__r5],A
        11F4: 3E 09    MVI   A,[__r5]
        11F6: 53 0A    MOV   [__r4],A
        11F8: 26 0A 07 AND   [__r4],7
        11FB: 51 0D    MOV   A,[__r1]
        11FD: 11 01    SUB   A,1
        11FF: 53 07    MOV   [__r7],A
        1201: 51 0E    MOV   A,[__r0]
        1203: 19 00    SBB   A,0
        1205: 5F 08 07 MOV   [__r6],[__r7]
        1208: 26 08 1F AND   [__r6],31
        120B: 51 08    MOV   A,[__r6]
        120D: 64       ASL   A
        120E: 64       ASL   A
        120F: 64       ASL   A
        1210: 21 F8    AND   A,248
        1212: 2C 0A    OR    [__r4],A
        1214: 51 0A    MOV   A,[__r4]
        1216: 3F 0B    MVI   [__r3],A
        1218: 52 FC    MOV   A,[X-4]
        121A: 04 0D    ADD   [__r1],A
        121C: 52 FB    MOV   A,[X-5]
        121E: 0C 0E    ADC   [__r0],A
        1220: 50 2D    MOV   A,45
        1222: 3F 0D    MVI   [__r1],A
(0154) 
(0155) #if (FLOAT==1)
(0156) 	for(;flag.add_zero;flag.add_zero--){						// add zero for 1.005,1.05,1.012 etc
(0157) 		*(out + flag.width--) = '0';
(0158) 	}
(0159) 
(0160) 	if (flag.dp) {
(0161) 	 	*(out + flag.width--) = '.';
(0162) 		goto complete;
(0163) 	}
(0164) #endif
(0165) 
(0166) 	if (++flag.width) {								// if not fit to width, place something in the space
        1224: 52 FA    MOV   A,[X-6]
        1226: 53 0D    MOV   [__r1],A
        1228: 3E 0D    MVI   A,[__r1]
        122A: 53 0D    MOV   [__r1],A
        122C: 55 0E 00 MOV   [__r0],0
        122F: 53 0B    MOV   [__r3],A
        1231: 55 0C 00 MOV   [__r2],0
        1234: 68 0C    ASR   [__r2]
        1236: 6E 0B    RRC   [__r3]
        1238: 68 0C    ASR   [__r2]
        123A: 6E 0B    RRC   [__r3]
        123C: 68 0C    ASR   [__r2]
        123E: 6E 0B    RRC   [__r3]
        1240: 26 0B 1F AND   [__r3],31
        1243: 26 0C 00 AND   [__r2],0
        1246: 06 0B 01 ADD   [__r3],1
        1249: 0E 0C 00 ADC   [__r2],0
        124C: 55 0C 00 MOV   [__r2],0
        124F: 26 0B 1F AND   [__r3],31
        1252: 26 0C 00 AND   [__r2],0
        1255: 52 FA    MOV   A,[X-6]
        1257: 53 09    MOV   [__r5],A
        1259: 26 0D 07 AND   [__r1],7
        125C: 26 0E FF AND   [__r0],255
        125F: 5F 07 0B MOV   [__r7],[__r3]
        1262: 5F 08 0C MOV   [__r6],[__r2]
        1265: 65 07    ASL   [__r7]
        1267: 6B 08    RLC   [__r6]
        1269: 65 07    ASL   [__r7]
        126B: 6B 08    RLC   [__r6]
        126D: 65 07    ASL   [__r7]
        126F: 6B 08    RLC   [__r6]
        1271: 26 07 F8 AND   [__r7],248
        1274: 26 08 00 AND   [__r6],0
        1277: 51 07    MOV   A,[__r7]
        1279: 2C 0D    OR    [__r1],A
        127B: 51 08    MOV   A,[__r6]
        127D: 2C 0E    OR    [__r0],A
        127F: 51 0D    MOV   A,[__r1]
        1281: 3F 09    MVI   [__r5],A
        1283: 3C 0C 00 CMP   [__r2],0
        1286: B0 06    JNZ   0x128D
        1288: 3C 0B 00 CMP   [__r3],0
        128B: A1 E7    JZ    0x1473
(0167) 											//	since the above ++flag.width, so i must adjust back to right position
(0168) //	printf("flagwidth=%d\n",flag.width);						//check point only
(0169) 
(0170) 
(0171) 		if (flag.pad_left) {							// left justify and width value > real width
        128D: 52 FA    MOV   A,[X-6]
        128F: 53 0D    MOV   [__r1],A
        1291: 3E 0D    MVI   A,[__r1]
        1293: 53 0E    MOV   [__r0],A
        1295: 26 0E 01 AND   [__r0],1
        1298: A0 58    JZ    0x12F1
(0172) 			unsigned char j = 0;						//	adding one to flag.width 1st, because
        129A: 56 01 00 MOV   [X+1],0
(0173) 			char tmp;							//	if fit of digial placement, ++flag.width == 0
(0174) 			do {
(0175) 				tmp = *(out + flag.width + j);
        129D: 52 01    MOV   A,[X+1]
        129F: 53 0D    MOV   [__r1],A
        12A1: 55 0E 00 MOV   [__r0],0
        12A4: 52 FA    MOV   A,[X-6]
        12A6: 53 0B    MOV   [__r3],A
        12A8: 3E 0B    MVI   A,[__r3]
        12AA: 53 0B    MOV   [__r3],A
        12AC: 55 0C 00 MOV   [__r2],0
        12AF: 68 0C    ASR   [__r2]
        12B1: 6E 0B    RRC   [__r3]
        12B3: 68 0C    ASR   [__r2]
        12B5: 6E 0B    RRC   [__r3]
        12B7: 68 0C    ASR   [__r2]
        12B9: 6E 0B    RRC   [__r3]
        12BB: 26 0B 1F AND   [__r3],31
        12BE: 26 0C 00 AND   [__r2],0
        12C1: 52 FC    MOV   A,[X-4]
        12C3: 04 0B    ADD   [__r3],A
        12C5: 52 FB    MOV   A,[X-5]
        12C7: 0C 0C    ADC   [__r2],A
        12C9: 51 0B    MOV   A,[__r3]
        12CB: 04 0D    ADD   [__r1],A
        12CD: 51 0C    MOV   A,[__r2]
        12CF: 0C 0E    ADC   [__r0],A
        12D1: 3E 0D    MVI   A,[__r1]
        12D3: 54 02    MOV   [X+2],A
(0176) 				*(out + j) = tmp;
        12D5: 52 01    MOV   A,[X+1]
        12D7: 53 0D    MOV   [__r1],A
        12D9: 55 0E 00 MOV   [__r0],0
        12DC: 52 FC    MOV   A,[X-4]
        12DE: 04 0D    ADD   [__r1],A
        12E0: 52 FB    MOV   A,[X-5]
        12E2: 0C 0E    ADC   [__r0],A
        12E4: 52 02    MOV   A,[X+2]
        12E6: 3F 0D    MVI   [__r1],A
(0177) 				j++;
        12E8: 77 01    INC   [X+1]
(0178) 			} while (tmp);							//	chk '\0'
        12EA: 3D 02 00 CMP   [X+2],0
        12ED: BF AF    JNZ   0x129D
(0179) 		} else {
        12EF: 81 83    JMP   0x1473
(0180) 			if ((!flag.neg)||(!flag.pad_zero)) flag.width--;
        12F1: 52 FA    MOV   A,[X-6]
        12F3: 53 0D    MOV   [__r1],A
        12F5: 3E 0D    MVI   A,[__r1]
        12F7: 53 0D    MOV   [__r1],A
        12F9: 55 0E 00 MOV   [__r0],0
        12FC: 53 0B    MOV   [__r3],A
        12FE: 55 0C 00 MOV   [__r2],0
        1301: 68 0C    ASR   [__r2]
        1303: 6E 0B    RRC   [__r3]
        1305: 68 0C    ASR   [__r2]
        1307: 6E 0B    RRC   [__r3]
        1309: 26 0B 01 AND   [__r3],1
        130C: 26 0C 00 AND   [__r2],0
        130F: B0 06    JNZ   0x1316
        1311: 3C 0B 00 CMP   [__r3],0
        1314: A0 12    JZ    0x1327
        1316: 68 0E    ASR   [__r0]
        1318: 6E 0D    RRC   [__r1]
        131A: 26 0D 01 AND   [__r1],1
        131D: 26 0E 00 AND   [__r0],0
        1320: B0 62    JNZ   0x1383
        1322: 3C 0D 00 CMP   [__r1],0
        1325: B0 5D    JNZ   0x1383
        1327: 52 FA    MOV   A,[X-6]
        1329: 53 0D    MOV   [__r1],A
        132B: 3E 0D    MVI   A,[__r1]
        132D: 53 0D    MOV   [__r1],A
        132F: 55 0E 00 MOV   [__r0],0
        1332: 52 FA    MOV   A,[X-6]
        1334: 53 0B    MOV   [__r3],A
        1336: 51 0D    MOV   A,[__r1]
        1338: 21 07    AND   A,7
        133A: 53 09    MOV   [__r5],A
        133C: 50 00    MOV   A,0
        133E: 21 FF    AND   A,255
        1340: 53 0A    MOV   [__r4],A
        1342: 68 0E    ASR   [__r0]
        1344: 6E 0D    RRC   [__r1]
        1346: 68 0E    ASR   [__r0]
        1348: 6E 0D    RRC   [__r1]
        134A: 68 0E    ASR   [__r0]
        134C: 6E 0D    RRC   [__r1]
        134E: 26 0D 1F AND   [__r1],31
        1351: 26 0E 00 AND   [__r0],0
        1354: 16 0D 01 SUB   [__r1],1
        1357: 1E 0E 00 SBB   [__r0],0
        135A: 55 0E 00 MOV   [__r0],0
        135D: 26 0D 1F AND   [__r1],31
        1360: 26 0E 00 AND   [__r0],0
        1363: 65 0D    ASL   [__r1]
        1365: 6B 0E    RLC   [__r0]
        1367: 65 0D    ASL   [__r1]
        1369: 6B 0E    RLC   [__r0]
        136B: 65 0D    ASL   [__r1]
        136D: 6B 0E    RLC   [__r0]
        136F: 26 0D F8 AND   [__r1],248
        1372: 26 0E 00 AND   [__r0],0
        1375: 51 09    MOV   A,[__r5]
        1377: 2A 0D    OR    A,[__r1]
        1379: 53 0D    MOV   [__r1],A
        137B: 51 0A    MOV   A,[__r4]
        137D: 2A 0E    OR    A,[__r0]
        137F: 51 0D    MOV   A,[__r1]
        1381: 3F 0B    MVI   [__r3],A
(0181) 			if (flag.pad_zero) padchar = '0';				// place zero for empty space and width value > real width
        1383: 52 FA    MOV   A,[X-6]
        1385: 53 0D    MOV   [__r1],A
        1387: 3E 0D    MVI   A,[__r1]
        1389: 53 0E    MOV   [__r0],A
        138B: 70 FB    AND   F,251
        138D: 6E 0E    RRC   [__r0]
        138F: 26 0E 01 AND   [__r0],1
        1392: A0 06    JZ    0x1399
        1394: 56 00 30 MOV   [X+0],48
        1397: 80 04    JMP   0x139C
(0182) 			else padchar = ' ';
        1399: 56 00 20 MOV   [X+0],32
(0183) 			do {
(0184) 				*(out + flag.width) = padchar;
        139C: 52 FA    MOV   A,[X-6]
        139E: 53 0D    MOV   [__r1],A
        13A0: 3E 0D    MVI   A,[__r1]
        13A2: 53 0D    MOV   [__r1],A
        13A4: 55 0E 00 MOV   [__r0],0
        13A7: 68 0E    ASR   [__r0]
        13A9: 6E 0D    RRC   [__r1]
        13AB: 68 0E    ASR   [__r0]
        13AD: 6E 0D    RRC   [__r1]
        13AF: 68 0E    ASR   [__r0]
        13B1: 6E 0D    RRC   [__r1]
        13B3: 26 0D 1F AND   [__r1],31
        13B6: 26 0E 00 AND   [__r0],0
        13B9: 52 FC    MOV   A,[X-4]
        13BB: 04 0D    ADD   [__r1],A
        13BD: 52 FB    MOV   A,[X-5]
        13BF: 0C 0E    ADC   [__r0],A
        13C1: 52 00    MOV   A,[X+0]
        13C3: 3F 0D    MVI   [__r1],A
(0185) 				if (flag.width) flag.width--;
        13C5: 52 FA    MOV   A,[X-6]
        13C7: 53 0D    MOV   [__r1],A
        13C9: 3E 0D    MVI   A,[__r1]
        13CB: 67       ASR   A
        13CC: 67       ASR   A
        13CD: 67       ASR   A
        13CE: 21 1F    AND   A,31
        13D0: 53 0E    MOV   [__r0],A
        13D2: 26 0E 1F AND   [__r0],31
        13D5: A0 5F    JZ    0x1435
        13D7: 52 FA    MOV   A,[X-6]
        13D9: 53 0D    MOV   [__r1],A
        13DB: 3E 0D    MVI   A,[__r1]
        13DD: 53 0D    MOV   [__r1],A
        13DF: 55 0E 00 MOV   [__r0],0
        13E2: 52 FA    MOV   A,[X-6]
        13E4: 53 0B    MOV   [__r3],A
        13E6: 51 0D    MOV   A,[__r1]
        13E8: 21 07    AND   A,7
        13EA: 53 09    MOV   [__r5],A
        13EC: 50 00    MOV   A,0
        13EE: 21 FF    AND   A,255
        13F0: 53 0A    MOV   [__r4],A
        13F2: 68 0E    ASR   [__r0]
        13F4: 6E 0D    RRC   [__r1]
        13F6: 68 0E    ASR   [__r0]
        13F8: 6E 0D    RRC   [__r1]
        13FA: 68 0E    ASR   [__r0]
        13FC: 6E 0D    RRC   [__r1]
        13FE: 26 0D 1F AND   [__r1],31
        1401: 26 0E 00 AND   [__r0],0
        1404: 16 0D 01 SUB   [__r1],1
        1407: 1E 0E 00 SBB   [__r0],0
        140A: 55 0E 00 MOV   [__r0],0
        140D: 26 0D 1F AND   [__r1],31
        1410: 26 0E 00 AND   [__r0],0
        1413: 65 0D    ASL   [__r1]
        1415: 6B 0E    RLC   [__r0]
        1417: 65 0D    ASL   [__r1]
        1419: 6B 0E    RLC   [__r0]
        141B: 65 0D    ASL   [__r1]
        141D: 6B 0E    RLC   [__r0]
        141F: 26 0D F8 AND   [__r1],248
        1422: 26 0E 00 AND   [__r0],0
        1425: 51 09    MOV   A,[__r5]
        1427: 2A 0D    OR    A,[__r1]
        1429: 53 0D    MOV   [__r1],A
        142B: 51 0A    MOV   A,[__r4]
        142D: 2A 0E    OR    A,[__r0]
        142F: 51 0D    MOV   A,[__r1]
        1431: 3F 0B    MVI   [__r3],A
(0186) 				else break;
(0187) 			} while (1);
        1433: 8F 68    JMP   0x139C
(0188) 			if ((flag.neg)&&(flag.pad_zero)) *out = '-';			//	should be *(out + flag.width), but flag.width must be zere
        1435: 52 FA    MOV   A,[X-6]
        1437: 53 0D    MOV   [__r1],A
        1439: 3E 0D    MVI   A,[__r1]
        143B: 53 0D    MOV   [__r1],A
        143D: 55 0E 00 MOV   [__r0],0
        1440: 53 0B    MOV   [__r3],A
        1442: 55 0C 00 MOV   [__r2],0
        1445: 68 0C    ASR   [__r2]
        1447: 6E 0B    RRC   [__r3]
        1449: 68 0C    ASR   [__r2]
        144B: 6E 0B    RRC   [__r3]
        144D: 26 0B 01 AND   [__r3],1
        1450: 26 0C 00 AND   [__r2],0
        1453: B0 06    JNZ   0x145A
        1455: 3C 0B 00 CMP   [__r3],0
        1458: A0 1A    JZ    0x1473
        145A: 68 0E    ASR   [__r0]
        145C: 6E 0D    RRC   [__r1]
        145E: 26 0D 01 AND   [__r1],1
        1461: 26 0E 00 AND   [__r0],0
        1464: B0 06    JNZ   0x146B
        1466: 3C 0D 00 CMP   [__r1],0
        1469: A0 09    JZ    0x1473
        146B: 52 FC    MOV   A,[X-4]
        146D: 53 0D    MOV   [__r1],A
        146F: 50 2D    MOV   A,45
        1471: 3F 0D    MVI   [__r1],A
(0189) 		}
(0190) 	}
(0191) #if (FLOAT==1)
(0192) complete:		flag.dp=0;
(0193) #endif
(0194) }
        1473: 38 FD    ADD   SP,253
        1475: 20       POP   X
        1476: 7F       RET   
(0195) 
(0196) 
(0197) void print_integer(char* out, const char* flag_ptr, int i)
(0198) {
_print_integer:
  i                    --> X-9
  flag_ptr             --> X-7
  out                  --> X-5
        1477: 10       PUSH  X
        1478: 4F       MOV   X,SP
        1479: 38 01    ADD   SP,1
(0199) 	print_i(out,format_manipulate(flag_ptr),i);
        147B: 52 F9    MOV   A,[X-7]
        147D: 08       PUSH  A
        147E: 52 FA    MOV   A,[X-6]
        1480: 08       PUSH  A
        1481: 51 0E    MOV   A,[__r0]
        1483: 08       PUSH  A
        1484: 10       PUSH  X
        1485: 9B 11    CALL  _format_manipulate
        1487: 52 F7    MOV   A,[X-9]
        1489: 08       PUSH  A
        148A: 52 F8    MOV   A,[X-8]
        148C: 08       PUSH  A
        148D: 51 0E    MOV   A,[__r0]
        148F: 08       PUSH  A
        1490: 10       PUSH  X
        1491: 52 FB    MOV   A,[X-5]
        1493: 08       PUSH  A
        1494: 52 FC    MOV   A,[X-4]
        1496: 08       PUSH  A
        1497: 9B 9B    CALL  _print_i
        1499: 38 F6    ADD   SP,246
(0200) }
        149B: 38 FF    ADD   SP,255
        149D: 20       POP   X
        149E: 7F       RET   
FILE: .\sched.c
(0001) /*
(0002)  *	kernel/sched.c
(0003)  *
(0004)  *	Kernel scheduler and related syscalls
(0005)  *
(0006)  *	09-04-2004	yan	create this following linux
(0007)  */
(0008) 
(0009) #include "app.h"
(0010) #include "sched.h"
(0011) #include "current.h"									// MUST be placed after sched.h
(0012) #include "system.h"
(0013) #include "timer.h"									// timer_list
(0014) 
(0015) void sched_init(void);
(0016) struct task_struct task[NR_TASKS];
(0017) #if (CONTEXT_SW==1)
(0018) unsigned char current_ptr;
(0019) unsigned char next_ptr;
(0020) #endif
(0021) 
(0022) #if (AUTO_ZERO==0)
(0023) extern void init_timer(void);
(0024) #endif
(0025) 
(0026) void sched_init(void)
(0027) {
(0028) 	//unsigned char cpu = smp_processor_id();					// get existing process id
(0029) 	//init_task.processor = cpu;
(0030) 
(0031) #if (AUTO_ZERO==0)
(0032) 	init_timer();
(0033) #endif
(0034) 
(0035) 				// the following does not same to linux
(0036) 				// init. process 0
(0037) #if (AUTO_ZERO==0)
(0038) #if (CONTEXT_SW==1)
(0039) 	current_ptr = 0;
(0040) 	next_ptr = 0;
(0041) #endif
(0042) #endif
(0043) 	get_process0_sp();								// task[0].stack_ptr = SP, since Process0 is also starting from this layer, see main.c
_sched_init:
        149F: 55 0D 13 MOV   [__r1],19
        14A2: 4E       SWAP  SP,A
        14A3: 3F 0D    MVI   [__r1],A
        14A5: 4E       SWAP  SP,A
(0044) 	wake_up_process(current);
        14A6: 5F 0D 12 MOV   [__r1],[_current_ptr]
        14A9: 55 0E 00 MOV   [__r0],0
        14AC: 65 0D    ASL   [__r1]
        14AE: 6B 0E    RLC   [__r0]
        14B0: 06 0D 14 ADD   [__r1],20
        14B3: 0E 0E 00 ADC   [__r0],0
        14B6: 50 00    MOV   A,0
        14B8: 3F 0D    MVI   [__r1],A
(0045) }
        14BA: 7F       RET   
(0046) 
(0047) //void wake_up_process(struct task_struct* p)
(0048) //{
(0049) //	p->state = TASK_RUNNING;
(0050) //}
(0051) 
(0052) #if (CONTEXT_SW==1)
(0053) 		// Description : each time kernel arrange different processes to run, this schedule must be called, so try to min. the code and RAM
(0054) 		//			global variables declaration, since reduce time to declar in local and save memory in each time stack
(0055) struct task_struct *prev;						
(0056) void schedule(void)
(0057) {
(0058) 	cli();
_schedule:
        14BB: 70 FE    AND   F,254
(0059) 	prev = current;
        14BD: 5F 0D 12 MOV   [__r1],[_current_ptr]
        14C0: 55 0E 00 MOV   [__r0],0
        14C3: 65 0D    ASL   [__r1]
        14C5: 6B 0E    RLC   [__r0]
        14C7: 51 0D    MOV   A,[__r1]
        14C9: 01 13    ADD   A,19
        14CB: 53 11    MOV   [_prev+1],A
        14CD: 51 0E    MOV   A,[__r0]
        14CF: 09 00    ADC   A,0
        14D1: 53 10    MOV   [_prev],A
(0060) 	do {										// seek next running state process
(0061) 		if (next_ptr==0) {								//	just normal sched for next
        14D3: 3C 17 00 CMP   [_next_ptr],0
        14D6: B0 0D    JNZ   0x14E4
(0062) 			current_ptr++;							//		method A => choose this method, since it is more save RAM and ROM code studied from assembly code, at least in cypress PSoC, verify other mcus, and think about what is the good implement method from C
        14D8: 76 12    INC   [_current_ptr]
(0063) 			if (current_ptr==NR_TASKS) current_ptr = 0;
        14DA: 3C 12 02 CMP   [_current_ptr],2
        14DD: B0 0C    JNZ   0x14EA
        14DF: 55 12 00 MOV   [_current_ptr],0
(0064) 			//current_ptr = ((current_ptr++) == NR_TASKS) ? 0 :;		//		method B
(0065) 		} else {								//	any urge process
        14E2: 80 07    JMP   0x14EA
(0066) 			current_ptr = next_ptr;
        14E4: 5F 12 17 MOV   [_current_ptr],[_next_ptr]
(0067) 			next_ptr = 0;
        14E7: 55 17 00 MOV   [_next_ptr],0
(0068) 		}
(0069) 	} while (current->state!=TASK_RUNNING);
        14EA: 5F 0D 12 MOV   [__r1],[_current_ptr]
        14ED: 55 0E 00 MOV   [__r0],0
        14F0: 65 0D    ASL   [__r1]
        14F2: 6B 0E    RLC   [__r0]
        14F4: 06 0D 14 ADD   [__r1],20
        14F7: 0E 0E 00 ADC   [__r0],0
        14FA: 3E 0D    MVI   A,[__r1]
        14FC: BF D6    JNZ   0x14D3
(0070) 	if (prev!=current) switch_to();
        14FE: 5F 0D 12 MOV   [__r1],[_current_ptr]
        1501: 55 0E 00 MOV   [__r0],0
        1504: 65 0D    ASL   [__r1]
        1506: 6B 0E    RLC   [__r0]
        1508: 06 0D 13 ADD   [__r1],19
        150B: 0E 0E 00 ADC   [__r0],0
        150E: 51 10    MOV   A,[_prev]
        1510: 3A 0E    CMP   A,[__r0]
        1512: B0 07    JNZ   0x151A
        1514: 51 11    MOV   A,[_prev+1]
        1516: 3A 0D    CMP   A,[__r1]
        1518: A0 1C    JZ    0x1535
        151A: 10       PUSH  X
        151B: 4E       SWAP  SP,A
        151C: 5F 0D 11 MOV   [__r1],[_prev+1]
        151F: 3F 0D    MVI   [__r1],A
        1521: 5F 0D 12 MOV   [__r1],[_current_ptr]
        1524: 55 0E 00 MOV   [__r0],0
        1527: 65 0D    ASL   [__r1]
        1529: 6B 0E    RLC   [__r0]
        152B: 06 0D 13 ADD   [__r1],19
        152E: 0E 0E 00 ADC   [__r0],0
        1531: 3E 0D    MVI   A,[__r1]
        1533: 4E       SWAP  SP,A
        1534: 20       POP   X
(0071) 	sti();
        1535: 71 01    OR    F,1
(0072) }
        1537: 7F       RET   
(0073) 
(0074) //void sys_sched_yield(void)
(0075) //{
(0076) //
(0077) //}
(0078) //void sched_yield(void)
(0079) //{
(0080) 	//set_current_state(TASK_RUNNING);						// already in running state
(0081) 	//sys_sched_yield();
(0082) //	schedule();
(0083) //}
(0084) 
(0085) #if (TIMER_MOD==1)                    
(0086) 		// Remarks 
(0087) 		//	* max. of time for sleep is 256Sec
(0088) extern char add_timer(struct timer_list* ptimer_addr);
(0089) //extern void del_timer(unsigned char timer_num);
(0090) /*void schedule_timeout(unsigned char sec)
(0091) {
(0092) 	unsigned char i;
(0093) 	struct timer_list timer;
(0094) 	current->state = TASK_INTERRUPTIBLE;
(0095) 	timer.expires = sec * 100 + jiffies;						// since 10mSec for 1 tick, so X100
(0096) 	timer.data = (unsigned int) current;
(0097) 	//timer.function = process_timeout;
(0098) 	i = add_timer(&timer);
(0099) 	schedule();
(0100) 	del_timer(i);
(0101) }*/
(0102) 		// must in times of 10mSec
(0103) void schedule_timeout(unsigned char millisec_time_10)
(0104) {
_schedule_timeout:
  i                    --> X+3
  timer                --> X+0
  millisec_time_10     --> X-4
        1538: 10       PUSH  X
        1539: 4F       MOV   X,SP
        153A: 38 04    ADD   SP,4
(0105) 	unsigned char i;
(0106) 	struct timer_list timer;
(0107) 	timer.expires = millisec_time_10 + jiffies;					// since 10mSec for 1 tick, so X100
        153C: 52 FC    MOV   A,[X-4]
        153E: 02 36    ADD   A,[_jiffies]
        1540: 54 00    MOV   [X+0],A
(0108) 	timer.data.timer_data = (0xff00 | ((unsigned int) current_ptr));		// related to timer.c only
        1542: 51 12    MOV   A,[_current_ptr]
        1544: 29 00    OR    A,0
        1546: 54 02    MOV   [X+2],A
        1548: 50 00    MOV   A,0
        154A: 29 FF    OR    A,255
        154C: 54 01    MOV   [X+1],A
(0109) 	//timer.data = (unsigned int) current;
(0110) 	if ((i = add_timer(&timer))>=0) current->state = TASK_INTERRUPTIBLE;
        154E: 50 00    MOV   A,0
        1550: 08       PUSH  A
        1551: 10       PUSH  X
        1552: 7C 1E A9 LCALL _add_timer
        1555: 38 FE    ADD   SP,254
        1557: 54 03    MOV   [X+3],A
        1559: 39 00    CMP   A,0
        155B: A0 03    JZ    0x155F
        155D: C0 15    JC    0x1573
        155F: 5F 0D 12 MOV   [__r1],[_current_ptr]
        1562: 55 0E 00 MOV   [__r0],0
        1565: 65 0D    ASL   [__r1]
        1567: 6B 0E    RLC   [__r0]
        1569: 06 0D 14 ADD   [__r1],20
        156C: 0E 0E 00 ADC   [__r0],0
        156F: 50 01    MOV   A,1
        1571: 3F 0D    MVI   [__r1],A
(0111) 	schedule();									// when switching, struct timer_list timer staying be kept
        1573: 9F 46    CALL  _schedule
(0112) 	if (i>=0) del_timer(i);
        1575: 3D 03 00 CMP   [X+3],0
        1578: A0 03    JZ    0x157C
        157A: C0 18    JC    0x1593
        157C: 52 03    MOV   A,[X+3]
        157E: 53 0D    MOV   [__r1],A
        1580: 55 0E 00 MOV   [__r0],0
        1583: 65 0D    ASL   [__r1]
        1585: 6B 0E    RLC   [__r0]
        1587: 06 0D 30 ADD   [__r1],48
        158A: 0E 0E 00 ADC   [__r0],0
        158D: 76 0D    INC   [__r1]
        158F: 50 00    MOV   A,0
        1591: 3F 0D    MVI   [__r1],A
(0113) }
        1593: 38 FC    ADD   SP,252
        1595: 20       POP   X
        1596: 7F       RET   
FILE: .\serial.c
(0001) /*
(0002)  * Copyright (c) 24-05-2004 cheng chung yan yan@amonics.com> / <chungyan5@hkem.com for 8-bit system
(0003)  *
(0004)  * this module is serial in cypress psoc, driver specification. So each arch. has different code here
(0005)  * 
(0006)  * using cypress psoc serial
(0007)  *
(0008)  */
(0009) 
(0010) #include "app.h"									// this linlike8
(0011) #if (SERIAL_MOD==1)
(0012) #if (SWITCH_CASE==0)
(0013) 	#include "sched.h"								// linlike8 system
(0014) 	#include "timer.h"
(0015) #endif
(0016) #include "cirbuf.h"									// pre_wr_cir254buf()
(0017) #include "uart_1.h"
(0018) 
(0019) unsigned char serial_rx_buf[MAX_SERIAL_BUF];
(0020) struct {
(0021) 	unsigned	wr :4;
(0022) 	unsigned	rd :4;
(0023) } serial_rx;
(0024) unsigned char serial_tx_buf[MAX_SERIAL_TX_BUF];
(0025) struct {
(0026) 	unsigned	wr :3;								// max. of tx buf. is 7
(0027) 	unsigned	rd :4;
(0028) 	unsigned	tx_complete_flag :1;						// true as completed, false is non-completed
(0029) } serial_tx;
(0030) #if (SWITCH_CASE==1)
(0031) struct wr_compl_struct {
(0032) 	unsigned tmp	:7;
(0033) 	unsigned state	:1;
(0034) } wr_compl_var;
(0035) #endif
(0036) 
(0037) void serial_open(void)
(0038) {
(0039) 	serial_rx.wr = 0;
_serial_open:
        1597: 26 1D 00 AND   [_serial_rx],0
(0040) 	serial_rx.rd = 0;
(0041) 	serial_tx.wr = 0;
        159A: 26 19 80 AND   [_serial_tx],128
(0042) 	serial_tx.rd = 0;
(0043) 	serial_tx.tx_complete_flag = 1;
        159D: 2E 19 80 OR    [_serial_tx],128
(0044) 
(0045) #if (SWITCH_CASE==1)
(0046) 	wr_compl_var.state = 0;
        15A0: 26 18 7F AND   [_wr_compl_var],127
(0047) #endif
(0048)         UART_1_EnableInt(); 
        15A3: 10       PUSH  X
        15A4: 7C 09 46 LCALL 0x0946
(0049)         UART_1_Start(UART_PARITY_NONE);
        15A7: 50 00    MOV   A,0
        15A9: 7C 09 54 LCALL 0x0954
        15AC: 20       POP   X
(0050) }
        15AD: 7F       RET   
(0051) #endif
(0052) 
(0053) #pragma	interrupt_handler	serial_tx_isr						// shouald add this isr name at boot.asm from PSoC Designer
(0054) void serial_tx_isr(void)
(0055) {
_serial_tx_isr:
  k                    --> X+0
        15AE: 08       PUSH  A
        15AF: 51 0E    MOV   A,[__r0]
        15B1: 08       PUSH  A
        15B2: 51 0D    MOV   A,[__r1]
        15B4: 08       PUSH  A
        15B5: 51 0C    MOV   A,[__r2]
        15B7: 08       PUSH  A
        15B8: 51 0B    MOV   A,[__r3]
        15BA: 08       PUSH  A
        15BB: 51 0A    MOV   A,[__r4]
        15BD: 08       PUSH  A
        15BE: 51 09    MOV   A,[__r5]
        15C0: 08       PUSH  A
        15C1: 51 08    MOV   A,[__r6]
        15C3: 08       PUSH  A
        15C4: 51 07    MOV   A,[__r7]
        15C6: 08       PUSH  A
        15C7: 51 06    MOV   A,[__r8]
        15C9: 08       PUSH  A
        15CA: 51 05    MOV   A,[__r9]
        15CC: 08       PUSH  A
        15CD: 51 04    MOV   A,[__r10]
        15CF: 08       PUSH  A
        15D0: 51 03    MOV   A,[__r11]
        15D2: 08       PUSH  A
        15D3: 51 02    MOV   A,[__rX]
        15D5: 08       PUSH  A
        15D6: 51 01    MOV   A,[__rY]
        15D8: 08       PUSH  A
        15D9: 51 00    MOV   A,[NO_SHADOW]
        15DB: 08       PUSH  A
        15DC: 10       PUSH  X
        15DD: 4F       MOV   X,SP
        15DE: 38 01    ADD   SP,1
(0056) #if (SERIAL_MOD==1)
(0057) 	unsigned char k;
(0058) 	if (bUART_1_ReadTxStatus() & UART_TX_BUFFER_EMPTY) {
        15E0: 10       PUSH  X
        15E1: 7C 09 65 LCALL 0x0965
        15E4: 20       POP   X
        15E5: 53 0E    MOV   [__r0],A
        15E7: 47 0E 10 TST   [__r0],16
        15EA: A0 5C    JZ    0x1647
(0059) 		if ((k=pre_rd_cir254buf((unsigned char)serial_tx.wr,(unsigned char)serial_tx.rd,MAX_SERIAL_TX_BUF))!=255) {
        15EC: 50 03    MOV   A,3
        15EE: 08       PUSH  A
        15EF: 51 19    MOV   A,[_serial_tx]
        15F1: 67       ASR   A
        15F2: 67       ASR   A
        15F3: 67       ASR   A
        15F4: 21 0F    AND   A,15
        15F6: 08       PUSH  A
        15F7: 51 19    MOV   A,[_serial_tx]
        15F9: 21 07    AND   A,7
        15FB: 08       PUSH  A
        15FC: 7C 09 D6 LCALL _pre_rd_cir254buf
        15FF: 38 FD    ADD   SP,253
        1601: 54 00    MOV   [X+0],A
        1603: 39 FF    CMP   A,255
        1605: A0 3C    JZ    0x1642
(0060) 			UART_1_SendData(serial_tx_buf[(unsigned char)serial_tx.rd]);
        1607: 5F 0D 19 MOV   [__r1],[_serial_tx]
        160A: 55 0E 00 MOV   [__r0],0
        160D: 68 0E    ASR   [__r0]
        160F: 6E 0D    RRC   [__r1]
        1611: 68 0E    ASR   [__r0]
        1613: 6E 0D    RRC   [__r1]
        1615: 68 0E    ASR   [__r0]
        1617: 6E 0D    RRC   [__r1]
        1619: 26 0D 0F AND   [__r1],15
        161C: 26 0E 00 AND   [__r0],0
        161F: 06 0D 1A ADD   [__r1],26
        1622: 0E 0E 00 ADC   [__r0],0
        1625: 3E 0D    MVI   A,[__r1]
        1627: 10       PUSH  X
        1628: 7C 09 62 LCALL 0x0962
        162B: 20       POP   X
(0061) 			serial_tx.rd = (unsigned)k;
        162C: 51 19    MOV   A,[_serial_tx]
        162E: 21 87    AND   A,135
        1630: 53 0E    MOV   [__r0],A
        1632: 52 00    MOV   A,[X+0]
        1634: 21 0F    AND   A,15
        1636: 64       ASL   A
        1637: 64       ASL   A
        1638: 64       ASL   A
        1639: 21 78    AND   A,120
        163B: 2C 0E    OR    [__r0],A
        163D: 5F 19 0E MOV   [_serial_tx],[__r0]
(0062) 		} else serial_tx.tx_complete_flag = 1;					// change to empty of tx
        1640: 80 06    JMP   0x1647
        1642: 2E 19 80 OR    [_serial_tx],128
        1645: 51 19    MOV   A,[_serial_tx]
(0063) 	}
(0064) #endif
(0065) }
        1647: 38 FF    ADD   SP,255
        1649: 20       POP   X
        164A: 18       POP   A
        164B: 53 00    MOV   [NO_SHADOW],A
        164D: 18       POP   A
        164E: 53 01    MOV   [__rY],A
        1650: 18       POP   A
        1651: 53 02    MOV   [__rX],A
        1653: 18       POP   A
        1654: 53 03    MOV   [__r11],A
        1656: 18       POP   A
        1657: 53 04    MOV   [__r10],A
        1659: 18       POP   A
        165A: 53 05    MOV   [__r9],A
        165C: 18       POP   A
        165D: 53 06    MOV   [__r8],A
        165F: 18       POP   A
        1660: 53 07    MOV   [__r7],A
        1662: 18       POP   A
        1663: 53 08    MOV   [__r6],A
        1665: 18       POP   A
        1666: 53 09    MOV   [__r5],A
        1668: 18       POP   A
        1669: 53 0A    MOV   [__r4],A
        166B: 18       POP   A
        166C: 53 0B    MOV   [__r3],A
        166E: 18       POP   A
        166F: 53 0C    MOV   [__r2],A
        1671: 18       POP   A
        1672: 53 0D    MOV   [__r1],A
        1674: 18       POP   A
        1675: 53 0E    MOV   [__r0],A
        1677: 18       POP   A
        1678: 7E       RETI  
(0066) 
(0067) #pragma	interrupt_handler	serial_rx_isr						// shouald add this isr name at boot.asm from PSoC Designer
(0068) void serial_rx_isr(void)
(0069) {
_serial_rx_isr:
  i                    --> X+1
  bRxStatus            --> X+0
        1679: 08       PUSH  A
        167A: 51 0E    MOV   A,[__r0]
        167C: 08       PUSH  A
        167D: 51 0D    MOV   A,[__r1]
        167F: 08       PUSH  A
        1680: 51 0C    MOV   A,[__r2]
        1682: 08       PUSH  A
        1683: 51 0B    MOV   A,[__r3]
        1685: 08       PUSH  A
        1686: 51 0A    MOV   A,[__r4]
        1688: 08       PUSH  A
        1689: 51 09    MOV   A,[__r5]
        168B: 08       PUSH  A
        168C: 51 08    MOV   A,[__r6]
        168E: 08       PUSH  A
        168F: 51 07    MOV   A,[__r7]
        1691: 08       PUSH  A
        1692: 51 06    MOV   A,[__r8]
        1694: 08       PUSH  A
        1695: 51 05    MOV   A,[__r9]
        1697: 08       PUSH  A
        1698: 51 04    MOV   A,[__r10]
        169A: 08       PUSH  A
        169B: 51 03    MOV   A,[__r11]
        169D: 08       PUSH  A
        169E: 51 02    MOV   A,[__rX]
        16A0: 08       PUSH  A
        16A1: 51 01    MOV   A,[__rY]
        16A3: 08       PUSH  A
        16A4: 51 00    MOV   A,[NO_SHADOW]
        16A6: 08       PUSH  A
        16A7: 10       PUSH  X
        16A8: 4F       MOV   X,SP
        16A9: 38 02    ADD   SP,2
(0070) #if (SERIAL_MOD==1)
(0071) 	unsigned char i;
(0072) 	unsigned char bRxStatus;
(0073) 	if ( bRxStatus=bUART_1_ReadRxStatus() & UART_RX_COMPLETE ) {
        16AB: 10       PUSH  X
        16AC: 7C 09 6B LCALL 0x096B
        16AF: 20       POP   X
        16B0: 21 08    AND   A,8
        16B2: 54 00    MOV   [X+0],A
        16B4: 39 00    CMP   A,0
        16B6: A0 51    JZ    0x1708
(0074) 		if ( ! (bRxStatus & UART_RX_NO_ERROR) ) {
        16B8: 48 00 E0 TST   [X+0],224
        16BB: B0 4C    JNZ   0x1708
(0075) 			if ((i=pre_wr_cir254buf(serial_rx.wr,serial_rx.rd,MAX_SERIAL_BUF))!=255) {
        16BD: 50 09    MOV   A,9
        16BF: 08       PUSH  A
        16C0: 51 1D    MOV   A,[_serial_rx]
        16C2: 67       ASR   A
        16C3: 67       ASR   A
        16C4: 67       ASR   A
        16C5: 67       ASR   A
        16C6: 21 0F    AND   A,15
        16C8: 08       PUSH  A
        16C9: 51 1D    MOV   A,[_serial_rx]
        16CB: 21 0F    AND   A,15
        16CD: 08       PUSH  A
        16CE: 7C 09 B3 LCALL _pre_wr_cir254buf
        16D1: 38 FD    ADD   SP,253
        16D3: 54 01    MOV   [X+1],A
        16D5: 39 FF    CMP   A,255
        16D7: A0 2B    JZ    0x1703
(0076) 				serial_rx_buf[serial_rx.wr] = bUART_1_ReadRxData();
        16D9: 10       PUSH  X
        16DA: 7C 09 68 LCALL 0x0968
        16DD: 20       POP   X
        16DE: 5F 0B 1D MOV   [__r3],[_serial_rx]
        16E1: 55 0C 00 MOV   [__r2],0
        16E4: 26 0B 0F AND   [__r3],15
        16E7: 26 0C 00 AND   [__r2],0
        16EA: 06 0B 1E ADD   [__r3],30
        16ED: 0E 0C 00 ADC   [__r2],0
        16F0: 3F 0B    MVI   [__r3],A
(0077) 				serial_rx.wr = i;
        16F2: 51 1D    MOV   A,[_serial_rx]
        16F4: 21 F0    AND   A,240
        16F6: 53 0E    MOV   [__r0],A
        16F8: 52 01    MOV   A,[X+1]
        16FA: 21 0F    AND   A,15
        16FC: 2C 0E    OR    [__r0],A
        16FE: 5F 1D 0E MOV   [_serial_rx],[__r0]
(0078) 			} else bUART_1_ReadRxData();					// any cases, i must need to clear the UART rx register data, then prepare for next interrupt
        1701: 80 06    JMP   0x1708
        1703: 10       PUSH  X
        1704: 7C 09 68 LCALL 0x0968
        1707: 20       POP   X
(0079) 		}
(0080) 	}
(0081) #endif
(0082) }
        1708: 38 FE    ADD   SP,254
        170A: 20       POP   X
        170B: 18       POP   A
        170C: 53 00    MOV   [NO_SHADOW],A
        170E: 18       POP   A
        170F: 53 01    MOV   [__rY],A
        1711: 18       POP   A
        1712: 53 02    MOV   [__rX],A
        1714: 18       POP   A
        1715: 53 03    MOV   [__r11],A
        1717: 18       POP   A
        1718: 53 04    MOV   [__r10],A
        171A: 18       POP   A
        171B: 53 05    MOV   [__r9],A
        171D: 18       POP   A
        171E: 53 06    MOV   [__r8],A
        1720: 18       POP   A
        1721: 53 07    MOV   [__r7],A
        1723: 18       POP   A
        1724: 53 08    MOV   [__r6],A
        1726: 18       POP   A
        1727: 53 09    MOV   [__r5],A
        1729: 18       POP   A
        172A: 53 0A    MOV   [__r4],A
        172C: 18       POP   A
        172D: 53 0B    MOV   [__r3],A
        172F: 18       POP   A
        1730: 53 0C    MOV   [__r2],A
        1732: 18       POP   A
        1733: 53 0D    MOV   [__r1],A
        1735: 18       POP   A
        1736: 53 0E    MOV   [__r0],A
        1738: 18       POP   A
        1739: 7E       RETI  
(0083) 
(0084) #if (SERIAL_MOD==1)
(0085) unsigned char write(unsigned char *__buf, unsigned char __n)
(0086) {
_write:
  i                    --> X+1
  var                  --> X+0
  __n                  --> X-6
  __buf                --> X-5
        173A: 10       PUSH  X
        173B: 4F       MOV   X,SP
        173C: 38 02    ADD   SP,2
(0087) 	unsigned char i;
(0088) //	struct {
(0089) //		unsigned j : 7;
(0090) 		//unsigned k : 1;
(0091) //	} var;
(0092) 	unsigned char var;
(0093) 	
(0094) 	if (serial_tx.tx_complete_flag) {						// empty of tx
        173E: 51 19    MOV   A,[_serial_tx]
        1740: 67       ASR   A
        1741: 67       ASR   A
        1742: 67       ASR   A
        1743: 67       ASR   A
        1744: 67       ASR   A
        1745: 67       ASR   A
        1746: 67       ASR   A
        1747: 21 01    AND   A,1
        1749: 53 0E    MOV   [__r0],A
        174B: 26 0E 01 AND   [__r0],1
        174E: A0 06    JZ    0x1755
(0095) 		//var.k = 1;
(0096) 		var = 1;
        1750: 56 00 01 MOV   [X+0],1
(0097) 	} else {
        1753: 80 57    JMP   0x17AB
(0098) 		//var.k = 0;
(0099) 		var = 0;
        1755: 56 00 00 MOV   [X+0],0
(0100) 	}
(0101) 	for (;var<__n;var++) {
        1758: 80 52    JMP   0x17AB
(0102) 		if ((i=pre_wr_cir254buf((unsigned char)serial_tx.wr,(unsigned char)serial_tx.rd,MAX_SERIAL_TX_BUF))!=255) {
        175A: 50 03    MOV   A,3
        175C: 08       PUSH  A
        175D: 51 19    MOV   A,[_serial_tx]
        175F: 67       ASR   A
        1760: 67       ASR   A
        1761: 67       ASR   A
        1762: 21 0F    AND   A,15
        1764: 08       PUSH  A
        1765: 51 19    MOV   A,[_serial_tx]
        1767: 21 07    AND   A,7
        1769: 08       PUSH  A
        176A: 7C 09 B3 LCALL _pre_wr_cir254buf
        176D: 38 FD    ADD   SP,253
        176F: 54 01    MOV   [X+1],A
        1771: 39 FF    CMP   A,255
        1773: A0 3F    JZ    0x17B3
(0103) 			serial_tx_buf[serial_tx.wr] = *(__buf+var);
        1775: 5F 0D 19 MOV   [__r1],[_serial_tx]
        1778: 55 0E 00 MOV   [__r0],0
        177B: 26 0D 07 AND   [__r1],7
        177E: 26 0E 00 AND   [__r0],0
        1781: 06 0D 1A ADD   [__r1],26
        1784: 0E 0E 00 ADC   [__r0],0
        1787: 52 00    MOV   A,[X+0]
        1789: 53 0B    MOV   [__r3],A
        178B: 55 0C 00 MOV   [__r2],0
        178E: 52 FC    MOV   A,[X-4]
        1790: 04 0B    ADD   [__r3],A
        1792: 52 FB    MOV   A,[X-5]
        1794: 0C 0C    ADC   [__r2],A
        1796: 3E 0B    MVI   A,[__r3]
        1798: 3F 0D    MVI   [__r1],A
(0104) 			serial_tx.wr = i;
        179A: 51 19    MOV   A,[_serial_tx]
        179C: 21 F8    AND   A,248
        179E: 53 0E    MOV   [__r0],A
        17A0: 52 01    MOV   A,[X+1]
        17A2: 21 07    AND   A,7
        17A4: 2C 0E    OR    [__r0],A
        17A6: 5F 19 0E MOV   [_serial_tx],[__r0]
        17A9: 77 00    INC   [X+0]
        17AB: 52 00    MOV   A,[X+0]
        17AD: 3B FA    CMP   A,[X-6]
        17AF: A0 03    JZ    0x17B3
        17B1: CF A8    JC    0x175A
(0105) 		} else break;
(0106) 	}
(0107) //	if (var.k==1) UART_1_SendData(*(__buf));
(0108) 	if (serial_tx.tx_complete_flag) {
        17B3: 51 19    MOV   A,[_serial_tx]
        17B5: 67       ASR   A
        17B6: 67       ASR   A
        17B7: 67       ASR   A
        17B8: 67       ASR   A
        17B9: 67       ASR   A
        17BA: 67       ASR   A
        17BB: 67       ASR   A
        17BC: 21 01    AND   A,1
        17BE: 53 0E    MOV   [__r0],A
        17C0: 26 0E 01 AND   [__r0],1
        17C3: A0 0F    JZ    0x17D3
(0109) 		UART_1_SendData(*(__buf));	// send 1st byte to active the Tx
        17C5: 52 FC    MOV   A,[X-4]
        17C7: 53 0D    MOV   [__r1],A
        17C9: 3E 0D    MVI   A,[__r1]
        17CB: 10       PUSH  X
        17CC: 7C 09 62 LCALL 0x0962
        17CF: 20       POP   X
(0110) 		serial_tx.tx_complete_flag = 0;						// change to non-empty of tx
        17D0: 26 19 7F AND   [_serial_tx],127
(0111) 	}
(0112) 	return (unsigned char) var;
        17D3: 52 00    MOV   A,[X+0]
        17D5: 38 FE    ADD   SP,254
        17D7: 20       POP   X
        17D8: 7F       RET   
(0113) }
(0114) 
(0115) //<rec 1 byte,remove>unsigned char read(unsigned char *__buf, unsigned char __n)	// reduce RAM usage
(0116) unsigned char read(unsigned char *__buf)//<rec 1 byte,add>
(0117) {
_read:
  k                    --> X+0
  __buf                --> X-5
        17D9: 10       PUSH  X
        17DA: 4F       MOV   X,SP
        17DB: 38 01    ADD   SP,1
(0118) 	unsigned char k;
(0119) 	//<rec 1 byte,remove>unsigned char j;
(0120) 	//<rec 1 byte,remove>for (j=0;j<__n;j++) {
(0121) 		if ((k=pre_rd_cir254buf(serial_rx.wr,serial_rx.rd,MAX_SERIAL_BUF))!=255) {
        17DD: 50 09    MOV   A,9
        17DF: 08       PUSH  A
        17E0: 51 1D    MOV   A,[_serial_rx]
        17E2: 67       ASR   A
        17E3: 67       ASR   A
        17E4: 67       ASR   A
        17E5: 67       ASR   A
        17E6: 21 0F    AND   A,15
        17E8: 08       PUSH  A
        17E9: 51 1D    MOV   A,[_serial_rx]
        17EB: 21 0F    AND   A,15
        17ED: 08       PUSH  A
        17EE: 7C 09 D6 LCALL _pre_rd_cir254buf
        17F1: 38 FD    ADD   SP,253
        17F3: 54 00    MOV   [X+0],A
        17F5: 39 FF    CMP   A,255
        17F7: A0 44    JZ    0x183C
(0122) 			//<rec 1 byte,remove>*(__buf+j) = serial_rx_buf[serial_rx.rd];
(0123) 			*(__buf) = serial_rx_buf[serial_rx.rd];//<rec 1 byte,add>
        17F9: 52 FC    MOV   A,[X-4]
        17FB: 53 0D    MOV   [__r1],A
        17FD: 5F 0B 1D MOV   [__r3],[_serial_rx]
        1800: 55 0C 00 MOV   [__r2],0
        1803: 68 0C    ASR   [__r2]
        1805: 6E 0B    RRC   [__r3]
        1807: 68 0C    ASR   [__r2]
        1809: 6E 0B    RRC   [__r3]
        180B: 68 0C    ASR   [__r2]
        180D: 6E 0B    RRC   [__r3]
        180F: 68 0C    ASR   [__r2]
        1811: 6E 0B    RRC   [__r3]
        1813: 26 0B 0F AND   [__r3],15
        1816: 26 0C 00 AND   [__r2],0
        1819: 06 0B 1E ADD   [__r3],30
        181C: 0E 0C 00 ADC   [__r2],0
        181F: 3E 0B    MVI   A,[__r3]
        1821: 3F 0D    MVI   [__r1],A
(0124) 			serial_rx.rd = k;
        1823: 51 1D    MOV   A,[_serial_rx]
        1825: 21 0F    AND   A,15
        1827: 53 0E    MOV   [__r0],A
        1829: 52 00    MOV   A,[X+0]
        182B: 21 0F    AND   A,15
        182D: 64       ASL   A
        182E: 64       ASL   A
        182F: 64       ASL   A
        1830: 64       ASL   A
        1831: 21 F0    AND   A,240
        1833: 2C 0E    OR    [__r0],A
        1835: 5F 1D 0E MOV   [_serial_rx],[__r0]
(0125) 			return 1;//<rec 1 byte,add>
        1838: 50 01    MOV   A,1
        183A: 80 03    JMP   0x183E
(0126) 		}//<rec 1 byte,add>
(0127) 		return 0;//<rec 1 byte,add>
        183C: 50 00    MOV   A,0
        183E: 38 FF    ADD   SP,255
        1840: 20       POP   X
        1841: 7F       RET   
(0128) 		//<rec 1 byte,remove>} else break;
(0129) 	//<rec 1 byte,remove>}
(0130) 	//<rec 1 byte,remove>return j;
(0131) }
(0132) 
(0133) #if (SWITCH_CASE==0)
(0134) void serial_write_complete(unsigned char *__buf, unsigned char __n)
(0135) {
(0136) 	// non-tested
(0137) 	unsigned char i = 0;
(0138) 	do {
(0139) 		i += write(__buf + i, __n - i);
(0140) 		if (i==__n) break;
(0141) 		else msleep(10);
(0142) 	} while (1);
(0143) }
(0144) #else
(0145) unsigned char serial_write_complete(unsigned char *__buf, unsigned char __n)
(0146) {
_serial_write_complete:
  __n                  --> X-6
  __buf                --> X-5
        1842: 10       PUSH  X
        1843: 4F       MOV   X,SP
        1844: 38 04    ADD   SP,4
(0147) 	switch (wr_compl_var.state) {
        1846: 5F 0D 18 MOV   [__r1],[_wr_compl_var]
        1849: 55 0E 00 MOV   [__r0],0
        184C: 68 0E    ASR   [__r0]
        184E: 6E 0D    RRC   [__r1]
        1850: 68 0E    ASR   [__r0]
        1852: 6E 0D    RRC   [__r1]
        1854: 68 0E    ASR   [__r0]
        1856: 6E 0D    RRC   [__r1]
        1858: 68 0E    ASR   [__r0]
        185A: 6E 0D    RRC   [__r1]
        185C: 68 0E    ASR   [__r0]
        185E: 6E 0D    RRC   [__r1]
        1860: 68 0E    ASR   [__r0]
        1862: 6E 0D    RRC   [__r1]
        1864: 68 0E    ASR   [__r0]
        1866: 6E 0D    RRC   [__r1]
        1868: 26 0D 01 AND   [__r1],1
        186B: 26 0E 00 AND   [__r0],0
        186E: 51 0D    MOV   A,[__r1]
        1870: 54 01    MOV   [X+1],A
        1872: 51 0E    MOV   A,[__r0]
        1874: 54 00    MOV   [X+0],A
        1876: 3D 00 00 CMP   [X+0],0
        1879: B0 06    JNZ   0x1880
        187B: 3D 01 00 CMP   [X+1],0
        187E: A0 0D    JZ    0x188C
        1880: 3D 00 00 CMP   [X+0],0
        1883: B0 06    JNZ   0x188A
        1885: 3D 01 01 CMP   [X+1],1
        1888: A0 0D    JZ    0x1896
        188A: 80 74    JMP   0x18FF
(0148) 		case 0 :
(0149) 			 wr_compl_var.tmp = 0;
        188C: 26 18 80 AND   [_wr_compl_var],128
(0150) 			 wr_compl_var.state = 1;
        188F: 2E 18 80 OR    [_wr_compl_var],128
        1892: 51 18    MOV   A,[_wr_compl_var]
(0151) 			break;
        1894: 80 6A    JMP   0x18FF
(0152) 		case 1 :
(0153) 			 wr_compl_var.tmp += write(__buf + wr_compl_var.tmp, __n - wr_compl_var.tmp);
        1896: 5F 0D 18 MOV   [__r1],[_wr_compl_var]
        1899: 55 0E 00 MOV   [__r0],0
        189C: 26 0D 7F AND   [__r1],127
        189F: 26 0E 00 AND   [__r0],0
        18A2: 51 0D    MOV   A,[__r1]
        18A4: 54 03    MOV   [X+3],A
        18A6: 51 0E    MOV   A,[__r0]
        18A8: 54 02    MOV   [X+2],A
        18AA: 52 FA    MOV   A,[X-6]
        18AC: 53 0B    MOV   [__r3],A
        18AE: 55 0C 00 MOV   [__r2],0
        18B1: 51 0D    MOV   A,[__r1]
        18B3: 14 0B    SUB   [__r3],A
        18B5: 51 0E    MOV   A,[__r0]
        18B7: 1C 0C    SBB   [__r2],A
        18B9: 51 0B    MOV   A,[__r3]
        18BB: 08       PUSH  A
        18BC: 51 0D    MOV   A,[__r1]
        18BE: 03 FC    ADD   A,[X-4]
        18C0: 53 0B    MOV   [__r3],A
        18C2: 51 0E    MOV   A,[__r0]
        18C4: 0B FB    ADC   A,[X-5]
        18C6: 08       PUSH  A
        18C7: 51 0B    MOV   A,[__r3]
        18C9: 08       PUSH  A
        18CA: 9E 6E    CALL  _write
        18CC: 38 FD    ADD   SP,253
        18CE: 53 0E    MOV   [__r0],A
        18D0: 51 18    MOV   A,[_wr_compl_var]
        18D2: 21 80    AND   A,128
        18D4: 53 0C    MOV   [__r2],A
        18D6: 5F 0D 0E MOV   [__r1],[__r0]
        18D9: 55 0E 00 MOV   [__r0],0
        18DC: 52 03    MOV   A,[X+3]
        18DE: 02 0D    ADD   A,[__r1]
        18E0: 53 0D    MOV   [__r1],A
        18E2: 52 02    MOV   A,[X+2]
        18E4: 0A 0E    ADC   A,[__r0]
        18E6: 5F 0E 0D MOV   [__r0],[__r1]
        18E9: 26 0E 7F AND   [__r0],127
        18EC: 51 0C    MOV   A,[__r2]
        18EE: 2A 0E    OR    A,[__r0]
        18F0: 53 18    MOV   [_wr_compl_var],A
(0154) 			 if (wr_compl_var.tmp>=__n) wr_compl_var.state = 0;
        18F2: 51 18    MOV   A,[_wr_compl_var]
        18F4: 21 7F    AND   A,127
        18F6: 3B FA    CMP   A,[X-6]
        18F8: A0 03    JZ    0x18FC
        18FA: C0 04    JC    0x18FF
        18FC: 26 18 7F AND   [_wr_compl_var],127
(0155) 			break;
(0156) 	}
(0157) 	return (unsigned char) wr_compl_var.state;
        18FF: 51 18    MOV   A,[_wr_compl_var]
        1901: 67       ASR   A
        1902: 67       ASR   A
        1903: 67       ASR   A
        1904: 67       ASR   A
        1905: 67       ASR   A
        1906: 67       ASR   A
        1907: 67       ASR   A
        1908: 21 01    AND   A,1
        190A: 38 FC    ADD   SP,252
        190C: 20       POP   X
        190D: 7F       RET   
FILE: .\setup.c
(0001) /*
(0002)  *	arch/cypress_psoc/kernel/setup.c
(0003)  *
(0004)  *	09-04-2004	yan	create this following linux, init. this arch 
(0005)  *
(0006)  */
(0007) 
(0008) #include "app.h"
(0009) 
(0010) extern void gpio_open(void);
(0011) #if (SERIAL_MOD==1)
(0012) extern void serial_open(void);
(0013) #endif
(0014) #if (I2C_MOD==1)
(0015) extern void i2c_open(void);
(0016) #endif
(0017) //#if (KB_MOD==1)
(0018) //extern void kb_open(void);
(0019) //#endif
(0020) 
(0021) void setup_arch(void)
(0022) {
(0023) 	gpio_open();
_setup_arch:
        190E: 7C 0A A9 LCALL _gpio_open
(0024) //#if (KB_MOD==1)
(0025) //	kb_open();
(0026) //#endif
(0027) #if (SERIAL_MOD==1)
(0028) 	serial_open();
        1911: 7C 15 97 LCALL _serial_open
(0029) #endif
(0030) #if (I2C_MOD==1)
(0031) 	i2c_open();
(0032) #endif
(0033) 
(0034) }
        1914: 7F       RET   
FILE: .\softirq.c
(0001) /*
(0002)  *	kernel/softirq.c
(0003)  *
(0004)  *	29-04-2004	yan	create this following linux
(0005)  *
(0006)  */
(0007) 
(0008) #include "app.h"
(0009) #include "system.h"									// sti             
(0010) #include "hardirq.h"									// irq_cpustat.h, in_interrupt
(0011) #include "irq_cpustat.h"								// irq_cpustat_t
(0012) #include "softirq.h"									// local_bh_disable
(0013) #include "sched.h"									// schedule()
(0014) 
(0015) irq_cpustat_t irq_stat[1];								// must be '1', since linlike8 just support single MCU; where to init. in linux ???
(0016) unsigned char softirq_vec;
(0017) 
(0018) #if (TIMER_MOD==1)                    
(0019) extern void timer_softirq(void);
(0020) #endif                                                                   
(0021) extern void gpio_softirq(void);
(0022) 
(0023) void softirq_init(void)
(0024) {
(0025) #if (AUTO_ZERO==0)
(0026) 	softirq_vec = 0;
(0027) 	irq_stat[0].__local_softirq_count = 0;
(0028) #endif
(0029) }
_softirq_init:
        1915: 7F       RET   
(0030) 			
(0031) void do_softirq(void)
(0032) {
(0033) 	if (in_interrupt()) return;							// if any previous soft irq is running, avoid nesting, return to let it to run cont., current soft irq will be run after previous by looping
_do_softirq:
        1916: 3C 28 00 CMP   [_irq_stat],0
        1919: A0 03    JZ    0x191D
        191B: 80 26    JMP   0x1942
(0034) 	local_softirq_disable();
        191D: 76 28    INC   [_irq_stat]
(0035) 	sti();										// start to enable interrupt again
        191F: 71 01    OR    F,1
        1921: 80 19    JMP   0x193B
(0036) 	while (softirq_vec) {
(0037) #if (TIMER_MOD==1)                    
(0038) 		if (softirq_vec&0x01) {timer_softirq();softirq_vec&=~0x01;}		// timer is always has interrupt, so let it to chk and do 1st to reduce each interrupt time consuming
        1923: 47 27 01 TST   [_softirq_vec],1
        1926: A0 09    JZ    0x1930
        1928: 7C 1C EE LCALL _timer_softirq
        192B: 26 27 FE AND   [_softirq_vec],254
        192E: 80 0C    JMP   0x193B
(0039) 		else if (softirq_vec&0x02) {gpio_softirq();softirq_vec&=~0x02;}
        1930: 47 27 02 TST   [_softirq_vec],2
        1933: A0 07    JZ    0x193B
        1935: 7C 0B 69 LCALL _gpio_softirq
        1938: 26 27 FD AND   [_softirq_vec],253
        193B: 3C 27 00 CMP   [_softirq_vec],0
        193E: BF E4    JNZ   0x1923
(0040) #else
(0041) 		if (softirq_vec&0x02) {gpio_softirq();softirq_vec&=~0x02;}
(0042) #endif
(0043) 		//else if (softirq_vec&0x04) ;						// after complete one softirq, directly go to while loop goto chk and out
(0044) 		// ... 
(0045) 		
(0046) 	}
(0047) 	local_softirq_enable();
        1940: 7A 28    DEC   [_irq_stat]
(0048) #if (AUTO_SW_MOD==1)
(0049) 	schedule();
(0050) #endif
(0051) }
        1942: 7F       RET   
FILE: .\srvfunc.c
(0001) /*
(0002)  * Copyright (c) 1999, 2000, 2001, 2002, 2003 Greg Haerr <greg@censoft.com>
(0003)  * Portions Copyright (c) 2002 by Koninklijke Philips Electronics N.V.
(0004)  * Copyright (c) 2000 Alex Holden <alex@linuxhacker.org>
(0005)  * Copyright (c) 1991 David I. Bell
(0006)  * Copyright (c) 2004 cheng chung yan <chungyan5@hkem.com / yan@amonics.com> for 8-bit system
(0007)  * Permission is granted to use, distribute, or modify this source,
(0008)  * provided that this copyright notice remains intact.
(0009)  */
(0010) 
(0011) #include "app.h"
(0012) #include "nano-X.h"
(0013) #include "sched.h"									// timer.h
(0014) #include "timer.h"									// msleep()
(0015) #include "psoc_gpio_bit.h"								// led_hw_off()
(0016) #include "cirbuf.h"									// pre_wr_cir254buf()
(0017) 
(0018) //#include "serial.h"
(0019) 
(0020) 		// LED and Buzzer
(0021) //struct io_bit_struct buzzer_ctrl;
(0022) //struct io_bit_struct led_ctrl;
(0023) struct io_bit_struct io_bit_ctrl;
(0024) #if (ADD_LED>0)
(0025) struct ADD_LED_STRUCT add_led;
(0026) #endif
(0027) 		// events
(0028) GR_EVENT events_vect[NR_EVENT];
(0029) struct EVENT_PTR ptr_events_vect;
(0030) //unsigned char wr_ptr_events_vect;
(0031) //unsigned char rd_ptr_events_vect;
(0032) 
(0033) void io_open(void)
(0034) {
(0035) 	buz_hw_off;									// hw init.
_io_open:
        1943: 41 08 F7 AND   REG[8],247
(0036) 	led_hw_off;
        1946: 43 08 80 OR    REG[8],128
(0037) 	buz_off();
        1949: 26 2C E0 AND   [_io_bit_ctrl],224
(0038) 	led_off();
(0039) #if (ADD_LED>0)
(0040) 	led_1st_off();
(0041) 	#if (ADD_LED>1)
(0042) 	led_2nd_off();
(0043) 	#endif
(0044) 	#if (ADD_LED>2)
(0045) 	led_3rd_off();
(0046) 	#endif
(0047) #endif
(0048) 	#if (SWITCH_CASE==1)
(0049) 	io_bit_ctrl.GrGetNextEventTimeout_status = 0;
(0050) 	#endif
(0051) }
        194C: 7F       RET   
(0052) 
(0053) // return -1, event buf. full; all others as completed in this number index
(0054) /*char wr_event(char event_type)
(0055) {
(0056) 	if ((i=pre_wr_cir254buf(wr_ptr_events_vect,rd_ptr_events_vect,NR_EVENT))!=255) {
(0057) 		events_vect[wr_ptr_events_vect].type = event_type;
(0058) 		wr_ptr_events_vect = i;
(0059) 	}
(0060) 	//
(0061) 	unsigned char tmp1 = wr_ptr_events_vect;
(0062) 	unsigned char tmp = (wr_ptr_events_vect==NR_EVENT) ? 0 : wr_ptr_events_vect + 1;
(0063) 	if (tmp==rd_ptr_events_vect) return ((char) -1);
(0064) 	events_vect[wr_ptr_events_vect].type = event_type;
(0065) 	wr_ptr_events_vect = tmp;
(0066) 	return tmp1;
(0067) }*/
(0068) 
(0069) /*
(0070)  * Map the window to make it (and possibly its children) visible on the screen.
(0071)  * (this subr. is placed in server side, but be called from client, i.e. coding running in client side)
(0072)  */
(0073) //void
(0074) //GrMapWindow(void)
(0075) //{
(0076) //	unsigned char i;
(0077) //	if ((i=pre_wr_cir254buf(ptr_events_vect.wr,ptr_events_vect.rd,NR_EVENT))!=255) {
(0078) //		events_vect[ptr_events_vect.wr].type = GR_EVENT_TYPE_EXPOSURE;
(0079) //		ptr_events_vect.wr = i;
(0080) //	}
(0081) //}
(0082) 
(0083) /*
(0084)  * Return the next event from the event queue, or
(0085)  * wait for a new one if one is not ready.  If timeout
(0086)  * is nonzero, return timeout event if time elapsed.
(0087)  * timeout in millisecond
(0088)  * Assume the ep event as zero content
(0089)  * (this subr. is placed in server side, but be called from client, i.e. coding running in client side)
(0090)  * max. timeout is 12500mSec
(0091)  */
(0092) #define TIME_OUT_INTERVAL	50							// in mill. second
(0093) #if (SWITCH_CASE==0)
(0094) void
(0095) GrGetNextEventTimeout(GR_EVENT *ep, GR_TIMEOUT timeout)
(0096) {
(0097) 	unsigned char max_time_out = timeout/TIME_OUT_INTERVAL;
(0098) 	unsigned char i = 0;
(0099) 	//unsigned char buz_j;
(0100) 	//unsigned char led_j;
(0101) 	unsigned char k;								// for circular buffer
(0102) 	ep->type = GR_EVENT_TYPE_NONE;
(0103) 	
(0104) 	do {
(0105) 		// sleep regular time as TIME_OUT_INTERVAL
(0106) 		msleep(TIME_OUT_INTERVAL);
(0107) 		
(0108) 		// check event job 
(0109) 		if ((k=pre_rd_cir254buf((unsigned char) ptr_events_vect.wr,(unsigned char) ptr_events_vect.rd,NR_EVENT))==255) {	// no event
(0110) 			if (i==max_time_out) ep->type = GR_EVENT_TYPE_TIMEOUT;
(0111) 			else i++;
(0112) 		} else {										// event occurs
(0113) 			*ep = events_vect[(unsigned char) ptr_events_vect.rd];
(0114) 			//ep->type = events_vect[rd_ptr_events_vect].type;
(0115) 			ptr_events_vect.rd = k;
(0116) 		}
(0117) 		
(0118) 		// buzzer control job
(0119) 		switch (io_bit_ctrl.buzzer_stat) {
(0120) 			case BUZZER_OFF :
(0121) 				 buz_hw_off;
(0122) 				break;
(0123) 			case BUZZER_POS_PULSE :
(0124) 				 buz_hw_on;
(0125) 				 //io_bit_ctrl.buzzer_stat = BUZZER_POS_PULSE_1;
(0126) 				 io_bit_ctrl.buzzer_stat = BUZZER_OFF;
(0127) 				break;
(0128) 			/*case BUZZER_POS_PULSE_1 :
(0129) 				 if (max_time_out>4) {					// 4 as 4 X 50mSec = 200mSec
(0130) 					 if (i>=4) io_bit_ctrl.buzzer_stat = BUZZER_OFF;
(0131) 				 } else {
(0132) 					 if (i>=max_time_out) io_bit_ctrl.buzzer_stat = BUZZER_OFF;
(0133) 				 }
(0134) 				break;
(0135) 			case BUZZER_REP_PULSE :
(0136) 				 buz_j = buzzer_ctrl.cnt;
(0137) 				 buzzer_ctrl.stat = BUZZER_REP_PULSE_1;
(0138) 				break;
(0139) 			case BUZZER_REP_PULSE_1 :
(0140) 				 if ((buz_j--)>(buzzer_ctrl.cnt/2)) {
(0141) 					buz_hw_on;
(0142) 				 } else {
(0143) 					if (buz_j==0) buz_j = buzzer_ctrl.cnt;
(0144) 					buz_hw_off;
(0145) 				 }
(0146) 				break;*/
(0147) 		}
(0148) 		
(0149) 		// led control job
(0150) 		switch (io_bit_ctrl.led_stat) {
(0151) 			case LED_OFF :
(0152) 				 led_hw_off;
(0153) 				break;
(0154) 			case LED_POS_PULSE :
(0155) 				 led_hw_on;
(0156) 				 io_bit_ctrl.led_stat = LED_OFF;
(0157) 				break;
(0158) 			case LED_ON :
(0159) 				 led_hw_on;
(0160) 				break;
(0161) 			case LED_NEG_PULSE :
(0162) 				 led_hw_off;
(0163) 				 io_bit_ctrl.led_stat = LED_ON;
(0164) 				break;
(0165) 			/*case LED_REP_PULSE :
(0166) 				 led_j = led_ctrl.cnt;
(0167) 				 led_ctrl.stat = LED_REP_PULSE_1;
(0168) 				break;
(0169) 			case LED_REP_PULSE_1 :
(0170) 				 if ((led_j--)>(led_ctrl.cnt/2)) {
(0171) 					led_hw_on;
(0172) 				 } else {
(0173) 					if (led_j==0) led_j = led_ctrl.cnt;
(0174) 					led_hw_off;
(0175) 				 }
(0176) 				break;*/
(0177) 		}
(0178) 		
(0179) 	} while (ep->type==GR_EVENT_TYPE_NONE);
(0180) }
(0181) #else
(0182) //void GrGetNextEventTimeout_timeout_alarm(void);
(0183) // return 
(0184) //	GR_EVENT_TYPE_NONE -- not completed
(0185) //	NOT GR_EVENT_TYPE_NONE -- valid event
(0186) GR_EVENT_TYPE GrGetNextEventTimeout(GR_EVENT *ep, GR_TIMEOUT timeout)
(0187) {
_GrGetNextEventTimeout:
  k                    --> X+0
  timeout              --> X-7
  ep                   --> X-5
        194D: 10       PUSH  X
        194E: 4F       MOV   X,SP
        194F: 38 07    ADD   SP,7
(0188) 	unsigned char k;								// for circular buffer
(0189) 	static unsigned char ggnet_i;
(0190) 	//static struct timer_list ggnet_timer;
(0191) 	static unsigned int ggnet_timer;
(0192) 	ep->type = GR_EVENT_TYPE_NONE;
        1951: 52 FC    MOV   A,[X-4]
        1953: 53 0D    MOV   [__r1],A
        1955: 52 FC    MOV   A,[X-4]
        1957: 53 0B    MOV   [__r3],A
        1959: 3E 0B    MVI   A,[__r3]
        195B: 21 F8    AND   A,248
        195D: 3F 0D    MVI   [__r1],A
(0193) 	switch (io_bit_ctrl.GrGetNextEventTimeout_status) {
        195F: 5F 0D 2C MOV   [__r1],[_io_bit_ctrl]
        1962: 55 0E 00 MOV   [__r0],0
        1965: 68 0E    ASR   [__r0]
        1967: 6E 0D    RRC   [__r1]
        1969: 68 0E    ASR   [__r0]
        196B: 6E 0D    RRC   [__r1]
        196D: 68 0E    ASR   [__r0]
        196F: 6E 0D    RRC   [__r1]
        1971: 26 0D 03 AND   [__r1],3
        1974: 26 0E 00 AND   [__r0],0
        1977: 51 0D    MOV   A,[__r1]
        1979: 54 02    MOV   [X+2],A
        197B: 51 0E    MOV   A,[__r0]
        197D: 54 01    MOV   [X+1],A
        197F: 3D 01 00 CMP   [X+1],0
        1982: B0 06    JNZ   0x1989
        1984: 3D 02 00 CMP   [X+2],0
        1987: A0 21    JZ    0x19A9
        1989: 3D 01 00 CMP   [X+1],0
        198C: B0 06    JNZ   0x1993
        198E: 3D 02 01 CMP   [X+2],1
        1991: A0 28    JZ    0x19BA
        1993: 3D 01 00 CMP   [X+1],0
        1996: B0 06    JNZ   0x199D
        1998: 3D 02 02 CMP   [X+2],2
        199B: A0 32    JZ    0x19CE
        199D: 3D 01 00 CMP   [X+1],0
        19A0: B0 06    JNZ   0x19A7
        19A2: 3D 02 03 CMP   [X+2],3
        19A5: A0 4A    JZ    0x19F0
        19A7: 81 92    JMP   0x1B3A
(0194) 		case 0 :
(0195) 			 ggnet_i = 0;
        19A9: 55 29 00 MOV   [_irq_stat+1],0
(0196) 			 io_bit_ctrl.GrGetNextEventTimeout_status = 1;
        19AC: 51 2C    MOV   A,[_io_bit_ctrl]
        19AE: 21 E7    AND   A,231
        19B0: 53 0E    MOV   [__r0],A
        19B2: 2E 0E 08 OR    [__r0],8
        19B5: 5F 2C 0E MOV   [_io_bit_ctrl],[__r0]
(0197) 			break;
        19B8: 81 81    JMP   0x1B3A
(0198) 		case 1 :
(0199) 			 //ggnet_timer.data.timer_function = (p_func) GrGetNextEventTimeout_timeout_alarm;//after solve the problem, put back into alarm()
(0200) 			 //if (malarm((p_func) GrGetNextEventTimeout_timeout_alarm, TIME_OUT_INTERVAL, &ggnet_timer)>=0)// start timer, sleep regular time as TIME_OUT_INTERVAL
(0201) 			 //	io_bit_ctrl.GrGetNextEventTimeout_status = 2;
(0202) 			 ggnet_timer = 0;
        19BA: 55 2B 00 MOV   [_irq_stat+3],0
        19BD: 55 2A 00 MOV   [_irq_stat+2],0
(0203) 			 io_bit_ctrl.GrGetNextEventTimeout_status = 2;
        19C0: 51 2C    MOV   A,[_io_bit_ctrl]
        19C2: 21 E7    AND   A,231
        19C4: 53 0E    MOV   [__r0],A
        19C6: 2E 0E 10 OR    [__r0],16
        19C9: 5F 2C 0E MOV   [_io_bit_ctrl],[__r0]
(0204) 			break;
        19CC: 81 6D    JMP   0x1B3A
(0205) 		case 2 :								// wait alarm for each timeout
(0206) 			 if ((++ggnet_timer)==1024) io_bit_ctrl.GrGetNextEventTimeout_status = 3;
        19CE: 51 2B    MOV   A,[_irq_stat+3]
        19D0: 01 01    ADD   A,1
        19D2: 53 0D    MOV   [__r1],A
        19D4: 51 2A    MOV   A,[_irq_stat+2]
        19D6: 09 00    ADC   A,0
        19D8: 53 0E    MOV   [__r0],A
        19DA: 5F 2B 0D MOV   [_irq_stat+3],[__r1]
        19DD: 53 2A    MOV   [_irq_stat+2],A
        19DF: 3C 2A 04 CMP   [_irq_stat+2],4
        19E2: B1 57    JNZ   0x1B3A
        19E4: 3C 0D 00 CMP   [__r1],0
        19E7: B1 52    JNZ   0x1B3A
        19E9: 2E 2C 18 OR    [_io_bit_ctrl],24
        19EC: 51 2C    MOV   A,[_io_bit_ctrl]
(0207) 			break;
        19EE: 81 4B    JMP   0x1B3A
(0208) 		case 3 :
(0209) 			 io_bit_ctrl.GrGetNextEventTimeout_status = 0;			// check event job
        19F0: 26 2C E7 AND   [_io_bit_ctrl],231
(0210) 			 if ((k=pre_rd_cir254buf((unsigned char) ptr_events_vect.wr,(unsigned char) ptr_events_vect.rd,NR_EVENT))==255) {// no event
        19F3: 50 02    MOV   A,2
        19F5: 08       PUSH  A
        19F6: 51 2D    MOV   A,[_ptr_events_vect]
        19F8: 67       ASR   A
        19F9: 67       ASR   A
        19FA: 67       ASR   A
        19FB: 67       ASR   A
        19FC: 21 0F    AND   A,15
        19FE: 08       PUSH  A
        19FF: 51 2D    MOV   A,[_ptr_events_vect]
        1A01: 21 0F    AND   A,15
        1A03: 08       PUSH  A
        1A04: 7C 09 D6 LCALL _pre_rd_cir254buf
        1A07: 38 FD    ADD   SP,253
        1A09: 54 00    MOV   [X+0],A
        1A0B: 39 FF    CMP   A,255
        1A0D: B0 4F    JNZ   0x1A5D
(0211) 				 if (ggnet_i==timeout/TIME_OUT_INTERVAL) {
        1A0F: 5F 0D 29 MOV   [__r1],[_irq_stat+1]
        1A12: 50 00    MOV   A,0
        1A14: 08       PUSH  A
        1A15: 50 32    MOV   A,50
        1A17: 08       PUSH  A
        1A18: 52 F9    MOV   A,[X-7]
        1A1A: 08       PUSH  A
        1A1B: 52 FA    MOV   A,[X-6]
        1A1D: 08       PUSH  A
        1A1E: 7C 22 5E LCALL __divmodu_16X16_16
        1A21: 18       POP   A
        1A22: 53 0B    MOV   [__r3],A
        1A24: 18       POP   A
        1A25: 53 0C    MOV   [__r2],A
        1A27: 38 FE    ADD   SP,254
        1A29: 50 00    MOV   A,0
        1A2B: 3A 0C    CMP   A,[__r2]
        1A2D: B0 1F    JNZ   0x1A4D
        1A2F: 51 0D    MOV   A,[__r1]
        1A31: 3A 0B    CMP   A,[__r3]
        1A33: B0 19    JNZ   0x1A4D
(0212) 					 ep->type = GR_EVENT_TYPE_TIMEOUT;
        1A35: 52 FC    MOV   A,[X-4]
        1A37: 53 0D    MOV   [__r1],A
        1A39: 52 FC    MOV   A,[X-4]
        1A3B: 53 0B    MOV   [__r3],A
        1A3D: 3E 0B    MVI   A,[__r3]
        1A3F: 53 0C    MOV   [__r2],A
        1A41: 26 0C F8 AND   [__r2],248
        1A44: 2E 0C 04 OR    [__r2],4
        1A47: 51 0C    MOV   A,[__r2]
        1A49: 3F 0D    MVI   [__r1],A
(0213) 				 }
        1A4B: 80 50    JMP   0x1A9C
(0214) 				 else {
(0215) 					 ggnet_i++;
        1A4D: 76 29    INC   [_irq_stat+1]
(0216) 					 io_bit_ctrl.GrGetNextEventTimeout_status = 1;
        1A4F: 51 2C    MOV   A,[_io_bit_ctrl]
        1A51: 21 E7    AND   A,231
        1A53: 53 0E    MOV   [__r0],A
        1A55: 2E 0E 08 OR    [__r0],8
        1A58: 5F 2C 0E MOV   [_io_bit_ctrl],[__r0]
(0217) 				 }
(0218) 			 } else {							//	event occurs
        1A5B: 80 40    JMP   0x1A9C
(0219) 				*ep = events_vect[(unsigned char) ptr_events_vect.rd];
        1A5D: 52 FC    MOV   A,[X-4]
        1A5F: 53 0D    MOV   [__r1],A
        1A61: 5F 0B 2D MOV   [__r3],[_ptr_events_vect]
        1A64: 55 0C 00 MOV   [__r2],0
        1A67: 68 0C    ASR   [__r2]
        1A69: 6E 0B    RRC   [__r3]
        1A6B: 68 0C    ASR   [__r2]
        1A6D: 6E 0B    RRC   [__r3]
        1A6F: 68 0C    ASR   [__r2]
        1A71: 6E 0B    RRC   [__r3]
        1A73: 68 0C    ASR   [__r2]
        1A75: 6E 0B    RRC   [__r3]
        1A77: 26 0B 0F AND   [__r3],15
        1A7A: 26 0C 00 AND   [__r2],0
        1A7D: 06 0B 2E ADD   [__r3],46
        1A80: 0E 0C 00 ADC   [__r2],0
        1A83: 3E 0B    MVI   A,[__r3]
        1A85: 3F 0D    MVI   [__r1],A
(0220) 				ptr_events_vect.rd = k;
        1A87: 51 2D    MOV   A,[_ptr_events_vect]
        1A89: 21 0F    AND   A,15
        1A8B: 53 0E    MOV   [__r0],A
        1A8D: 52 00    MOV   A,[X+0]
        1A8F: 21 0F    AND   A,15
        1A91: 64       ASL   A
        1A92: 64       ASL   A
        1A93: 64       ASL   A
        1A94: 64       ASL   A
        1A95: 21 F0    AND   A,240
        1A97: 2C 0E    OR    [__r0],A
        1A99: 5F 2D 0E MOV   [_ptr_events_vect],[__r0]
(0221) 			 }
(0222) 
(0223) 			 // buzzer control job
(0224) 			 switch (io_bit_ctrl.buzzer_stat) {
        1A9C: 5F 0D 2C MOV   [__r1],[_io_bit_ctrl]
        1A9F: 55 0E 00 MOV   [__r0],0
        1AA2: 68 0E    ASR   [__r0]
        1AA4: 6E 0D    RRC   [__r1]
        1AA6: 68 0E    ASR   [__r0]
        1AA8: 6E 0D    RRC   [__r1]
        1AAA: 26 0D 01 AND   [__r1],1
        1AAD: 26 0E 00 AND   [__r0],0
        1AB0: 51 0D    MOV   A,[__r1]
        1AB2: 54 04    MOV   [X+4],A
        1AB4: 51 0E    MOV   A,[__r0]
        1AB6: 54 03    MOV   [X+3],A
        1AB8: 3D 03 00 CMP   [X+3],0
        1ABB: B0 06    JNZ   0x1AC2
        1ABD: 3D 04 00 CMP   [X+4],0
        1AC0: A0 0D    JZ    0x1ACE
        1AC2: 3D 03 00 CMP   [X+3],0
        1AC5: B0 06    JNZ   0x1ACC
        1AC7: 3D 04 01 CMP   [X+4],1
        1ACA: A0 08    JZ    0x1AD3
        1ACC: 80 0C    JMP   0x1AD9
(0225) 				case BUZZER_OFF :
(0226) 					 buz_hw_off;
        1ACE: 41 08 F7 AND   REG[8],247
(0227) 					break;
        1AD1: 80 07    JMP   0x1AD9
(0228) 				case BUZZER_POS_PULSE :
(0229) 					 buz_hw_on;
        1AD3: 43 08 08 OR    REG[8],8
(0230) 					 //io_bit_ctrl.buzzer_stat = BUZZER_POS_PULSE_1;
(0231) 					 io_bit_ctrl.buzzer_stat = BUZZER_OFF;
        1AD6: 26 2C FB AND   [_io_bit_ctrl],251
(0232) 					break;
(0233) /*				case BUZZER_POS_PULSE_1 :
(0234) 					 k = timeout/TIME_OUT_INTERVAL;
(0235) 					 if (k>2) {					// 4 as 4 X 50mSec = 200mSec
(0236) 						 if (ggnet_i>=2) io_bit_ctrl.buzzer_stat = BUZZER_OFF;
(0237) 					 } else {
(0238) 						 if (ggnet_i>=k) io_bit_ctrl.buzzer_stat = BUZZER_OFF;
(0239) 					 }
(0240) 					break;*/
(0241) 				/*case BUZZER_REP_PULSE :
(0242) 					 buz_j = buzzer_ctrl.cnt;
(0243) 					 buzzer_ctrl.stat = BUZZER_REP_PULSE_1;
(0244) 					break;
(0245) 				case BUZZER_REP_PULSE_1 :
(0246) 					 if ((buz_j--)>(buzzer_ctrl.cnt/2)) {
(0247) 						buz_hw_on;
(0248) 					 } else {
(0249) 						if (buz_j==0) buz_j = buzzer_ctrl.cnt;
(0250) 						buz_hw_off;
(0251) 					 }
(0252) 					break;*/
(0253) 			 }
(0254) 			
(0255) 			 // led control job
(0256) 			 switch (io_bit_ctrl.led_stat) {
        1AD9: 5F 0D 2C MOV   [__r1],[_io_bit_ctrl]
        1ADC: 55 0E 00 MOV   [__r0],0
        1ADF: 26 0D 03 AND   [__r1],3
        1AE2: 26 0E 00 AND   [__r0],0
        1AE5: 51 0D    MOV   A,[__r1]
        1AE7: 54 06    MOV   [X+6],A
        1AE9: 51 0E    MOV   A,[__r0]
        1AEB: 54 05    MOV   [X+5],A
        1AED: 3D 05 00 CMP   [X+5],0
        1AF0: B0 06    JNZ   0x1AF7
        1AF2: 3D 06 00 CMP   [X+6],0
        1AF5: A0 21    JZ    0x1B17
        1AF7: 3D 05 00 CMP   [X+5],0
        1AFA: B0 06    JNZ   0x1B01
        1AFC: 3D 06 01 CMP   [X+6],1
        1AFF: A0 1C    JZ    0x1B1C
        1B01: 3D 05 00 CMP   [X+5],0
        1B04: B0 06    JNZ   0x1B0B
        1B06: 3D 06 02 CMP   [X+6],2
        1B09: A0 1C    JZ    0x1B26
        1B0B: 3D 05 00 CMP   [X+5],0
        1B0E: B0 06    JNZ   0x1B15
        1B10: 3D 06 03 CMP   [X+6],3
        1B13: A0 17    JZ    0x1B2B
        1B15: 80 24    JMP   0x1B3A
(0257) 				case LED_OFF :
(0258) 					 led_hw_off;
        1B17: 43 08 80 OR    REG[8],128
(0259) 					break;
        1B1A: 80 1F    JMP   0x1B3A
(0260) 				case LED_POS_PULSE :
(0261) 					 led_hw_on;
        1B1C: 41 08 7F AND   REG[8],127
(0262) 					 io_bit_ctrl.led_stat = LED_OFF;
        1B1F: 26 2C FC AND   [_io_bit_ctrl],252
        1B22: 51 2C    MOV   A,[_io_bit_ctrl]
(0263) 					break;
        1B24: 80 15    JMP   0x1B3A
(0264) 				case LED_ON :
(0265) 					 led_hw_on;
        1B26: 41 08 7F AND   REG[8],127
(0266) 					break;
        1B29: 80 10    JMP   0x1B3A
(0267) 				case LED_NEG_PULSE :
(0268) 					 led_hw_off;
        1B2B: 43 08 80 OR    REG[8],128
(0269) 					 io_bit_ctrl.led_stat = LED_ON;
        1B2E: 51 2C    MOV   A,[_io_bit_ctrl]
        1B30: 21 FC    AND   A,252
        1B32: 53 0E    MOV   [__r0],A
        1B34: 2E 0E 02 OR    [__r0],2
        1B37: 5F 2C 0E MOV   [_io_bit_ctrl],[__r0]
(0270) 					break;
(0271) 				/*case LED_REP_PULSE :
(0272) 					 ggnet_led_j = led_ctrl.cnt;
(0273) 					 led_ctrl.stat = LED_REP_PULSE_1;
(0274) 					break;
(0275) 				case LED_REP_PULSE_1 :
(0276) 					 if ((ggnet_led_j--)>(led_ctrl.cnt/2)) {
(0277) 						led_hw_on;
(0278) 					 } else {
(0279) 						if (ggnet_led_j==0) ggnet_led_j = led_ctrl.cnt;
(0280) 						led_hw_off;
(0281) 					 }
(0282) 					break;*/
(0283) 			 }
(0284) 			
(0285) #if (ADD_LED>0)
(0286) 			 // additional led control job
(0287) 			 switch (add_led.first) {
(0288) 				case LED_OFF :
(0289) 					 led_1st_hw_off;
(0290) 					break;
(0291) 				case LED_POS_PULSE :
(0292) 					 led_1st_hw_on;
(0293) 					 add_led.first = LED_OFF;
(0294) 					break;
(0295) 				case LED_ON :
(0296) 					 led_1st_hw_on;
(0297) 					break;
(0298) 				case LED_NEG_PULSE :
(0299) 					 led_1st_hw_off;
(0300) 					 add_led.first = LED_ON;
(0301) 					break;
(0302) 			 }
(0303) 	#if (ADD_LED>1)
(0304) 			 switch (add_led.second) {
(0305) 				case LED_OFF :
(0306) 					 led_2nd_hw_off;
(0307) 					break;
(0308) 				case LED_POS_PULSE :
(0309) 					 led_2nd_hw_on;
(0310) 					 add_led.second = LED_OFF;
(0311) 					break;
(0312) 				case LED_ON :
(0313) 					 led_2nd_hw_on;
(0314) 					break;
(0315) 				case LED_NEG_PULSE :
(0316) 					 led_2nd_hw_off;
(0317) 					 add_led.second = LED_ON;
(0318) 					break;
(0319) 			 }
(0320) 	#endif
(0321) 	#if (ADD_LED>2)
(0322) 			 switch (add_led.third) {
(0323) 				case LED_OFF :
(0324) 					 led_3rd_hw_off;
(0325) 					break;
(0326) 				case LED_POS_PULSE :
(0327) 					 led_3rd_hw_on;
(0328) 					 add_led.third = LED_OFF;
(0329) 					break;
(0330) 				case LED_ON :
(0331) 					 led_3rd_hw_on;
(0332) 					break;
(0333) 				case LED_NEG_PULSE :
(0334) 					 led_3rd_hw_off;
(0335) 					 add_led.third = LED_ON;
(0336) 					break;
(0337) 			 }
(0338) 	#endif
(0339) 			break;
(0340) #endif
(0341) 	}
(0342) 	return ep->type;
        1B3A: 52 FC    MOV   A,[X-4]
        1B3C: 53 0D    MOV   [__r1],A
        1B3E: 3E 0D    MVI   A,[__r1]
        1B40: 21 07    AND   A,7
        1B42: 38 F9    ADD   SP,249
        1B44: 20       POP   X
        1B45: 7F       RET   
(0343) }
(0344) //void GrGetNextEventTimeout_timeout_alarm(void)
(0345) //{
(0346) //	io_bit_ctrl.GrGetNextEventTimeout_status = 3;
(0347) //}
(0348) #endif
(0349) 
(0350) #if (GUI_LCD==1)
(0351) /*
(0352)  * Draw a text string in the specified drawable using the
(0353)  * specified graphics context.
(0354)  *
(0355)  * flags
(0356)  *	bit 0 - '0' as high light off, '1' as high light on
(0357)  */
(0358) void
(0359) GrText(GR_COORD x, GR_COORD y, const unsigned char* str_ROM, unsigned char* str_RAM, GR_COUNT count, GR_TEXTFLAGS flags)
(0360) {
_GrText:
  i                    --> X+0
  flags                --> X-11
  count                --> X-10
  str_RAM              --> X-9
  str_ROM              --> X-7
  y                    --> X-5
  x                    --> X-4
        1B46: 10       PUSH  X
        1B47: 4F       MOV   X,SP
        1B48: 38 01    ADD   SP,1
(0361) 	unsigned char i;
(0362) 	i = count + x;
        1B4A: 52 F6    MOV   A,[X-10]
        1B4C: 03 FC    ADD   A,[X-4]
        1B4E: 54 00    MOV   [X+0],A
(0363) 	
(0364) 	if (str_ROM==0) {								// if future has more better solution, throw aways this method
        1B50: 3D F9 00 CMP   [X-7],0
        1B53: B0 4F    JNZ   0x1BA3
        1B55: 3D FA 00 CMP   [X-6],0
        1B58: B0 4A    JNZ   0x1BA3
(0365) 		for (;x<i;x++,str_RAM++)
        1B5A: 80 1D    JMP   0x1B78
(0366) 			GrTextDrv(x, y, *str_RAM, flags);
        1B5C: 52 F5    MOV   A,[X-11]
        1B5E: 08       PUSH  A
        1B5F: 52 F8    MOV   A,[X-8]
        1B61: 53 0D    MOV   [__r1],A
        1B63: 3E 0D    MVI   A,[__r1]
        1B65: 08       PUSH  A
        1B66: 52 FB    MOV   A,[X-5]
        1B68: 08       PUSH  A
        1B69: 52 FC    MOV   A,[X-4]
        1B6B: 08       PUSH  A
        1B6C: 7C 20 87 LCALL _GrTextDrv
        1B6F: 38 FC    ADD   SP,252
        1B71: 77 FC    INC   [X-4]
        1B73: 77 F8    INC   [X-8]
        1B75: 0F F7 00 ADC   [X-9],0
        1B78: 52 FC    MOV   A,[X-4]
        1B7A: 3B 00    CMP   A,[X+0]
        1B7C: A0 03    JZ    0x1B80
        1B7E: CF DD    JC    0x1B5C
(0367) 	} else {
        1B80: 80 2A    JMP   0x1BAB
(0368) 		for (;x<i;x++,str_ROM++)
(0369) 			GrTextDrv(x, y, *str_ROM, flags);
        1B82: 52 F5    MOV   A,[X-11]
        1B84: 08       PUSH  A
        1B85: 52 FA    MOV   A,[X-6]
        1B87: 53 0D    MOV   [__r1],A
        1B89: 52 F9    MOV   A,[X-7]
        1B8B: 10       PUSH  X
        1B8C: 58 0D    MOV   X,[__r1]
        1B8E: 28       ROMX  
        1B8F: 20       POP   X
        1B90: 08       PUSH  A
        1B91: 52 FB    MOV   A,[X-5]
        1B93: 08       PUSH  A
        1B94: 52 FC    MOV   A,[X-4]
        1B96: 08       PUSH  A
        1B97: 7C 20 87 LCALL _GrTextDrv
        1B9A: 38 FC    ADD   SP,252
        1B9C: 77 FC    INC   [X-4]
        1B9E: 77 FA    INC   [X-6]
        1BA0: 0F F9 00 ADC   [X-7],0
        1BA3: 52 FC    MOV   A,[X-4]
        1BA5: 3B 00    CMP   A,[X+0]
        1BA7: A0 03    JZ    0x1BAB
        1BA9: CF D8    JC    0x1B82
(0370) 	}
(0371) }
        1BAB: 38 FF    ADD   SP,255
        1BAD: 20       POP   X
        1BAE: 7F       RET   
FILE: .\srvmain.c
(0001) /*
(0002)  * Copyright (c) 1999, 2000, 2001, 2003 Greg Haerr <greg@censoft.com>
(0003)  * Portions Copyright (c) 2002 by Koninklijke Philips Electronics N.V.
(0004)  * Copyright (c) 1991 David I. Bell
(0005)  * Copyright (c) 2004 cheng chung yan <chungyan5@hkem.com / yan@amonics.com> for 8-bit system running in linlike8
(0006)  * Permission is granted to use, distribute, or modify this source,
(0007)  * provided that this copyright notice remains intact.
(0008)  *
(0009)  * Main module of graphics server.
(0010)  */
(0011) 
(0012) #include "app.h"									// linlike8 os
(0013) 
(0014) #include "sched.h"
(0015) #include "nano-X.h"									// NR_EVENT
(0016) #include "device.h"									// scr_open()
(0017) #include "timer.h"
(0018) 
(0019) extern void io_open(void);
(0020) 
(0021) void mwlike8_server(void)
(0022) {
_mwlike8_server:
  i                    --> X+0
        1BAF: 10       PUSH  X
        1BB0: 4F       MOV   X,SP
        1BB1: 38 01    ADD   SP,1
(0023) 	
(0024) #if (KB_MOD==1)
(0025) 	// keyboard events
(0026) 	//=========================================================
(0027) 	unsigned char i;
(0028) #endif
(0029) 
(0030) 		// init this process
(0031) #if (GUI_LCD==1)
(0032) 	scr_open();									// hardware init.
        1BB3: 7C 1F 64 LCALL _scr_open
(0033) #endif
(0034) 	io_open();
        1BB6: 7C 19 43 LCALL _io_open
        1BB9: 80 04    JMP   0x1BBE
(0035) 	
(0036) #if (AUTO_ZERO==0)
(0037) 	unsigned char k;								// mwlike8 server init.
(0038) 	wr_ptr_events_vect = 0;
(0039) 	rd_ptr_events_vect = 0;
(0040) 	for (k=0;i<NR_EVENT;k++) events_vect[i].type = GR_EVENT_TYPE_NONE;
(0041) #endif
(0042) 
(0043) 		// main job of this process
(0044) 		//	detect user input
(0045) 	while (1) {
(0046) 		
(0047) 		// linlike8 system
(0048) 		//******************************************
(0049) 		
(0050) 		// appl.
(0051) 		//******************************************
(0052) 		
(0053) 		// system context switch
(0054) 		//******************************************
(0055) 		sched_yield();								// any time should switch away to let other process to run, unless somethign need to run in this process0
        1BBB: 7C 14 BB LCALL _schedule
        1BBE: 8F FC    JMP   0x1BBB
(0056) 	}
(0057) }
        1BC0: 38 FF    ADD   SP,255
        1BC2: 20       POP   X
        1BC3: 7F       RET   
        1BC4: 10       PUSH  X
        1BC5: 4F       MOV   X,SP
        1BC6: 55 0E 01 MOV   [__r0],1
        1BC9: 52 FC    MOV   A,[X-4]
        1BCB: 21 07    AND   A,7
        1BCD: A0 06    JZ    0x1BD4
        1BCF: 65 0E    ASL   [__r0]
        1BD1: 78       DEC   A
        1BD2: BF FC    JNZ   0x1BCF
        1BD4: 51 27    MOV   A,[_softirq_vec]
        1BD6: 2A 0E    OR    A,[__r0]
        1BD8: 53 27    MOV   [_softirq_vec],A
        1BDA: 20       POP   X
        1BDB: 7F       RET   
FILE: .\time.c
(0001) /*
(0002)  *	arch/cypress_psoc/kernel/time.c
(0003)  *
(0004)  *	23-04-2004	yan	create this following linux arch but using cypress psoc hardware related codes
(0005)  *
(0006)  */
(0007) 
(0008) #include <m8c.h>									// part specific constants and macros
(0009) #include "PSoCAPI.h"									// PSoC API definitions for all User Modules
(0010) 
(0011) #include "app.h"
(0012) #include "sched.h"
(0013) #include "interrupt.h"									// do_softirq
(0014) #include "gpio.h"									// gpio_var.timer_10msec_f
(0015) 
(0016) extern void do_IRQ(void);
(0017) 
(0018) #if (TIMER_MOD==1)
(0019) void time_init(void)
(0020) {
(0021)         Timer8_1_EnableInt();								// start 8-bit Timer, 5mS for one interrupt
_time_init:
        1BDC: 10       PUSH  X
        1BDD: 7C 09 6E LCALL 0x096E
(0022)         Timer8_1_Start();
        1BE0: 7C 09 76 LCALL 0x0976
        1BE3: 20       POP   X
(0023) }
        1BE4: 7F       RET   
(0024) #endif
(0025) 
(0026) #pragma	interrupt_handler	timer_interrupt						// shouald add this isr name at boot.asm from PSoC Designer
(0027) void timer_interrupt(void)								// timer interrupt
(0028) {											//	this code must under disable interrupt state in cypress_psoc
_timer_interrupt:
        1BE5: 08       PUSH  A
        1BE6: 51 0E    MOV   A,[__r0]
        1BE8: 08       PUSH  A
        1BE9: 51 0D    MOV   A,[__r1]
        1BEB: 08       PUSH  A
        1BEC: 51 0C    MOV   A,[__r2]
        1BEE: 08       PUSH  A
        1BEF: 51 0B    MOV   A,[__r3]
        1BF1: 08       PUSH  A
        1BF2: 51 0A    MOV   A,[__r4]
        1BF4: 08       PUSH  A
        1BF5: 51 09    MOV   A,[__r5]
        1BF7: 08       PUSH  A
        1BF8: 51 08    MOV   A,[__r6]
        1BFA: 08       PUSH  A
        1BFB: 51 07    MOV   A,[__r7]
        1BFD: 08       PUSH  A
        1BFE: 51 06    MOV   A,[__r8]
        1C00: 08       PUSH  A
        1C01: 51 05    MOV   A,[__r9]
        1C03: 08       PUSH  A
        1C04: 51 04    MOV   A,[__r10]
        1C06: 08       PUSH  A
        1C07: 51 03    MOV   A,[__r11]
        1C09: 08       PUSH  A
        1C0A: 51 02    MOV   A,[__rX]
        1C0C: 08       PUSH  A
        1C0D: 51 01    MOV   A,[__rY]
        1C0F: 08       PUSH  A
        1C10: 51 00    MOV   A,[NO_SHADOW]
        1C12: 08       PUSH  A
(0029) #if (TIMER_MOD==1)
(0030) 	if (gpio_var.timer_10msec_f) {							//	since reduce usage of cypress digital block, using a timer8, that it only support to 5mSec each interrupt, but i need 10mSec
        1C13: 51 0F    MOV   A,[_gpio_var]
        1C15: 21 01    AND   A,1
        1C17: A0 47    JZ    0x1C5F
(0031) 	//if (chk_timer_int_ctrl) {
(0032) 		//inv_timer_int_ctrl;							
(0033) 		gpio_var.timer_10msec_f ^= 1;						//	must do it 1st, since it will switch to other process
        1C19: 5F 0D 0F MOV   [__r1],[_gpio_var]
        1C1C: 55 0E 00 MOV   [__r0],0
        1C1F: 55 0B 0F MOV   [__r3],15
        1C22: 51 0D    MOV   A,[__r1]
        1C24: 21 FE    AND   A,254
        1C26: 53 09    MOV   [__r5],A
        1C28: 50 00    MOV   A,0
        1C2A: 21 FF    AND   A,255
        1C2C: 53 0A    MOV   [__r4],A
        1C2E: 26 0D 01 AND   [__r1],1
        1C31: 26 0E 00 AND   [__r0],0
        1C34: 36 0D 01 XOR   [__r1],1
        1C37: 36 0E 00 XOR   [__r0],0
        1C3A: 55 0E 00 MOV   [__r0],0
        1C3D: 26 0D 01 AND   [__r1],1
        1C40: 26 0E 00 AND   [__r0],0
        1C43: 26 0D 01 AND   [__r1],1
        1C46: 26 0E 00 AND   [__r0],0
        1C49: 51 09    MOV   A,[__r5]
        1C4B: 2A 0D    OR    A,[__r1]
        1C4D: 53 0D    MOV   [__r1],A
        1C4F: 51 0A    MOV   A,[__r4]
        1C51: 2A 0E    OR    A,[__r0]
        1C53: 51 0D    MOV   A,[__r1]
        1C55: 3F 0B    MVI   [__r3],A
(0034) 		do_timer();								//	should in do_timer_interrupt(), timer interrupt code, need to complete in short time
        1C57: 7C 1C E4 LCALL _do_timer
(0035) 		do_softirq();								//	botton half of interrupt, if needed, enable interrupt in 2nd-half
        1C5A: 7C 19 16 LCALL _do_softirq
(0036) 	} else gpio_var.timer_10msec_f ^= 1;
        1C5D: 80 3F    JMP   0x1C9D
        1C5F: 5F 0D 0F MOV   [__r1],[_gpio_var]
        1C62: 55 0E 00 MOV   [__r0],0
        1C65: 55 0B 0F MOV   [__r3],15
        1C68: 51 0D    MOV   A,[__r1]
        1C6A: 21 FE    AND   A,254
        1C6C: 53 09    MOV   [__r5],A
        1C6E: 50 00    MOV   A,0
        1C70: 21 FF    AND   A,255
        1C72: 53 0A    MOV   [__r4],A
        1C74: 26 0D 01 AND   [__r1],1
        1C77: 26 0E 00 AND   [__r0],0
        1C7A: 36 0D 01 XOR   [__r1],1
        1C7D: 36 0E 00 XOR   [__r0],0
        1C80: 55 0E 00 MOV   [__r0],0
        1C83: 26 0D 01 AND   [__r1],1
        1C86: 26 0E 00 AND   [__r0],0
        1C89: 26 0D 01 AND   [__r1],1
        1C8C: 26 0E 00 AND   [__r0],0
        1C8F: 51 09    MOV   A,[__r5]
        1C91: 2A 0D    OR    A,[__r1]
        1C93: 53 0D    MOV   [__r1],A
        1C95: 51 0A    MOV   A,[__r4]
        1C97: 2A 0E    OR    A,[__r0]
        1C99: 51 0D    MOV   A,[__r1]
        1C9B: 3F 0B    MVI   [__r3],A
(0037) 	//} else inv_timer_int_ctrl;
(0038) #endif
(0039) }											//	auto enable interrupt again after isr in cypress_psoc
        1C9D: 18       POP   A
        1C9E: 53 00    MOV   [NO_SHADOW],A
        1CA0: 18       POP   A
        1CA1: 53 01    MOV   [__rY],A
        1CA3: 18       POP   A
        1CA4: 53 02    MOV   [__rX],A
        1CA6: 18       POP   A
        1CA7: 53 03    MOV   [__r11],A
        1CA9: 18       POP   A
        1CAA: 53 04    MOV   [__r10],A
        1CAC: 18       POP   A
        1CAD: 53 05    MOV   [__r9],A
        1CAF: 18       POP   A
        1CB0: 53 06    MOV   [__r8],A
        1CB2: 18       POP   A
        1CB3: 53 07    MOV   [__r7],A
        1CB5: 18       POP   A
        1CB6: 53 08    MOV   [__r6],A
        1CB8: 18       POP   A
        1CB9: 53 09    MOV   [__r5],A
        1CBB: 18       POP   A
        1CBC: 53 0A    MOV   [__r4],A
        1CBE: 18       POP   A
        1CBF: 53 0B    MOV   [__r3],A
        1CC1: 18       POP   A
        1CC2: 53 0C    MOV   [__r2],A
        1CC4: 18       POP   A
        1CC5: 53 0D    MOV   [__r1],A
        1CC7: 18       POP   A
        1CC8: 53 0E    MOV   [__r0],A
        1CCA: 18       POP   A
        1CCB: 7E       RETI  
        1CCC: 10       PUSH  X
        1CCD: 4F       MOV   X,SP
        1CCE: 55 0E 01 MOV   [__r0],1
        1CD1: 52 FC    MOV   A,[X-4]
        1CD3: 21 07    AND   A,7
        1CD5: A0 06    JZ    0x1CDC
        1CD7: 65 0E    ASL   [__r0]
        1CD9: 78       DEC   A
        1CDA: BF FC    JNZ   0x1CD7
        1CDC: 51 27    MOV   A,[_softirq_vec]
        1CDE: 2A 0E    OR    A,[__r0]
        1CE0: 53 27    MOV   [_softirq_vec],A
        1CE2: 20       POP   X
        1CE3: 7F       RET   
FILE: .\timer.c
(0001) /*
(0002)  *	kernel/timer.c
(0003)  *
(0004)  *	23-04-2004	yan	create this following linux
(0005)  *	17-06-2004	yan	modify timer structure from 6 bytes to 4 bytes only to reduce RAM usage, then more timer variables can reduce more RAM
(0006)  *	27-07-2004	yan	max. timer delay or sleep is 255*10mSec = 2.55 Sec, then reuce more RAM : timer counter from 16-bit to 8-bit
(0007)  *
(0008)  */
(0009) 
(0010) #include "app.h"
(0011) #include "sched.h"									// schedule_timeout()
(0012) #include "current.h"									// current
(0013) #include "interrupt.h"									// mark_bh()
(0014) #include "timer.h"									// timer_list
(0015) #include "system.h"									// sti()             
(0016) #if (KB_MOD==1)
(0017) 	#include "kb.h"									// kb hw driver(application dependent, so diff. appl. has diff. kb.h)
(0018) 	#include "gpio.h"
(0019) 	#include "gpio_kb_app.h"							// kb app.
(0020) #endif
(0021) 
(0022) #if (TIMER_MOD==1)
(0023) 
(0024) #if (AUTO_ZERO==1)
(0025) unsigned char jiffies;
(0026) #else
(0027) unsigned char jiffies = 0;								// 9-bit, so can handle 2^8 * 10mSec =  days; if type is be modified, change MAX_JIFFY_OFFSET also in include/linlike8/time.h
(0028) #endif
(0029) 
(0030) #if (NR_TIMER_OUT>0)
(0031) struct timer_list* timer_vector[NR_TIMER_OUT];
(0032) #endif
(0033) 
(0034) #if (AUTO_ZERO==0)
(0035) void init_timer(void)
(0036) {
(0037) 	unsigned char i;
(0038) 	for (i=0;i<NR_TIMER_OUT;i++)							// clr all to zero, indicating empty timer.
(0039) 		timer_vector[i] = 0;
(0040) }
(0041) #endif
(0042) 
(0043) void do_timer(void)
(0044) {
(0045) 	jiffies++;									// make sure it is running in atomic, so make sure no other interrupt here
_do_timer:
        1CE4: 76 36    INC   [_jiffies]
(0046) 	mark_bh(TIMER_BH);								// enable bh timer task
        1CE6: 50 00    MOV   A,0
        1CE8: 08       PUSH  A
        1CE9: 9F E1    CALL  0x1CCC
        1CEB: 38 FF    ADD   SP,255
(0047) }
        1CED: 7F       RET   
(0048) 
(0049) void timer_softirq(void)
(0050) {
_timer_softirq:
  i                    --> X+1
  timer_event          --> X+1
  i                    --> X+0
        1CEE: 10       PUSH  X
        1CEF: 4F       MOV   X,SP
        1CF0: 38 04    ADD   SP,4
(0051) #if (NR_TIMER_OUT>0)
(0052) 	unsigned char i;								// common variabe
(0053) 	
(0054) 		// this timer_softirq source code should do not longer than 10mSec, since each timer interrupt event is each 10mSec
(0055) 		//******************************************************************************
(0056) 		
(0057) 		// run_timer_list();	=> chk timer event
(0058) 		//******************************************************************************
(0059) 	{
(0060) //	if (gpio_var.timer_semop==0) {
(0061) //		gpio_var.timer_semop = 1;
(0062) 	for (i=0;i<NR_TIMER_OUT;i++)							// find out non-empty place
        1CF2: 56 00 00 MOV   [X+0],0
        1CF5: 80 A2    JMP   0x1D98
(0063) 		if (timer_vector[i]!=0) {
        1CF7: 52 00    MOV   A,[X+0]
        1CF9: 53 0D    MOV   [__r1],A
        1CFB: 55 0E 00 MOV   [__r0],0
        1CFE: 65 0D    ASL   [__r1]
        1D00: 6B 0E    RLC   [__r0]
        1D02: 06 0D 30 ADD   [__r1],48
        1D05: 0E 0E 00 ADC   [__r0],0
        1D08: 3E 0D    MVI   A,[__r1]
        1D0A: 53 0E    MOV   [__r0],A
        1D0C: 3E 0D    MVI   A,[__r1]
        1D0E: 3C 0E 00 CMP   [__r0],0
        1D11: B0 05    JNZ   0x1D17
        1D13: 39 00    CMP   A,0
        1D15: A0 80    JZ    0x1D96
(0064) 			struct timer_list timer_event = *timer_vector[i];
        1D17: 5A 0D    MOV   [__r1],X
        1D19: 06 0D 01 ADD   [__r1],1
        1D1C: 52 00    MOV   A,[X+0]
        1D1E: 53 0B    MOV   [__r3],A
        1D20: 55 0C 00 MOV   [__r2],0
        1D23: 65 0B    ASL   [__r3]
        1D25: 6B 0C    RLC   [__r2]
        1D27: 06 0B 30 ADD   [__r3],48
        1D2A: 0E 0C 00 ADC   [__r2],0
        1D2D: 3E 0B    MVI   A,[__r3]
        1D2F: 3E 0B    MVI   A,[__r3]
        1D31: 53 0B    MOV   [__r3],A
        1D33: 3E 0B    MVI   A,[__r3]
        1D35: 3F 0D    MVI   [__r1],A
        1D37: 3E 0B    MVI   A,[__r3]
        1D39: 3F 0D    MVI   [__r1],A
        1D3B: 3E 0B    MVI   A,[__r3]
        1D3D: 3F 0D    MVI   [__r1],A
(0065) 			if (timer_event.expires==jiffies) {
        1D3F: 52 01    MOV   A,[X+1]
        1D41: 3A 36    CMP   A,[_jiffies]
        1D43: B0 52    JNZ   0x1D96
(0066) 				if ((timer_event.data.timer_data&0xff00)==0xff00) wake_up_process(((struct task_struct*) (&task[(timer_event.data.timer_data&0x00ff)]) ));// related to sched.c only
        1D45: 52 03    MOV   A,[X+3]
        1D47: 21 00    AND   A,0
        1D49: 53 0D    MOV   [__r1],A
        1D4B: 52 02    MOV   A,[X+2]
        1D4D: 21 FF    AND   A,255
        1D4F: 39 FF    CMP   A,255
        1D51: B0 22    JNZ   0x1D74
        1D53: 3C 0D 00 CMP   [__r1],0
        1D56: B0 1D    JNZ   0x1D74
        1D58: 52 03    MOV   A,[X+3]
        1D5A: 21 FF    AND   A,255
        1D5C: 53 0D    MOV   [__r1],A
        1D5E: 52 02    MOV   A,[X+2]
        1D60: 21 00    AND   A,0
        1D62: 53 0E    MOV   [__r0],A
        1D64: 65 0D    ASL   [__r1]
        1D66: 6B 0E    RLC   [__r0]
        1D68: 06 0D 14 ADD   [__r1],20
        1D6B: 0E 0E 00 ADC   [__r0],0
        1D6E: 50 00    MOV   A,0
        1D70: 3F 0D    MVI   [__r1],A
        1D72: 80 23    JMP   0x1D96
(0067) //				if ((struct timer_list timer_vector[i])->data!=0) wake_up_process(((struct task_struct*) ((struct timer_list timer_vector[i])->data)));
(0068) 				else {
(0069) 					timer_event.data.timer_function();
        1D74: 52 03    MOV   A,[X+3]
        1D76: 53 0D    MOV   [__r1],A
        1D78: 52 02    MOV   A,[X+2]
        1D7A: 53 0E    MOV   [__r0],A
        1D7C: 7C 21 99 LCALL __plcall
(0070) 					del_timer(i);
        1D7F: 52 00    MOV   A,[X+0]
        1D81: 53 0D    MOV   [__r1],A
        1D83: 55 0E 00 MOV   [__r0],0
        1D86: 65 0D    ASL   [__r1]
        1D88: 6B 0E    RLC   [__r0]
        1D8A: 06 0D 30 ADD   [__r1],48
        1D8D: 0E 0E 00 ADC   [__r0],0
        1D90: 76 0D    INC   [__r1]
        1D92: 50 00    MOV   A,0
        1D94: 3F 0D    MVI   [__r1],A
        1D96: 77 00    INC   [X+0]
        1D98: 3D 00 03 CMP   [X+0],3
        1D9B: A0 03    JZ    0x1D9F
        1D9D: CF 59    JC    0x1CF7
(0071) 				}
(0072) 				//after timer interrupt, should have schedule again for updated process to run; do it in future; now just let programmer to yield other process, then run into this process again
(0073) 			}
(0074) 		}
(0075) 		
(0076) //		gpio_var.timer_semop = 0;
(0077) //	}
(0078) 	}
(0079) #endif
(0080) 		
(0081) #if (KB_MOD==1)
(0082) 
(0083) 	if ((++gpio_var.scan_key_timeout)%7) {
        1D9F: 51 0F    MOV   A,[_gpio_var]
        1DA1: 67       ASR   A
        1DA2: 67       ASR   A
        1DA3: 67       ASR   A
        1DA4: 67       ASR   A
        1DA5: 67       ASR   A
        1DA6: 21 07    AND   A,7
        1DA8: 53 0E    MOV   [__r0],A
        1DAA: 26 0E 07 AND   [__r0],7
        1DAD: 06 0E 01 ADD   [__r0],1
        1DB0: 5F 0D 0E MOV   [__r1],[__r0]
        1DB3: 55 0E 00 MOV   [__r0],0
        1DB6: 26 0D 07 AND   [__r1],7
        1DB9: 26 0E 00 AND   [__r0],0
        1DBC: 55 0B 0F MOV   [__r3],15
        1DBF: 5F 09 0F MOV   [__r5],[_gpio_var]
        1DC2: 55 0A 00 MOV   [__r4],0
        1DC5: 26 09 1F AND   [__r5],31
        1DC8: 26 0A FF AND   [__r4],255
        1DCB: 5F 07 0D MOV   [__r7],[__r1]
        1DCE: 5F 08 0E MOV   [__r6],[__r0]
        1DD1: 65 07    ASL   [__r7]
        1DD3: 6B 08    RLC   [__r6]
        1DD5: 65 07    ASL   [__r7]
        1DD7: 6B 08    RLC   [__r6]
        1DD9: 65 07    ASL   [__r7]
        1DDB: 6B 08    RLC   [__r6]
        1DDD: 65 07    ASL   [__r7]
        1DDF: 6B 08    RLC   [__r6]
        1DE1: 65 07    ASL   [__r7]
        1DE3: 6B 08    RLC   [__r6]
        1DE5: 26 07 E0 AND   [__r7],224
        1DE8: 26 08 00 AND   [__r6],0
        1DEB: 51 07    MOV   A,[__r7]
        1DED: 2C 09    OR    [__r5],A
        1DEF: 51 08    MOV   A,[__r6]
        1DF1: 2C 0A    OR    [__r4],A
        1DF3: 51 09    MOV   A,[__r5]
        1DF5: 3F 0B    MVI   [__r3],A
        1DF7: 50 00    MOV   A,0
        1DF9: 08       PUSH  A
        1DFA: 50 07    MOV   A,7
        1DFC: 08       PUSH  A
        1DFD: 51 0E    MOV   A,[__r0]
        1DFF: 08       PUSH  A
        1E00: 51 0D    MOV   A,[__r1]
        1E02: 08       PUSH  A
        1E03: 7C 21 A9 LCALL __divmod_16X16_16
        1E06: 38 FE    ADD   SP,254
        1E08: 18       POP   A
        1E09: 53 0D    MOV   [__r1],A
        1E0B: 18       POP   A
        1E0C: 39 00    CMP   A,0
        1E0E: B0 06    JNZ   0x1E15
        1E10: 3C 0D 00 CMP   [__r1],0
        1E13: A0 91    JZ    0x1EA5
(0084) 		
(0085) 	//	if ((gpio_var.key_fr_hi_lo&((unsigned)FR_HI_LO_ENTER))&&(!ENTER_KEY_DET)) {
(0086) 		if ((gpio_var.key_deb_f==0)&&(!ENTER_KEY_DET)) {
        1E15: 5F 0E 0F MOV   [__r0],[_gpio_var]
        1E18: 70 FB    AND   F,251
        1E1A: 6E 0E    RRC   [__r0]
        1E1C: 26 0E 01 AND   [__r0],1
        1E1F: B0 74    JNZ   0x1E94
        1E21: 49 0C 02 TST   REG[12],2
        1E24: B0 6F    JNZ   0x1E94
(0087) 	//		gpio_var.key_fr_hi_lo &= (unsigned) ~FR_HI_LO_ENTER;			//	in low state
(0088) 			gpio_var.key_deb_f = 1;
        1E26: 2E 0F 02 OR    [_gpio_var],2
        1E29: 51 0F    MOV   A,[_gpio_var]
(0089) 			// appl. level code here for ENTER key in DOWN case
(0090) 			APP_ENTER_KEY_DOWN_CASE;
        1E2B: 50 02    MOV   A,2
        1E2D: 08       PUSH  A
        1E2E: 51 2D    MOV   A,[_ptr_events_vect]
        1E30: 67       ASR   A
        1E31: 67       ASR   A
        1E32: 67       ASR   A
        1E33: 67       ASR   A
        1E34: 21 0F    AND   A,15
        1E36: 08       PUSH  A
        1E37: 51 2D    MOV   A,[_ptr_events_vect]
        1E39: 21 0F    AND   A,15
        1E3B: 08       PUSH  A
        1E3C: 7C 09 B3 LCALL _pre_wr_cir254buf
        1E3F: 38 FD    ADD   SP,253
        1E41: 54 01    MOV   [X+1],A
        1E43: 39 FF    CMP   A,255
        1E45: A0 56    JZ    0x1E9C
        1E47: 5F 0D 2D MOV   [__r1],[_ptr_events_vect]
        1E4A: 55 0E 00 MOV   [__r0],0
        1E4D: 26 0D 0F AND   [__r1],15
        1E50: 26 0E 00 AND   [__r0],0
        1E53: 06 0D 2E ADD   [__r1],46
        1E56: 0E 0E 00 ADC   [__r0],0
        1E59: 3E 0D    MVI   A,[__r1]
        1E5B: 7A 0D    DEC   [__r1]
        1E5D: 53 0C    MOV   [__r2],A
        1E5F: 26 0C F8 AND   [__r2],248
        1E62: 2E 0C 02 OR    [__r2],2
        1E65: 51 0C    MOV   A,[__r2]
        1E67: 3F 0D    MVI   [__r1],A
        1E69: 5F 0D 2D MOV   [__r1],[_ptr_events_vect]
        1E6C: 55 0E 00 MOV   [__r0],0
        1E6F: 26 0D 0F AND   [__r1],15
        1E72: 26 0E 00 AND   [__r0],0
        1E75: 06 0D 2E ADD   [__r1],46
        1E78: 0E 0E 00 ADC   [__r0],0
        1E7B: 3E 0D    MVI   A,[__r1]
        1E7D: 7A 0D    DEC   [__r1]
        1E7F: 21 E7    AND   A,231
        1E81: 3F 0D    MVI   [__r1],A
        1E83: 51 2D    MOV   A,[_ptr_events_vect]
        1E85: 21 F0    AND   A,240
        1E87: 53 0E    MOV   [__r0],A
        1E89: 52 01    MOV   A,[X+1]
        1E8B: 21 0F    AND   A,15
        1E8D: 2C 0E    OR    [__r0],A
        1E8F: 5F 2D 0E MOV   [_ptr_events_vect],[__r0]
(0091) 		} else if (ENTER_KEY_DET) {
        1E92: 80 09    JMP   0x1E9C
        1E94: 49 0C 02 TST   REG[12],2
        1E97: A0 04    JZ    0x1E9C
(0092) 			gpio_var.key_deb_f = 0;
        1E99: 26 0F FD AND   [_gpio_var],253
(0093) 		}
(0094) 		ENTER_KEY_SET_HIGH;								//	restore to high level regularly
        1E9C: 43 0C 02 OR    REG[12],2
(0095) 		DOWN_KEY_SET_HIGH;								//	since other process also use this gpio port for other function,
        1E9F: 43 0C 08 OR    REG[12],8
(0096) 		UPPER_KEY_SET_HIGH;								//	it read this pin and write back same data.
        1EA2: 43 14 08 OR    REG[20],8
(0097) 												//	However, this pin may be at active state when user click-in
(0098) 												//	then this active state will be always keep, so we need to clean regulary
(0099) 		//gpio_var.scan_key_timeout = 0;
(0100) 	}
(0101) #endif
(0102) 
(0103) }
        1EA5: 38 FC    ADD   SP,252
        1EA7: 20       POP   X
        1EA8: 7F       RET   
(0104) 
(0105) #if (NR_TIMER_OUT>0)
(0106) // parameters
(0107) // return
(0108) //	<0 as invalid timer
(0109) //	>=0 as valid timer index
(0110) char add_timer(struct timer_list* ptimer_addr)
(0111) {
_add_timer:
  i                    --> X+0
  ptimer_addr          --> X-5
        1EA9: 10       PUSH  X
        1EAA: 4F       MOV   X,SP
        1EAB: 38 01    ADD   SP,1
(0112) 	char i;
(0113) 	for (i=0;i<NR_TIMER_OUT;i++)							// chk struct timer vector for old one
        1EAD: 56 00 00 MOV   [X+0],0
        1EB0: 80 3E    JMP   0x1EEF
(0114) #if (CYPRESS_PSOC_RAM_UNDER_256==1)
(0115) 		if ((((unsigned int)timer_vector[i])&0x00ff)==(((unsigned int)ptimer_addr)&0x00ff))
        1EB2: 52 00    MOV   A,[X+0]
        1EB4: 53 0D    MOV   [__r1],A
        1EB6: 55 0E 00 MOV   [__r0],0
        1EB9: 65 0D    ASL   [__r1]
        1EBB: 6B 0E    RLC   [__r0]
        1EBD: 06 0D 30 ADD   [__r1],48
        1EC0: 0E 0E 00 ADC   [__r0],0
        1EC3: 3E 0D    MVI   A,[__r1]
        1EC5: 53 0E    MOV   [__r0],A
        1EC7: 3E 0D    MVI   A,[__r1]
        1EC9: 53 0D    MOV   [__r1],A
        1ECB: 26 0D FF AND   [__r1],255
        1ECE: 26 0E 00 AND   [__r0],0
        1ED1: 52 FC    MOV   A,[X-4]
        1ED3: 21 FF    AND   A,255
        1ED5: 53 0B    MOV   [__r3],A
        1ED7: 52 FB    MOV   A,[X-5]
        1ED9: 21 00    AND   A,0
        1EDB: 53 0C    MOV   [__r2],A
        1EDD: 51 0E    MOV   A,[__r0]
        1EDF: 3A 0C    CMP   A,[__r2]
        1EE1: B0 0B    JNZ   0x1EED
        1EE3: 51 0D    MOV   A,[__r1]
        1EE5: 3A 0B    CMP   A,[__r3]
        1EE7: B0 05    JNZ   0x1EED
(0116) 		// compiler problem in :
(0117) 		//	CY27CXXXX has 256 bytes RAM only, so the higher byte of 16-bit data is don't care. 
(0118) 		//	however, compiler of psoc is don't care the higher byte in parameter input(RAM address data) in subr.
(0119) 		//	this compiler is still handle the higher byte when comparing RAM address data
(0120) #else
(0121) 		if (timer_vector[i]==ptimer_addr)
(0122) #endif
(0123) 			return i;
        1EE9: 52 00    MOV   A,[X+0]
        1EEB: 80 5C    JMP   0x1F48
        1EED: 77 00    INC   [X+0]
        1EEF: 3D 00 03 CMP   [X+0],3
        1EF2: A0 03    JZ    0x1EF6
        1EF4: CF BD    JC    0x1EB2
(0124) 	for (i=0;i<NR_TIMER_OUT;i++)							//		find out the empty place for new timer
        1EF6: 56 00 00 MOV   [X+0],0
        1EF9: 80 25    JMP   0x1F1F
(0125) 		if (timer_vector[i]==0)
        1EFB: 52 00    MOV   A,[X+0]
        1EFD: 53 0D    MOV   [__r1],A
        1EFF: 55 0E 00 MOV   [__r0],0
        1F02: 65 0D    ASL   [__r1]
        1F04: 6B 0E    RLC   [__r0]
        1F06: 06 0D 30 ADD   [__r1],48
        1F09: 0E 0E 00 ADC   [__r0],0
        1F0C: 3E 0D    MVI   A,[__r1]
        1F0E: 53 0E    MOV   [__r0],A
        1F10: 3E 0D    MVI   A,[__r1]
        1F12: 3C 0E 00 CMP   [__r0],0
        1F15: B0 07    JNZ   0x1F1D
        1F17: 39 00    CMP   A,0
        1F19: B0 03    JNZ   0x1F1D
(0126) 			break;
        1F1B: 80 0A    JMP   0x1F26
        1F1D: 77 00    INC   [X+0]
        1F1F: 3D 00 03 CMP   [X+0],3
        1F22: A0 03    JZ    0x1F26
        1F24: CF D6    JC    0x1EFB
(0127) 	if (i==NR_TIMER_OUT) {
        1F26: 3D 00 03 CMP   [X+0],3
        1F29: B0 05    JNZ   0x1F2F
(0128) 		return (char) -1;
        1F2B: 50 FF    MOV   A,255
        1F2D: 80 1A    JMP   0x1F48
(0129) 	}
(0130) 	timer_vector[i] = ptimer_addr;
        1F2F: 52 00    MOV   A,[X+0]
        1F31: 53 0D    MOV   [__r1],A
        1F33: 55 0E 00 MOV   [__r0],0
        1F36: 65 0D    ASL   [__r1]
        1F38: 6B 0E    RLC   [__r0]
        1F3A: 06 0D 30 ADD   [__r1],48
        1F3D: 0E 0E 00 ADC   [__r0],0
        1F40: 76 0D    INC   [__r1]
        1F42: 52 FC    MOV   A,[X-4]
        1F44: 3F 0D    MVI   [__r1],A
(0131) 	return i;
        1F46: 52 00    MOV   A,[X+0]
        1F48: 38 FF    ADD   SP,255
        1F4A: 20       POP   X
        1F4B: 7F       RET   
(0132) }
(0133) 
(0134) /*void del_timer(unsigned char timer_num)
(0135) {
(0136) 	timer_vector[timer_num] = 0; 
(0137) }
(0138) 
(0139) void sleep(unsigned char sec)
(0140) {
(0141) 	schedule_timeout(sec * 100);
(0142) }*/
(0143) 
(0144) /*void alarm(p_func function, unsigned char sec)
(0145) {
(0146) 	struct timer_list timer;
(0147) 	timer.expires = sec*100 + jiffies;
(0148) 	timer.data = 0;
(0149) 	timer.function = function;
(0150) 	add_timer(&timer);
(0151) }*/
(0152) 
(0153) // parameters
(0154) //	jiffies_cnt -- should not be ZERO
(0155) // return
(0156) //	<0 as invalid timer
(0157) //	>=0 as valid timer index
(0158) char _malarm(p_func function, unsigned char jiffies_cnt, struct timer_list* timer)
(0159) {
__malarm:
  timer                --> X-8
  jiffies_cnt          --> X-6
  function             --> X-5
        1F4C: 10       PUSH  X
        1F4D: 4F       MOV   X,SP
(0160) //	char i = (char) -1;
(0161) //	if (gpio_var.timer_semop==0) {
(0162) //		gpio_var.timer_semop = 1;
(0163) 		timer->expires = jiffies_cnt + jiffies;
        1F4E: 52 F9    MOV   A,[X-7]
        1F50: 53 0D    MOV   [__r1],A
        1F52: 52 FA    MOV   A,[X-6]
        1F54: 02 36    ADD   A,[_jiffies]
        1F56: 3F 0D    MVI   [__r1],A
(0164) //		timer->data.timer_function = (p_func) function;// outside to do it, after solve this problem, enable this
(0165) 		return add_timer(timer);
        1F58: 52 F8    MOV   A,[X-8]
        1F5A: 08       PUSH  A
        1F5B: 52 F9    MOV   A,[X-7]
        1F5D: 08       PUSH  A
        1F5E: 9F 49    CALL  _add_timer
        1F60: 38 FE    ADD   SP,254
        1F62: 20       POP   X
        1F63: 7F       RET   
FILE: .\twlm6023.c
(0001) /*
(0002)  * Copyright (c) 05-05-2004 cheng chung yan <yan@amonics.com> for 8-bit system
(0003)  *
(0004)  * In mono LCD, 128X64 configuration, topway(http://www.topwaydisplay.com/) lm6023
(0005)  * hardware setting under Laser Control circuit by PSoC
(0006)  *
(0007)  * Char mode
(0008)  * hardware setting 
(0009)  *	PSoC
(0010)                 // chip's hardware setting
(0011)                 //      * 24MHz cpu clk
(0012)                 //      * reset and CS as pull high (for faster response on active low)
(0013)                 //      * A0, D6 and D7 as strong (for faster response on any stage)
(0014)                    init. 
(0015)                         * from util/sys start init.
(0016)                                 * chip select disable 
(0017)                                 * reset 
(0018)                         * local init.
(0019)  *	LCD
(0020)                 whole screen - 128X64
(0021)                 font - 8x8
(0022)  */
(0023) 
(0024) #include "app.h"									// linlike8 os
(0025) 
(0026) #if (GUI_LCD==1)
(0027) #include "nano-X.h"
(0028) #include "device.h"									// scr_open
(0029) #include "system.h"									// cli()
(0030) #include "twlm6023.h"									// hw bet. lcd and mcu
(0031) 
(0032) // Continuous ASCII Code so use 2D Table
(0033) const unsigned char Font_Table[][8]=
(0034) {
(0035) 	//{ 0x00, 0x00, 0x14, 0x0E, 0x14, 0x00, 0x00, 0x00 },		// ASCII=0x2A
(0036) 	//{ 0x00, 0x10, 0x10, 0x7C, 0x10, 0x10, 0x00, 0x00 },		// ASCII=0x2B
(0037) 	//{ 0x00, 0x00, 0x00, 0x00, 0x80, 0x60, 0x00, 0x00 },		// ASCII=0x2C
(0038) 	//{ 0x00, 0x00, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00 },		// ASCII=0x2D
(0039) 	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00 },		// ASCII=0x2E
(0040) 	{ 0x00, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00 },		// ASCII=0x2F
(0041) 	{ 0x00, 0x7C, 0x42, 0x42, 0x3E, 0x00, 0x00, 0x00 },		// ASCII=0x30
(0042) 	{ 0x00, 0x00, 0x04, 0x7E, 0x00, 0x00, 0x00, 0x00 },		// ASCII=0x31
(0043) 	{ 0x00, 0x00, 0x44, 0x62, 0x52, 0x4C, 0x00, 0x00 },		// ASCII=0x32
(0044) 	{ 0x00, 0x00, 0x24, 0x42, 0x4A, 0x34, 0x00, 0x00 },		// ASCII=0x33
(0045) 	{ 0x00, 0x30, 0x28, 0x24, 0x7E, 0x20, 0x00, 0x00 },		// ASCII=0x34
(0046) 	{ 0x00, 0x4E, 0x4A, 0x4A, 0x32, 0x00, 0x00, 0x00 },		// ASCII=0x35
(0047) 	{ 0x00, 0x3C, 0x4A, 0x4A, 0x32, 0x00, 0x00, 0x00 },		// ASCII=0x36
(0048) 	{ 0x00, 0x02, 0x62, 0x1A, 0x06, 0x00, 0x00, 0x00 },		// ASCII=0x37
(0049) 	{ 0x00, 0x34, 0x4A, 0x4A, 0x34, 0x00, 0x00, 0x00 },		// ASCII=0x38
(0050) 	{ 0x00, 0x1E, 0x12, 0x12, 0x7E, 0x00, 0x00, 0x00 },		// ASCII=0x39
(0051) 	{ 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00 },		// ASCII=0x3A
(0052) 	{ 0x00, 0x00, 0x00, 0x40, 0x34, 0x00, 0x00, 0x00 },		// ASCII=0x3B
(0053) 	{ 0x00, 0x10, 0x28, 0x28, 0x28, 0x44, 0x00, 0x00 },		// ASCII=0x3C
(0054) 	{ 0x00, 0x28, 0x28, 0x28, 0x28, 0x28, 0x00, 0x00 },		// ASCII=0x3D
(0055) 	{ 0x00, 0x44, 0x28, 0x28, 0x28, 0x10, 0x00, 0x00 },		// ASCII=0x3E
(0056) 	{ 0x00, 0x04, 0x02, 0xB2, 0x12, 0x0C, 0x00, 0x00 },		// ASCII=0x3F
(0057) 	{ 0x00, 0x7C, 0xC6, 0xFA, 0x8E, 0xE6, 0x3C, 0x00 },		// ASCII=0x40
(0058) 	{ 0x00, 0x60, 0x1C, 0x12, 0x1C, 0x60, 0x00, 0x00 },		// ASCII=0x41
(0059) 	{ 0x00, 0x7E, 0x4A, 0x4A, 0x3C, 0x00, 0x00, 0x00 },		// ASCII=0x42
(0060) 	{ 0x00, 0x7C, 0x82, 0x82, 0x82, 0x44, 0x00, 0x00 },		// ASCII=0x43
(0061) 	{ 0x00, 0x7E, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00 },		// ASCII=0x44
(0062) 	{ 0x00, 0x7E, 0x4A, 0x4A, 0x4A, 0x42, 0x00, 0x00 },		// ASCII=0x45
(0063) 	{ 0x00, 0x7E, 0x12, 0x12, 0x02, 0x00, 0x00, 0x00 },		// ASCII=0x46
(0064) 	{ 0x00, 0x3C, 0x42, 0x42, 0x52, 0x34, 0x00, 0x00 },		// ASCII=0x47
(0065) 	{ 0x00, 0x7E, 0x08, 0x08, 0x08, 0x7E, 0x00, 0x00 },		// ASCII=0x48
(0066) 	{ 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00 },		// ASCII=0x49
(0067) 	{ 0x00, 0x60, 0x40, 0x40, 0x3E, 0x00, 0x00, 0x00 },		// ASCII=0x4A
(0068) 	{ 0x00, 0x7E, 0x08, 0x14, 0x22, 0x40, 0x00, 0x00 },		// ASCII=0x4B
(0069) 	{ 0x00, 0x7E, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00 },		// ASCII=0x4C
(0070) 	{ 0x00, 0x7E, 0x04, 0x18, 0x10, 0x04, 0x7E, 0x00 },		// ASCII=0x4D
(0071) 	{ 0x00, 0x7E, 0x04, 0x08, 0x30, 0x7E, 0x00, 0x00 },		// ASCII=0x4E
(0072) 	{ 0x00, 0x3C, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00 },		// ASCII=0x4F
(0073) 	{ 0x00, 0x7E, 0x0A, 0x0A, 0x0E, 0x00, 0x00, 0x00 },		// ASCII=0x50
(0074) 	{ 0x00, 0x3C, 0x42, 0x42, 0x62, 0x5C, 0x00, 0x00 },		// ASCII=0x51
(0075) 	{ 0x00, 0x7E, 0x12, 0x12, 0x32, 0x4C, 0x00, 0x00 },		// ASCII=0x52
(0076) 	{ 0x00, 0x00, 0x2C, 0x4A, 0x52, 0x34, 0x00, 0x00 },		// ASCII=0x53
(0077) 	{ 0x00, 0x02, 0x02, 0x7E, 0x02, 0x02, 0x00, 0x00 },		// ASCII=0x54
(0078) 	{ 0x00, 0x3E, 0x40, 0x40, 0x40, 0x3E, 0x00, 0x00 },		// ASCII=0x55
(0079) 	{ 0x00, 0x0E, 0x30, 0x40, 0x30, 0x0E, 0x00, 0x00 },		// ASCII=0x56
(0080) 	{ 0x00, 0x1E, 0x60, 0x1C, 0x38, 0x60, 0x1E, 0x00 },		// ASCII=0x57
(0081) 	{ 0x00, 0x42, 0x34, 0x08, 0x34, 0x42, 0x00, 0x00 },		// ASCII=0x58
(0082) 	{ 0x00, 0x02, 0x0C, 0x70, 0x0C, 0x02, 0x00, 0x00 },		// ASCII=0x59
(0083) 	{ 0x00, 0x62, 0x52, 0x4A, 0x4A, 0x46, 0x42, 0x00 },		// ASCII=0x5A
(0084) 	{ 0x00, 0x00, 0x00, 0x00, 0xFF, 0x81, 0x00, 0x00 },		// ASCII=0x5B
(0085) 	{ 0x00, 0x00, 0x00, 0x06, 0x38, 0xC0, 0x00, 0x00 },		// ASCII=0x5C
(0086) 	{ 0x00, 0x00, 0x81, 0xFF, 0x00, 0x00, 0x00, 0x00 },		// ASCII=0x5D
(0087) 	{ 0x00, 0x00, 0x00, 0x0C, 0x02, 0x0C, 0x00, 0x00 },		// ASCII=0x5E
(0088) 	{ 0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00 },		// ASCII=0x5F
(0089) 	{ 0x00, 0x00, 0x00, 0x00, 0x06, 0x08, 0x00, 0x00 },		// ASCII=0x60
(0090) 	{ 0x00, 0x00, 0x64, 0x54, 0x54, 0x7C, 0x00, 0x00 },		// ASCII=0x61
(0091) 	{ 0x00, 0x00, 0x7F, 0x44, 0x44, 0x38, 0x00, 0x00 },		// ASCII=0x62
(0092) 	{ 0x00, 0x00, 0x38, 0x44, 0x44, 0x28, 0x00, 0x00 },		// ASCII=0x63
(0093) 	{ 0x00, 0x00, 0x38, 0x44, 0x44, 0x7F, 0x00, 0x00 },		// ASCII=0x64
(0094) 	{ 0x00, 0x00, 0x38, 0x54, 0x54, 0x58, 0x00, 0x00 },		// ASCII=0x65
(0095) 	{ 0x00, 0x00, 0x04, 0x7E, 0x05, 0x00, 0x00, 0x00 },		// ASCII=0x66
(0096) 	{ 0x00, 0x00, 0x2E, 0x51, 0x51, 0x3F, 0x00, 0x00 },		// ASCII=0x67
(0097) 	{ 0x00, 0x00, 0x7F, 0x04, 0x04, 0x78, 0x00, 0x00 },		// ASCII=0x68
(0098) 	{ 0x00, 0x00, 0x00, 0x00, 0x7D, 0x00, 0x00, 0x00 },		// ASCII=0x69
(0099) 	{ 0x00, 0x00, 0x40, 0x80, 0x7D, 0x00, 0x00, 0x00 },		// ASCII=0x6A
(0100) 	{ 0x00, 0x00, 0x7F, 0x10, 0x38, 0x44, 0x00, 0x00 },		// ASCII=0x6B
(0101) 	{ 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00 },		// ASCII=0x6C
(0102) 	{ 0x00, 0x7C, 0x04, 0x04, 0x7C, 0x04, 0x04, 0x78 },		// ASCII=0x6D
(0103) 	{ 0x00, 0x00, 0x7C, 0x04, 0x04, 0x78, 0x00, 0x00 },		// ASCII=0x6E
(0104) 	{ 0x00, 0x00, 0x38, 0x44, 0x44, 0x38, 0x00, 0x00 },		// ASCII=0x6F
(0105) 	{ 0x00, 0x00, 0xFE, 0x22, 0x22, 0x1C, 0x00, 0x00 },		// ASCII=0x70
(0106) 	{ 0x00, 0x00, 0x1C, 0x22, 0x22, 0xFE, 0x00, 0x00 },		// ASCII=0x71
(0107) 	{ 0x00, 0x00, 0x00, 0x7C, 0x04, 0x04, 0x00, 0x00 },		// ASCII=0x72
(0108) 	{ 0x00, 0x00, 0x48, 0x54, 0x54, 0x24, 0x00, 0x00 },		// ASCII=0x73
(0109) 	{ 0x00, 0x00, 0x00, 0x04, 0x7E, 0x44, 0x00, 0x00 },		// ASCII=0x74
(0110) 	{ 0x00, 0x00, 0x3C, 0x40, 0x40, 0x7C, 0x00, 0x00 },		// ASCII=0x75
(0111) 	{ 0x00, 0x00, 0x04, 0x38, 0x40, 0x38, 0x04, 0x00 },		// ASCII=0x76
(0112) 	{ 0x00, 0x00, 0x3C, 0x40, 0x3C, 0x40, 0x3C, 0x00 },		// ASCII=0x77
(0113) 	{ 0x00, 0x00, 0x44, 0x38, 0x38, 0x44, 0x00, 0x00 },		// ASCII=0x78
(0114) 	{ 0x00, 0x00, 0x02, 0x9C, 0x60, 0x1C, 0x02, 0x00 },		// ASCII=0x79
(0115) 	{ 0x00, 0x00, 0x00, 0x64, 0x54, 0x4C, 0x00, 0x00 },		// ASCII=0x7A
(0116) 
(0117) };
(0118) 
(0119) const unsigned char Font_SPACE[]={ 00, 00, 00, 00, 00, 00, 00, 00 };                            // ASCII=0x20
(0120) const unsigned char Font_DEGREE[]={ 0x00, 0x0C, 0x12, 0x12, 0x0C, 0x00, 0x00, 0x00 };           // ASCII=0xA7
(0121) const unsigned char Font_EXC[]={ 00, 00, 00, 0x5e, 00, 00, 00, 00 };                            // ASCII=0x21
(0122) const unsigned char ClearPaper[]={0};
(0123) 
(0124) void wrTxLm6023(unsigned char wrAddr, unsigned char wrData);
(0125) 
(0126) void scr_open(void)
(0127) {
(0128)         
(0129)         disResetP;
_scr_open:
        1F64: 43 10 02 OR    REG[16],2
(0130)         
(0131) 		// send out hardware reset pulse
(0132)         enResetP;									// delay >1uSec ~ 1.4uSec, under 24MHz cpu clk
        1F67: 41 10 FD AND   REG[16],253
(0133)         asm("nop");
        1F6A: 40       NOP   
(0134)         asm("nop");
        1F6B: 40       NOP   
(0135)         asm("nop");
        1F6C: 40       NOP   
(0136)         asm("nop");
        1F6D: 40       NOP   
(0137)         asm("nop");
        1F6E: 40       NOP   
(0138)         asm("nop");
        1F6F: 40       NOP   
(0139)         disResetP;                                      				// some transient ~ 0.4uSec
        1F70: 43 10 02 OR    REG[16],2
(0140)         asm("nop");                                     				// delay >1uSec ~ 1.2uSec
        1F73: 40       NOP   
(0141)         asm("nop");
        1F74: 40       NOP   
(0142)         asm("nop");
        1F75: 40       NOP   
(0143)         asm("nop");
        1F76: 40       NOP   
(0144)         asm("nop");
        1F77: 40       NOP   
(0145)         asm("nop");
        1F78: 40       NOP   
(0146)         
(0147)         	// set LCD bias, default as 1/8 by hw reset pin, show skip
(0148)         
(0149) 		// set power supply control, default close voltage follower, voltage adjustment and voltage higher by hw reset pin, show skip
(0150)         wrTxLm6023(0x00, 0x2f);                              				// turn ON all voltage control
        1F79: 50 2F    MOV   A,47
        1F7B: 08       PUSH  A
        1F7C: 50 00    MOV   A,0
        1F7E: 08       PUSH  A
        1F7F: 90 15    CALL  _wrTxLm6023
        1F81: 38 FE    ADD   SP,254
(0151)         
(0152)         	// set register control, i.e contrast
(0153)         wrTxLm6023(0x00, 0x94);                              				// set contrast in bit 4 to bit 0 => 0x0f as middle
        1F83: 50 94    MOV   A,148
        1F85: 08       PUSH  A
        1F86: 50 00    MOV   A,0
        1F88: 08       PUSH  A
        1F89: 90 0B    CALL  _wrTxLm6023
(0154)         
(0155)         	// ADC setting, i.e. normal or invert display, default as normal; So skip
(0156)         //wrTxLm6023(0x00, 0xa0);
(0157)         
(0158)         	// turn ON LCD
(0159)         wrTxLm6023(0x00, 0xaf);                                				// bit 0 as 1 to ON, 0 as OFF LCD
        1F8B: 50 AF    MOV   A,175
        1F8D: 08       PUSH  A
        1F8E: 50 00    MOV   A,0
        1F90: 08       PUSH  A
        1F91: 90 03    CALL  _wrTxLm6023
        1F93: 38 FC    ADD   SP,252
(0160)         
(0161)         //wrTxLm6023(0x00, 0xa7);
(0162)         //wrTxLm6023(0x00, 0xa5);                              				// ON all pixel
(0163)         
(0164) }
        1F95: 7F       RET   
(0165) 
(0166)         //----------------------------------------------------------------------------
(0167)         // Description : write data/command into LCD module
(0168)         // parameters : 
(0169)         //      wrPara : bit 7 ( , , , , , , , A0) bit 0
(0170)         //      wrData : Tx data
(0171)         //----------------------------------------------------------------------------
(0172) void wrTxLm6023(unsigned char wrAddr, unsigned char wrData) {
_wrTxLm6023:
  i                    --> X+0
  wrData               --> X-5
  wrAddr               --> X-4
        1F96: 10       PUSH  X
        1F97: 4F       MOV   X,SP
        1F98: 38 01    ADD   SP,1
(0173)         
(0174)         unsigned char i;
(0175)         
(0176) 	cli();										// disable interrupt, make sure the clock time
        1F9A: 70 FE    AND   F,254
(0177) 	
(0178)         // prepare data port for pull-high
(0179)         
(0180)         // chip select                                                  all timing is cal. under 5V supply
(0181)         enCsP;                                                  // <-| Min. 30 ns from LCD; 24MHz cpu Min. as 4.6us
        1F9C: 41 10 F7 AND   REG[16],247
(0182)                                                                 //   |
(0183)         // A0                                                        |
(0184)         if (wrAddr&0x01) highA0P;                               //   |  <-| Min. 50 ns from LCD; 24MHz cpu Min. as 3.6us
        1F9F: 48 FC 01 TST   [X-4],1
        1FA2: A0 06    JZ    0x1FA9
        1FA4: 43 10 20 OR    REG[16],32
        1FA7: 80 04    JMP   0x1FAC
(0185)         else lowA0P;                                            //   |    |
        1FA9: 41 10 DF AND   REG[16],223
(0186)                                                                 //   |    |
(0187)         // serial tx data for 8 cycle                                |    |
(0188)         for (i=0;i<8;i++) {                                     //   |    |
        1FAC: 56 00 00 MOV   [X+0],0
        1FAF: 80 18    JMP   0x1FC8
(0189)                                                                 //   |    |
(0190)                 // low serial data clock                             |    |
(0191)                 lowSClk;                                        //   |    |     <-| Min. 250 ns from LCD; 24MHz cpu Min. as 3.2us       <-| Min. 70 ns from LCD; 24MHz cpu Min. as 1.8us        
        1FB1: 41 10 7F AND   REG[16],127
(0192)                                                                 //   |    |       |                                                       |
(0193)                 // prepare data                                      |    |       |                                                       |
(0194)                 if (wrData&0x80) highSD;                        //   |    |       ...                                                     |                                                     <-| Min. 100 ns from LCD; 24MHz cpu Min. as 0.8us
        1FB4: 48 FB 80 TST   [X-5],128
        1FB7: A0 06    JZ    0x1FBE
        1FB9: 43 08 02 OR    REG[8],2
        1FBC: 80 04    JMP   0x1FC1
(0195)                 else lowSD;                                     //   |    |       ...                                                     |                                                       | 
        1FBE: 41 08 FD AND   REG[8],253
(0196)                 wrData <<= 1;                                   //   |    |       |                                                       |                                                       | 
        1FC1: 66 FB    ASL   [X-5]
(0197)                                                                 //   |    |     <-| next cycle sclk changing,                             |                                                       |  
(0198)                 // high serial data clock                            |    |                                                               |                                                       | 
(0199)                 highSClk;                                       // <-|  <-|  <-| Min. 100ns from LCD; 24MHz cpu Min. as 1.2us           <-|   <-| Min. 500ns from LCD; 24MHz cpu Min. as 5us    <-|   <-| Min. 100ns from LCD; 24MHz cpu Min. as 1.4us  <-| Min. 100ns from LCD; 24MHz cpu Min. as 2.4us
        1FC3: 43 10 80 OR    REG[16],128
        1FC6: 77 00    INC   [X+0]
        1FC8: 3D 00 08 CMP   [X+0],8
        1FCB: A0 03    JZ    0x1FCF
        1FCD: CF E3    JC    0x1FB1
(0200)                                                                 //             |                                                                |                                                       |                                                 |
(0201)         }                                                       //             |                                                                |                                                       |                                                 |
(0202)                                                                 //             |                                                                ...                                                     ...                                               ...
(0203)         disCsP;                                                 //           <-|                                                                ...                                                     ...                                               ...
        1FCF: 43 10 08 OR    REG[16],8
(0204)                                                                 //                                                                              |                                                       |                                                 |
(0205)                                                                 //                                                                            <-| next cycle A0 changing                              <-| next cycle SCLK changing                      <-| next cycle SCLK changing
(0206)         
(0207) 	sti();
        1FD2: 71 01    OR    F,1
(0208) }
        1FD4: 38 FF    ADD   SP,255
        1FD6: 20       POP   X
        1FD7: 7F       RET   
(0209) 
(0210) /*
(0211)  * Draw a rectangular area in the specified drawable using the specified
(0212)  * graphics, as determined by the specified bit map.  This differs from
(0213)  * rectangle drawing in that the rectangle is drawn using the foreground
(0214)  * color and possibly the background color as determined by the bit map.
(0215)  * Each row of bits is aligned to the next bitmap word boundary (so there
(0216)  * is padding at the end of the row).  The background bit values are only
(0217)  * written if the usebackground flag is set in the GC.
(0218)  *
(0219)  *	for whole screen only temporary
(0220)  */
(0221) void
(0222) GrBitmapDrv(const unsigned char* pData)
(0223) {
_GrBitmapDrv:
  tmpByte              --> X+5
  pageNo               --> X+4
  tmpInt               --> X+2
  dataCounter          --> X+0
  pData                --> X-5
        1FD8: 10       PUSH  X
        1FD9: 4F       MOV   X,SP
        1FDA: 38 06    ADD   SP,6
(0224)         unsigned char pageNo;
(0225)         unsigned char tmpByte;
(0226)         unsigned int tmpInt;
(0227)         unsigned int dataCounter;
(0228)         
(0229)         // init.
(0230)         dataCounter = 0;
        1FDC: 56 01 00 MOV   [X+1],0
        1FDF: 56 00 00 MOV   [X+0],0
(0231)         
(0232)         // each page
(0233)         for (pageNo=0;pageNo<8;pageNo++) {
        1FE2: 56 04 00 MOV   [X+4],0
        1FE5: 80 96    JMP   0x207C
(0234)         
(0235)                 tmpByte = 0xb0 | pageNo;                                // set page address
        1FE7: 52 04    MOV   A,[X+4]
        1FE9: 29 B0    OR    A,176
        1FEB: 54 05    MOV   [X+5],A
(0236)                 wrTxLm6023(0x00, tmpByte);
        1FED: 52 05    MOV   A,[X+5]
        1FEF: 08       PUSH  A
        1FF0: 50 00    MOV   A,0
        1FF2: 08       PUSH  A
        1FF3: 9F A1    CALL  _wrTxLm6023
        1FF5: 38 FE    ADD   SP,254
(0237)                 
(0238)                 wrTxLm6023(0x00, 0x10);                                      // set coloumn address (higher) at 0 position
        1FF7: 50 10    MOV   A,16
        1FF9: 08       PUSH  A
        1FFA: 50 00    MOV   A,0
        1FFC: 08       PUSH  A
        1FFD: 9F 97    CALL  _wrTxLm6023
(0239)                 wrTxLm6023(0x00, 0x00);                                      // set coloumn address (lower)
        1FFF: 50 00    MOV   A,0
        2001: 08       PUSH  A
        2002: 08       PUSH  A
        2003: 9F 91    CALL  _wrTxLm6023
        2005: 38 FC    ADD   SP,252
(0240)                 
(0241)                 // each segment in one page (adjust the code for more efficiency later)
(0242)                 tmpInt = (pageNo+1)*128;
        2007: 52 04    MOV   A,[X+4]
        2009: 53 0D    MOV   [__r1],A
        200B: 55 0E 00 MOV   [__r0],0
        200E: 06 0D 01 ADD   [__r1],1
        2011: 0E 0E 00 ADC   [__r0],0
        2014: 65 0D    ASL   [__r1]
        2016: 6B 0E    RLC   [__r0]
        2018: 65 0D    ASL   [__r1]
        201A: 6B 0E    RLC   [__r0]
        201C: 65 0D    ASL   [__r1]
        201E: 6B 0E    RLC   [__r0]
        2020: 65 0D    ASL   [__r1]
        2022: 6B 0E    RLC   [__r0]
        2024: 65 0D    ASL   [__r1]
        2026: 6B 0E    RLC   [__r0]
        2028: 65 0D    ASL   [__r1]
        202A: 6B 0E    RLC   [__r0]
        202C: 65 0D    ASL   [__r1]
        202E: 6B 0E    RLC   [__r0]
        2030: 51 0D    MOV   A,[__r1]
        2032: 54 03    MOV   [X+3],A
        2034: 51 0E    MOV   A,[__r0]
        2036: 54 02    MOV   [X+2],A
(0243)                 for (;dataCounter<tmpInt;dataCounter++) {
        2038: 80 33    JMP   0x206C
(0244)                         if (pData!=ClearPaper) wrTxLm6023(0x01, *(pData+dataCounter));              // set data, coloumn address will auto. inc. inside LCD
        203A: 3D FB 07 CMP   [X-5],7
        203D: B0 06    JNZ   0x2044
        203F: 3D FC B7 CMP   [X-4],183
        2042: A0 1A    JZ    0x205D
        2044: 52 01    MOV   A,[X+1]
        2046: 03 FC    ADD   A,[X-4]
        2048: 53 0D    MOV   [__r1],A
        204A: 52 00    MOV   A,[X+0]
        204C: 0B FB    ADC   A,[X-5]
        204E: 10       PUSH  X
        204F: 58 0D    MOV   X,[__r1]
        2051: 28       ROMX  
        2052: 20       POP   X
        2053: 08       PUSH  A
        2054: 50 01    MOV   A,1
        2056: 08       PUSH  A
        2057: 9F 3D    CALL  _wrTxLm6023
        2059: 38 FE    ADD   SP,254
        205B: 80 0B    JMP   0x2067
(0245)                         else wrTxLm6023(0x01, 0);                                    // clear screen
        205D: 50 00    MOV   A,0
        205F: 08       PUSH  A
        2060: 50 01    MOV   A,1
        2062: 08       PUSH  A
        2063: 9F 31    CALL  _wrTxLm6023
        2065: 38 FE    ADD   SP,254
        2067: 77 01    INC   [X+1]
        2069: 0F 00 00 ADC   [X+0],0
        206C: 52 00    MOV   A,[X+0]
        206E: 3B 02    CMP   A,[X+2]
        2070: B0 07    JNZ   0x2078
        2072: 52 01    MOV   A,[X+1]
        2074: 3B 03    CMP   A,[X+3]
        2076: A0 03    JZ    0x207A
        2078: CF C1    JC    0x203A
        207A: 77 04    INC   [X+4]
        207C: 3D 04 08 CMP   [X+4],8
        207F: A0 03    JZ    0x2083
        2081: CF 65    JC    0x1FE7
(0246)                 }
(0247)                         
(0248)         }
(0249) }
        2083: 38 FA    ADD   SP,250
        2085: 20       POP   X
        2086: 7F       RET   
(0250) 
(0251) /*
(0252)  * Draw a text in the specified drawable using the
(0253)  * specified graphics context.
(0254)  *
(0255)  * flags
(0256)  *	bit 0 - '0' as high light off, '1' as high light on
(0257)  */
(0258) void
(0259) GrTextDrv(GR_COORD x, GR_COORD y, unsigned char font_code,
(0260) 	GR_TEXTFLAGS flags)
(0261) {
_GrTextDrv:
  p                    --> X+1
  i                    --> X+0
  flags                --> X-7
  font_code            --> X-6
  y                    --> X-5
  x                    --> X-4
        2087: 10       PUSH  X
        2088: 4F       MOV   X,SP
        2089: 38 05    ADD   SP,5
(0262)         unsigned char i;
(0263)         const unsigned char* p;
(0264) 	
(0265) 		wrTxLm6023(0x00, 0xb0 | y);                                  // set page address
        208B: 52 FB    MOV   A,[X-5]
        208D: 29 B0    OR    A,176
        208F: 08       PUSH  A
        2090: 50 00    MOV   A,0
        2092: 08       PUSH  A
        2093: 9F 01    CALL  _wrTxLm6023
        2095: 38 FE    ADD   SP,254
(0266) 		
(0267) 		x *= 8;                                                 // set coloumn address 
        2097: 52 FC    MOV   A,[X-4]
        2099: 64       ASL   A
        209A: 64       ASL   A
        209B: 64       ASL   A
        209C: 54 FC    MOV   [X-4],A
(0268) 		wrTxLm6023(0x00, 0x0f & x );                                         // lower
        209E: 52 FC    MOV   A,[X-4]
        20A0: 21 0F    AND   A,15
        20A2: 08       PUSH  A
        20A3: 50 00    MOV   A,0
        20A5: 08       PUSH  A
        20A6: 9E EE    CALL  _wrTxLm6023
(0269) 		wrTxLm6023(0x00, ((x>>4) & 0x1f) | 0x10 );                           // higher
        20A8: 52 FC    MOV   A,[X-4]
        20AA: 67       ASR   A
        20AB: 67       ASR   A
        20AC: 67       ASR   A
        20AD: 67       ASR   A
        20AE: 21 0F    AND   A,15
        20B0: 53 0E    MOV   [__r0],A
        20B2: 26 0E 1F AND   [__r0],31
        20B5: 2E 0E 10 OR    [__r0],16
        20B8: 51 0E    MOV   A,[__r0]
        20BA: 08       PUSH  A
        20BB: 50 00    MOV   A,0
        20BD: 08       PUSH  A
        20BE: 9E D6    CALL  _wrTxLm6023
        20C0: 38 FC    ADD   SP,252
(0270) 		
(0271) 		switch (font_code) {
        20C2: 52 FA    MOV   A,[X-6]
        20C4: 54 04    MOV   [X+4],A
        20C6: 56 03 00 MOV   [X+3],0
        20C9: 3D 03 00 CMP   [X+3],0
        20CC: B0 06    JNZ   0x20D3
        20CE: 3D 04 20 CMP   [X+4],32
        20D1: A0 34    JZ    0x2106
        20D3: 3D 03 00 CMP   [X+3],0
        20D6: B0 06    JNZ   0x20DD
        20D8: 3D 04 21 CMP   [X+4],33
        20DB: A0 3A    JZ    0x2116
        20DD: 52 03    MOV   A,[X+3]
        20DF: 31 80    XOR   A,128
        20E1: 53 01    MOV   [__rY],A
        20E3: 50 00    MOV   A,0
        20E5: 31 80    XOR   A,128
        20E7: 53 00    MOV   [NO_SHADOW],A
        20E9: 55 02 00 MOV   [__rX],0
        20EC: 52 04    MOV   A,[X+4]
        20EE: 11 20    SUB   A,32
        20F0: 2C 02    OR    [__rX],A
        20F2: 51 01    MOV   A,[__rY]
        20F4: 1A 00    SBB   A,[NO_SHADOW]
        20F6: 2C 02    OR    [__rX],A
        20F8: C0 25    JC    0x211E
        20FA: 3D 03 00 CMP   [X+3],0
        20FD: B0 06    JNZ   0x2104
        20FF: 3D 04 A7 CMP   [X+4],167
        2102: A0 0B    JZ    0x210E
        2104: 80 19    JMP   0x211E
(0272) 			case 0x20 : 
(0273) 				 p = Font_SPACE;
        2106: 56 02 9F MOV   [X+2],159
        2109: 56 01 07 MOV   [X+1],7
(0274) 				break;
        210C: 80 36    JMP   0x2143
(0275) 			case 0xa7 : 
(0276) 				 p = Font_DEGREE;
        210E: 56 02 A7 MOV   [X+2],167
        2111: 56 01 07 MOV   [X+1],7
(0277) 				break;
        2114: 80 2E    JMP   0x2143
(0278) 			case 0x21 : 
(0279) 				 p = Font_EXC;
        2116: 56 02 AF MOV   [X+2],175
        2119: 56 01 07 MOV   [X+1],7
(0280) 				break;
        211C: 80 26    JMP   0x2143
(0281) 			default : 
(0282) 				 //p = Font_Table[font_code-0x2A];
(0283) 				 p = Font_Table[font_code-0x2E];
        211E: 52 FA    MOV   A,[X-6]
        2120: 53 0D    MOV   [__r1],A
        2122: 55 0E 00 MOV   [__r0],0
        2125: 16 0D 2E SUB   [__r1],46
        2128: 1E 0E 00 SBB   [__r0],0
        212B: 65 0D    ASL   [__r1]
        212D: 6B 0E    RLC   [__r0]
        212F: 65 0D    ASL   [__r1]
        2131: 6B 0E    RLC   [__r0]
        2133: 65 0D    ASL   [__r1]
        2135: 6B 0E    RLC   [__r0]
        2137: 51 0D    MOV   A,[__r1]
        2139: 01 37    ADD   A,55
        213B: 54 02    MOV   [X+2],A
        213D: 51 0E    MOV   A,[__r0]
        213F: 09 05    ADC   A,5
        2141: 54 01    MOV   [X+1],A
(0284) 				break;
(0285) 		}
(0286) 		
(0287) 		for (i=0;i<8;i++)                                       // wr. 8 bytes data for one fonts (8x8 in size), set data, coloumn address will auto. inc. inside LCD
        2143: 56 00 00 MOV   [X+0],0
        2146: 80 47    JMP   0x218E
(0288) 			//if (flags&0x01) {
(0289) 			if (flags) {
        2148: 3D F9 00 CMP   [X-7],0
        214B: A0 22    JZ    0x216E
(0290) 				wrTxLm6023(0x01, ~(*(p+i)) );
        214D: 52 00    MOV   A,[X+0]
        214F: 53 0D    MOV   [__r1],A
        2151: 55 0E 00 MOV   [__r0],0
        2154: 52 02    MOV   A,[X+2]
        2156: 04 0D    ADD   [__r1],A
        2158: 52 01    MOV   A,[X+1]
        215A: 0C 0E    ADC   [__r0],A
        215C: 51 0E    MOV   A,[__r0]
        215E: 10       PUSH  X
        215F: 58 0D    MOV   X,[__r1]
        2161: 28       ROMX  
        2162: 20       POP   X
        2163: 73       CPL   A
        2164: 08       PUSH  A
        2165: 50 01    MOV   A,1
        2167: 08       PUSH  A
        2168: 9E 2C    CALL  _wrTxLm6023
        216A: 38 FE    ADD   SP,254
(0291) 			} else {
        216C: 80 1F    JMP   0x218C
(0292) 				wrTxLm6023(0x01, *(p+i));
        216E: 52 00    MOV   A,[X+0]
        2170: 53 0D    MOV   [__r1],A
        2172: 55 0E 00 MOV   [__r0],0
        2175: 52 02    MOV   A,[X+2]
        2177: 04 0D    ADD   [__r1],A
        2179: 52 01    MOV   A,[X+1]
        217B: 0C 0E    ADC   [__r0],A
        217D: 51 0E    MOV   A,[__r0]
        217F: 10       PUSH  X
        2180: 58 0D    MOV   X,[__r1]
        2182: 28       ROMX  
        2183: 20       POP   X
        2184: 08       PUSH  A
        2185: 50 01    MOV   A,1
        2187: 08       PUSH  A
        2188: 9E 0C    CALL  _wrTxLm6023
        218A: 38 FE    ADD   SP,254
        218C: 77 00    INC   [X+0]
        218E: 3D 00 08 CMP   [X+0],8
        2191: A0 03    JZ    0x2195
        2193: CF B4    JC    0x2148
(0293) 			}
(0294) }
FILE: <library>
        2195: 38 FB    ADD   SP,251
        2197: 20       POP   X
        2198: 7F       RET   
__plcall:
        2199: 51 0E    MOV   A,[__r0]
        219B: 4D 0D    SWAP  X,[__r1]
        219D: 28       ROMX  
        219E: 08       PUSH  A
        219F: 51 0E    MOV   A,[__r0]
        21A1: 75       INC   X
        21A2: 09 00    ADC   A,0
        21A4: 28       ROMX  
        21A5: 08       PUSH  A
        21A6: 4D 0D    SWAP  X,[__r1]
        21A8: 7F       RET   
__divmod_16X16_16:
        21A9: 5A 02    MOV   [__rX],X
        21AB: 4F       MOV   X,SP
        21AC: 38 04    ADD   SP,4
        21AE: 56 00 10 MOV   [X+0],16
        21B1: 56 01 00 MOV   [X+1],0
        21B4: 52 FA    MOV   A,[X-6]
        21B6: 33 FC    XOR   A,[X-4]
        21B8: 39 80    CMP   A,128
        21BA: C0 04    JC    0x21BF
        21BC: 56 01 01 MOV   [X+1],1
        21BF: 48 FA 80 TST   [X-6],128
        21C2: A0 11    JZ    0x21D4
        21C4: 52 FB    MOV   A,[X-5]
        21C6: 73       CPL   A
        21C7: 54 FB    MOV   [X-5],A
        21C9: 52 FA    MOV   A,[X-6]
        21CB: 73       CPL   A
        21CC: 54 FA    MOV   [X-6],A
        21CE: 77 FB    INC   [X-5]
        21D0: D0 03    JNC   0x21D4
        21D2: 77 FA    INC   [X-6]
        21D4: 48 FC 80 TST   [X-4],128
        21D7: A0 14    JZ    0x21EC
        21D9: 2F 01 02 OR    [X+1],2
        21DC: 52 FD    MOV   A,[X-3]
        21DE: 73       CPL   A
        21DF: 54 FD    MOV   [X-3],A
        21E1: 52 FC    MOV   A,[X-4]
        21E3: 73       CPL   A
        21E4: 54 FC    MOV   [X-4],A
        21E6: 77 FD    INC   [X-3]
        21E8: D0 03    JNC   0x21EC
        21EA: 77 FC    INC   [X-4]
        21EC: 52 FA    MOV   A,[X-6]
        21EE: 54 02    MOV   [X+2],A
        21F0: 52 FB    MOV   A,[X-5]
        21F2: 54 03    MOV   [X+3],A
        21F4: 56 FA 00 MOV   [X-6],0
        21F7: 56 FB 00 MOV   [X-5],0
        21FA: 66 FD    ASL   [X-3]
        21FC: 6C FC    RLC   [X-4]
        21FE: 6C FB    RLC   [X-5]
        2200: 6C FA    RLC   [X-6]
        2202: C0 0B    JC    0x220E
        2204: 52 03    MOV   A,[X+3]
        2206: 15 FB    SUB   [X-5],A
        2208: 52 02    MOV   A,[X+2]
        220A: 1D FA    SBB   [X-6],A
        220C: 80 09    JMP   0x2216
        220E: 52 03    MOV   A,[X+3]
        2210: 05 FB    ADD   [X-5],A
        2212: 52 02    MOV   A,[X+2]
        2214: 0D FA    ADC   [X-6],A
        2216: 48 FA 80 TST   [X-6],128
        2219: B0 04    JNZ   0x221E
        221B: 2F FD 01 OR    [X-3],1
        221E: 7B 00    DEC   [X+0]
        2220: BF D9    JNZ   0x21FA
        2222: 48 FA 80 TST   [X-6],128
        2225: A0 09    JZ    0x222F
        2227: 52 03    MOV   A,[X+3]
        2229: 05 FB    ADD   [X-5],A
        222B: 52 02    MOV   A,[X+2]
        222D: 0D FA    ADC   [X-6],A
        222F: 48 01 01 TST   [X+1],1
        2232: A0 11    JZ    0x2244
        2234: 52 FD    MOV   A,[X-3]
        2236: 73       CPL   A
        2237: 54 FD    MOV   [X-3],A
        2239: 52 FC    MOV   A,[X-4]
        223B: 73       CPL   A
        223C: 54 FC    MOV   [X-4],A
        223E: 77 FD    INC   [X-3]
        2240: D0 03    JNC   0x2244
        2242: 77 FC    INC   [X-4]
        2244: 48 01 02 TST   [X+1],2
        2247: A0 11    JZ    0x2259
        2249: 52 FB    MOV   A,[X-5]
        224B: 73       CPL   A
        224C: 54 FB    MOV   [X-5],A
        224E: 52 FA    MOV   A,[X-6]
        2250: 73       CPL   A
        2251: 54 FA    MOV   [X-6],A
        2253: 77 FB    INC   [X-5]
        2255: D0 03    JNC   0x2259
        2257: 77 FA    INC   [X-6]
        2259: 38 FC    ADD   SP,252
        225B: 58 02    MOV   X,[__rX]
        225D: 7F       RET   
__divmodu_16X16_16:
        225E: 5A 02    MOV   [__rX],X
        2260: 4F       MOV   X,SP
        2261: 38 09    ADD   SP,9
        2263: 56 08 00 MOV   [X+8],0
        2266: 52 FD    MOV   A,[X-3]
        2268: 54 07    MOV   [X+7],A
        226A: 52 FC    MOV   A,[X-4]
        226C: 54 06    MOV   [X+6],A
        226E: 56 05 00 MOV   [X+5],0
        2271: 56 04 00 MOV   [X+4],0
        2274: 56 00 05 MOV   [X+0],5
        2277: 69 06    ASR   [X+6]
        2279: 6F 07    RRC   [X+7]
        227B: 6F 08    RRC   [X+8]
        227D: 7B 00    DEC   [X+0]
        227F: BF F7    JNZ   0x2277
        2281: 27 06 07 AND   [X+6],7
        2284: 56 03 00 MOV   [X+3],0
        2287: 52 FB    MOV   A,[X-5]
        2289: 54 02    MOV   [X+2],A
        228B: 52 FA    MOV   A,[X-6]
        228D: 54 01    MOV   [X+1],A
        228F: 56 00 05 MOV   [X+0],5
        2292: 69 01    ASR   [X+1]
        2294: 6F 02    RRC   [X+2]
        2296: 6F 03    RRC   [X+3]
        2298: 7B 00    DEC   [X+0]
        229A: BF F7    JNZ   0x2292
        229C: 27 01 07 AND   [X+1],7
        229F: 56 00 10 MOV   [X+0],16
        22A2: 66 08    ASL   [X+8]
        22A4: 6C 07    RLC   [X+7]
        22A6: 6C 06    RLC   [X+6]
        22A8: 6C 05    RLC   [X+5]
        22AA: 6C 04    RLC   [X+4]
        22AC: D0 0F    JNC   0x22BC
        22AE: 52 03    MOV   A,[X+3]
        22B0: 05 06    ADD   [X+6],A
        22B2: 52 02    MOV   A,[X+2]
        22B4: 0D 05    ADC   [X+5],A
        22B6: 52 01    MOV   A,[X+1]
        22B8: 0D 04    ADC   [X+4],A
        22BA: 80 0D    JMP   0x22C8
        22BC: 52 03    MOV   A,[X+3]
        22BE: 15 06    SUB   [X+6],A
        22C0: 52 02    MOV   A,[X+2]
        22C2: 1D 05    SBB   [X+5],A
        22C4: 52 01    MOV   A,[X+1]
        22C6: 1D 04    SBB   [X+4],A
        22C8: 48 04 80 TST   [X+4],128
        22CB: B0 04    JNZ   0x22D0
        22CD: 2F 08 01 OR    [X+8],1
        22D0: 7B 00    DEC   [X+0]
        22D2: BF CF    JNZ   0x22A2
        22D4: 52 08    MOV   A,[X+8]
        22D6: 54 FD    MOV   [X-3],A
        22D8: 52 07    MOV   A,[X+7]
        22DA: 54 FC    MOV   [X-4],A
        22DC: 48 04 80 TST   [X+4],128
        22DF: A0 0D    JZ    0x22ED
        22E1: 52 03    MOV   A,[X+3]
        22E3: 05 06    ADD   [X+6],A
        22E5: 52 02    MOV   A,[X+2]
        22E7: 0D 05    ADC   [X+5],A
        22E9: 52 01    MOV   A,[X+1]
        22EB: 0D 04    ADC   [X+4],A
        22ED: 56 00 03 MOV   [X+0],3
        22F0: 69 04    ASR   [X+4]
        22F2: 6F 05    RRC   [X+5]
        22F4: 6F 06    RRC   [X+6]
        22F6: 7B 00    DEC   [X+0]
        22F8: BF F7    JNZ   0x22F0
        22FA: 52 05    MOV   A,[X+5]
        22FC: 54 FA    MOV   [X-6],A
        22FE: 52 06    MOV   A,[X+6]
        2300: 54 FB    MOV   [X-5],A
        2302: 38 F7    ADD   SP,247
        2304: 58 02    MOV   X,[__rX]
        2306: 7F       RET   
--------------------------------------------------------------------------------


PSoC Designer Version: 4.1.931.0

Copyright (C) 1994 - 2001 ImageCraft
ImageCraft, 706 Colorado Ave., Suite 10-88, Palo Alto, CA 94303
info@imagecraft.com, phone (650) 493-9326 FAX (650) 493-9329
http://www.imagecraft.com
lcc source code (C) 1995, by David R. Hanson and AT&T. Reproduced by permission.
Code Compressor V1.08
ICCM8C version V1.28
