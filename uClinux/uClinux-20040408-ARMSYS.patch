diff -urN uClinux-dist/linux-2.4.x/arch/armnommu/boot/compressed/head.S linux-2.4.x/arch/armnommu/boot/compressed/head.S
--- uClinux-dist/linux-2.4.x/arch/armnommu/boot/compressed/head.S	2004-02-17 20:52:18.000000000 +0800
+++ linux-2.4.x/arch/armnommu/boot/compressed/head.S	2004-05-18 09:52:01.000000000 +0800
@@ -10,7 +10,7 @@
 #include <linux/config.h>
 #include <linux/linkage.h>
 
-#ifdef CONFIG_BOARD_SNDS100
+#if defined(CONFIG_BOARD_SNDS100) || defined(CONFIG_BOARD_MBA44)
 #include <asm/hardware.h>
 #endif
 
@@ -154,7 +154,7 @@
 		str	r1, [r0]
 
 		ldr	r0, =IOPDATA
-		ldr	r1, =0xEF
+		ldr	r1, =0xaa @0xEF
 		str	r1, [r0]
 
 		/* copy image to ram */
@@ -187,7 +187,7 @@
 		blt	1b
 
 #ifdef CONFIG_CPU_WITH_CACHE
-#ifndef CONFIG_BOARD_SNDS100
+#if !defined(CONFIG_BOARD_SNDS100) && !defined(CONFIG_BOARD_MBA44)
 		mrc	p15, 0, r6, c0, c0	@ get processor ID
 		bl	cache_on
 #endif
@@ -199,17 +199,24 @@
 		orr	r2, r2, #6
 		str	r2, [r0]
 #endif
+
+#ifdef CONFIG_BOARD_MBA44
+		ldr	r0, =S3C44B0X_SYSCFG
+		ldr	r2, [r0]
+		orr	r2, r2, #0xe
+		str	r2, [r0]
+#endif
 #endif	
 
 		mov	r1, sp			@ malloc space above stack
 		add	r2, sp, #0x10000	@ 64k max
 
-#ifndef CONFIG_BOARD_SNDS100
+#if !defined(CONFIG_BOARD_SNDS100) && !defined(CONFIG_BOARD_MBA44)
 		teq	r4, r5			@ will we overwrite ourselves?
 		moveq	r5, r2			@ decompress after image
 		movne	r5, r4			@ decompress to final location
 #endif
-#ifdef CONFIG_BOARD_SNDS100
+#if defined(CONFIG_BOARD_SNDS100) || defined(CONFIG_BOARD_MBA44)
 		mov	r5, r2			@ decompress after image
 #endif
 		mov	r0, r5
@@ -429,7 +436,14 @@
 		str	r1, [r0]
 		mov	pc, lr
 #endif
-#ifndef CONFIG_BOARD_SNDS100
+#ifdef CONFIG_BOARD_MBA44
+		ldr	r0, =S3C44B0X_SYSCFG
+		ldr	r1, [r0]
+		bic	r1, r1, #0xe
+		str	r1, [r0]
+		mov	pc, lr
+#endif
+#if !defined(CONFIG_BOARD_SNDS100) && !defined(CONFIG_BOARD_MBA44)
 #ifdef CONFIG_CPU_ARM610
 		eor	r1, r6, #0x41000000
 		eor	r1, r1, #0x00560000
@@ -485,7 +499,10 @@
 		bne	cache_flush_loop
 		mov	pc, lr
 #endif
-#ifndef CONFIG_BOARD_SNDS100
+#ifdef CONFIG_BOARD_MBA44
+		mov	pc, lr
+#endif
+#if !defined(CONFIG_BOARD_SNDS100) && !defined(CONFIG_BOARD_MBA44)
 		ldr	r1, proc_sa110_type
 		eor	r1, r1, r6
 		movs	r1, r1, lsr #5		@ catch SA110 and SA1100
diff -urN uClinux-dist/linux-2.4.x/arch/armnommu/boot/Makefile linux-2.4.x/arch/armnommu/boot/Makefile
--- uClinux-dist/linux-2.4.x/arch/armnommu/boot/Makefile	2004-02-17 20:52:18.000000000 +0800
+++ linux-2.4.x/arch/armnommu/boot/Makefile	2004-03-24 22:45:28.000000000 +0800
@@ -117,6 +117,11 @@
 endif
 endif
 
+ifeq ($(CONFIG_BOARD_MBA44),y)
+ZTEXTADDR	= 0x0c000000
+ZRELADDR	= 0x0c008000
+endif
+
 #
 # If you don't define ZRELADDR above,
 # then it defaults to ZTEXTADDR
diff -urN uClinux-dist/linux-2.4.x/arch/armnommu/config.in linux-2.4.x/arch/armnommu/config.in
--- uClinux-dist/linux-2.4.x/arch/armnommu/config.in	2004-02-17 20:52:18.000000000 +0800
+++ linux-2.4.x/arch/armnommu/config.in	2004-05-18 09:51:04.000000000 +0800
@@ -349,13 +349,13 @@
     define_bool CONFIG_NO_PGT_CACHE         y
     define_bool CONFIG_CPU_WITH_CACHE       y
     define_bool CONFIG_CPU_WITH_MCR_INSTRUCTION n
-    define_int  CONFIG_ARM_CLK              60000000
-    define_bool CONFIG_SERIAL_S3C44B0X      y
-    define_int  CONFIG_FORCE_MAX_ZONEORDER  5
+    define_int  CONFIG_ARM_CLK              64000000 #72000000 #60000000
+#    define_bool CONFIG_SERIAL_S3C44B0X      y
+#    define_int  CONFIG_FORCE_MAX_ZONEORDER  5
     if [ "$CONFIG_SET_MEM_PARAM" = "n" ]; then
-       define_hex DRAM_BASE      0x00000000
+       define_hex DRAM_BASE      0x0C000000
        define_hex DRAM_SIZE      0x00800000
-       define_hex FLASH_MEM_BASE 0x01000000
+       define_hex FLASH_MEM_BASE 0x00000000
        define_hex FLASH_SIZE     0x00200000
     fi
 fi
@@ -391,7 +391,7 @@
    define_bool CONFIG_CPU_WITH_MCR_INSTRUCTION n
    if [ "$CONFIG_SET_MEM_PARAM" = "n" ]; then
      define_hex DRAM_BASE 0x00000000
-     define_hex DRAM_SIZE 0x00800000
+     define_hex DRAM_SIZE 0x01000000
      define_hex FLASH_MEM_BASE 0x01000000
      define_hex FLASH_SIZE 0x00200000
    fi
@@ -561,12 +561,16 @@
      "$CONFIG_ARCH_EBSA110" = "y" -o   \
      "$CONFIG_ARCH_EBSA285" = "y" -o   \
      "$CONFIG_ARCH_CO285" = "y" -o     \
+     "$CONFIG_BOARD_SNDS100" = "y" -o  \
+     "$CONFIG_CPU_S3C44B0X" = "y" -o   \
      "$CONFIG_ARCH_SA1100" = "y" ]; then
    bool 'Timer and CPU usage LEDs' CONFIG_LEDS
    if [ "$CONFIG_LEDS" = "y" ]; then
       if [ "$CONFIG_ARCH_NETWINDER" = "y" -o \
 	   "$CONFIG_ARCH_EBSA285" = "y" -o   \
 	   "$CONFIG_ARCH_CO285" = "y" -o     \
+     	   "$CONFIG_BOARD_SNDS100" = "y" -o  \
+     	   "$CONFIG_CPU_S3C44B0X" = "y" -o   \
 	   "$CONFIG_ARCH_SA1100" = "y" ]; then
          bool '  Timer LED' CONFIG_LEDS_TIMER
          bool '  CPU usage LED' CONFIG_LEDS_CPU
diff -urN uClinux-dist/linux-2.4.x/arch/armnommu/kernel/head-armv.S linux-2.4.x/arch/armnommu/kernel/head-armv.S
--- uClinux-dist/linux-2.4.x/arch/armnommu/kernel/head-armv.S	2004-02-17 20:52:18.000000000 +0800
+++ linux-2.4.x/arch/armnommu/kernel/head-armv.S	2004-05-18 11:39:29.000000000 +0800
@@ -21,6 +21,10 @@
 #include <asm/mach-types.h>
 #include <asm/mach/arch.h>
 
+#ifdef CONFIG_BOARD_MBA44
+#include <asm/arch/hardware.h>
+#endif
+
 #define K(a,b,c)	((a) << 24 | (b) << 12 | (c))
 
 /*
@@ -72,6 +76,7 @@
 .section ".text.init",#alloc,#execinstr
 		.type	stext, #function
 ENTRY(stext)
+#if defined(CONFIG_ROMKERNEL)
 #if defined(CONFIG_CPU_S3C44B0X)
 /*
  * We assume that there is a bootloader that has jump instructions at all
@@ -89,6 +94,7 @@
 		b	vector_FIQ		/* 0x1C FIQ */
 99:
 #endif
+#endif
                 mov	r12, r0
 /*
  * NOTE!  Any code which is placed here should be done for one of
@@ -241,6 +247,12 @@
 	str     r2, [r6]
 	mov     r2, #MACH_TYPE_SNDS100
 	str     r2, [r9]
+		
+		/* cache/write buffer on */
+		ldr	r0, S3C4510_SYSCFG @=SYSCFG
+		ldr	r2, [r0]
+		orr	r2, r2, #6
+		str	r2, [r0]
 
         mov fp, #0
         b	start_kernel
@@ -253,6 +265,8 @@
 	
 S3C4510B_PROCESSOR_TYPE:
 	.long	0x36365036
+S3C4510_SYSCFG:
+	.long	0x03ff0000
 #endif
 
 #if defined(CONFIG_ARCH_TA7S) || defined(CONFIG_ARCH_TA7V)
@@ -389,6 +403,11 @@
 		str	r3, [r6]
 #endif
 #if     defined(CONFIG_CPU_S3C44B0X)
+		ldr	r9, =S3C44B0X_SYSCFG
+		ldr	r3, [r9]
+		orr	r3, r3, #0xe
+		str	r3, [r9]	@enable cache and write buffer
+
 		ldr	r3, S3C44B0X_PROCESSOR_TYPE
 		str	r3, [r5]
 		
diff -urN uClinux-dist/linux-2.4.x/arch/armnommu/kernel/setup.c linux-2.4.x/arch/armnommu/kernel/setup.c
--- uClinux-dist/linux-2.4.x/arch/armnommu/kernel/setup.c	2004-02-17 20:52:18.000000000 +0800
+++ linux-2.4.x/arch/armnommu/kernel/setup.c	2004-03-24 23:31:59.000000000 +0800
@@ -38,7 +38,7 @@
 #endif
 
 #ifndef CONFIG_CMDLINE
-#define CONFIG_CMDLINE "root=/dev/rom0"
+#define CONFIG_CMDLINE "root=/dev/rom0 init=/linuxrc"
 #endif
   
 #ifdef CONFIG_ARCH_NETARM
diff -urN uClinux-dist/linux-2.4.x/arch/armnommu/mach-S3C44B0X/arch.c linux-2.4.x/arch/armnommu/mach-S3C44B0X/arch.c
--- uClinux-dist/linux-2.4.x/arch/armnommu/mach-S3C44B0X/arch.c	2004-02-17 20:52:21.000000000 +0800
+++ linux-2.4.x/arch/armnommu/mach-S3C44B0X/arch.c	2004-03-23 23:44:41.000000000 +0800
@@ -31,3 +31,4 @@
 	/*
 	 * @todo activate the hardware reset
 	 */
+}
diff -urN uClinux-dist/linux-2.4.x/arch/armnommu/mach-S3C44B0X/fs44b0-leds.c linux-2.4.x/arch/armnommu/mach-S3C44B0X/fs44b0-leds.c
--- uClinux-dist/linux-2.4.x/arch/armnommu/mach-S3C44B0X/fs44b0-leds.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.4.x/arch/armnommu/mach-S3C44B0X/fs44b0-leds.c	2004-05-18 09:57:36.000000000 +0800
@@ -0,0 +1,112 @@
+/*
+ * LED driver for the Atmel AT91RM9200 Development Kit.
+ *
+ * (c) SAN People (Pty) Ltd
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+*/
+
+//added by antiscle
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include <asm/mach-types.h>
+#include <asm/leds.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/arch/hardware.h>
+
+
+static inline void leds_off(void)
+{
+	outl(inl(S3C44B0X_PDATE)&~(3<<2), S3C44B0X_PDATE);
+}
+
+static inline void leds_on(void)
+{
+	outl(inl(S3C44B0X_PDATE)|(3<<2), S3C44B0X_PDATE);
+}
+
+static inline void timer_led_toggle(void)
+{
+	outl(inl(S3C44B0X_PDATE)^(1<<2), S3C44B0X_PDATE);
+}
+
+static inline void busy_led_off(void)
+{
+	outl(inl(S3C44B0X_PDATE)&~(1<<3), S3C44B0X_PDATE);
+}
+
+static inline void busy_led_on(void)
+{
+	outl(inl(S3C44B0X_PDATE)|(1<<3), S3C44B0X_PDATE);
+}
+
+/*
+ * Handle LED events.
+ */
+static void fs44b0_leds_event(led_event_t evt)
+{
+	unsigned long flags;
+		
+	local_irq_save(flags);
+
+	switch(evt) {
+	case led_start:		/* System startup */
+		leds_on();
+		break;
+
+	case led_stop:		/* System stop / suspend */
+		leds_off();
+		break;
+
+#ifdef CONFIG_LEDS_TIMER
+	case led_timer:		/* Every 50 timer ticks */
+		timer_led_toggle();
+		break;
+#endif
+
+#ifdef CONFIG_LEDS_CPU
+	case led_idle_start:	/* Entering idle state */
+		busy_led_off();
+		break;
+
+	case led_idle_end:	/* Exit idle state */
+		busy_led_on();
+		break;
+#endif
+
+	default:
+		break;
+	}
+
+	local_irq_restore(flags);
+}
+
+
+static int __init leds_init(void)
+{
+	/* Enable PIO to access the LEDs
+	*outl((inl(S3C44B0X_PCONE)&~(0xf0))|0x50, S3C44B0X_PCONE);
+	*/
+       outl(0x15569, S3C44B0X_PCONE);
+ 
+#ifdef CONFIG_LEDS_TIMER
+//	printk("LEDS_TIMER init\n");
+#endif
+#ifdef CONFIG_LEDS_CPU
+//	printk("LEDS_CPU init\n");
+#endif
+	//leds_event = fs44b0_leds_event;//temp for make
+
+	//leds_event(led_start);//temp for make
+	return 0;
+}
+
+__initcall(leds_init);
diff -urN uClinux-dist/linux-2.4.x/arch/armnommu/mach-S3C44B0X/Makefile linux-2.4.x/arch/armnommu/mach-S3C44B0X/Makefile
--- uClinux-dist/linux-2.4.x/arch/armnommu/mach-S3C44B0X/Makefile	2004-02-17 20:52:21.000000000 +0800
+++ linux-2.4.x/arch/armnommu/mach-S3C44B0X/Makefile	2004-05-17 11:24:40.000000000 +0800
@@ -20,4 +20,8 @@
 
 export-objs		:= 
 
+# LEDs support
+leds-$(CONFIG_CPU_S3C44B0X) += fs44b0-leds.o
+obj-$(CONFIG_LEDS) += $(leds-y)
+
 include $(TOPDIR)/Rules.make
diff -urN uClinux-dist/linux-2.4.x/arch/armnommu/mach-S3C44B0X/time.c linux-2.4.x/arch/armnommu/mach-S3C44B0X/time.c
--- uClinux-dist/linux-2.4.x/arch/armnommu/mach-S3C44B0X/time.c	2004-02-17 20:52:21.000000000 +0800
+++ linux-2.4.x/arch/armnommu/mach-S3C44B0X/time.c	2004-05-17 11:25:04.000000000 +0800
@@ -23,9 +23,9 @@
 {
 	return (inw(S3C44B0X_TCNTB5) / CLOCKS_PER_USEC);
 }
-
+/*
 void s3c44b0x_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
 	do_timer(regs);
-}
+}*/
 
diff -urN uClinux-dist/linux-2.4.x/arch/armnommu/mach-snds100/fs4510-leds.c linux-2.4.x/arch/armnommu/mach-snds100/fs4510-leds.c
--- uClinux-dist/linux-2.4.x/arch/armnommu/mach-snds100/fs4510-leds.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.4.x/arch/armnommu/mach-snds100/fs4510-leds.c	2004-05-18 09:57:14.000000000 +0800
@@ -0,0 +1,109 @@
+/*
+ * LED driver for the Atmel AT91RM9200 Development Kit.
+ *
+ * (c) SAN People (Pty) Ltd
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+*/
+
+//added by antiscle
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include <asm/mach-types.h>
+#include <asm/leds.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/arch/hardware.h>
+
+
+static inline void leds_off(void)
+{
+	outl(inl(IOPDATA)|0x3, IOPDATA);
+}
+
+static inline void leds_on(void)
+{
+	outl(inl(IOPDATA)&~0x3, IOPDATA);
+}
+
+static inline void timer_led_toggle(void)
+{
+	outl(inl(IOPDATA)^0x1, IOPDATA);
+}
+
+static inline void busy_led_off(void)
+{
+	outl(inl(IOPDATA)|0x2, IOPDATA);
+}
+
+static inline void busy_led_on(void)
+{
+	outl(inl(IOPDATA)&~0x2, IOPDATA);
+}
+
+/*
+ * Handle LED events.
+ */
+static void fs44b0_leds_event(led_event_t evt)
+{
+	unsigned long flags;
+		
+	local_irq_save(flags);
+
+	switch(evt) {
+	case led_start:		/* System startup */
+		leds_on();
+		break;
+
+	case led_stop:		/* System stop / suspend */
+		leds_off();
+		break;
+
+#ifdef CONFIG_LEDS_TIMER
+	case led_timer:		/* Every 50 timer ticks */
+		timer_led_toggle();
+		break;
+#endif
+
+#ifdef CONFIG_LEDS_CPU
+	case led_idle_start:	/* Entering idle state */
+		busy_led_off();
+		break;
+
+	case led_idle_end:	/* Exit idle state */
+		busy_led_on();
+		break;
+#endif
+
+	default:
+		break;
+	}
+
+	local_irq_restore(flags);
+}
+
+
+static int __init leds_init(void)
+{
+	/* Enable PIO to access the LEDs */
+
+#ifdef CONFIG_LEDS_TIMER
+//	printk("LEDS_TIMER init\n");
+#endif
+#ifdef CONFIG_LEDS_CPU
+//	printk("LEDS_CPU init\n");
+#endif
+	leds_event = fs44b0_leds_event;
+
+	leds_event(led_start);
+	return 0;
+}
+
+__initcall(leds_init);
diff -urN uClinux-dist/linux-2.4.x/arch/armnommu/mach-snds100/Makefile linux-2.4.x/arch/armnommu/mach-snds100/Makefile
--- uClinux-dist/linux-2.4.x/arch/armnommu/mach-snds100/Makefile	2004-02-17 20:52:21.000000000 +0800
+++ linux-2.4.x/arch/armnommu/mach-snds100/Makefile	2004-05-18 09:53:45.000000000 +0800
@@ -18,4 +18,8 @@
 
 export-objs		:= 
 
+# LEDs support
+leds-$(CONFIG_CPU_S3C44B0X) += fs4510-leds.o
+obj-$(CONFIG_LEDS) += $(leds-y)
+
 include $(TOPDIR)/Rules.make
diff -urN uClinux-dist/linux-2.4.x/arch/armnommu/mach-snds100/time.c linux-2.4.x/arch/armnommu/mach-snds100/time.c
--- uClinux-dist/linux-2.4.x/arch/armnommu/mach-snds100/time.c	2004-02-17 20:52:21.000000000 +0800
+++ linux-2.4.x/arch/armnommu/mach-snds100/time.c	2004-05-18 10:02:57.000000000 +0800
@@ -13,8 +13,8 @@
 {
 	return 0;
 }
-
+/*
 void samsung_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
         do_timer(regs);
-}
+}*/
diff -urN uClinux-dist/linux-2.4.x/arch/armnommu/Makefile linux-2.4.x/arch/armnommu/Makefile
--- uClinux-dist/linux-2.4.x/arch/armnommu/Makefile	2004-02-17 20:52:18.000000000 +0800
+++ linux-2.4.x/arch/armnommu/Makefile	2004-03-23 23:47:56.000000000 +0800
@@ -239,10 +239,10 @@
 endif
 
 ifeq ($(CONFIG_BOARD_MBA44),y)
-TEXTADDR   	 = 0x0c000000
+TEXTADDR   	 = 0x0c008000
 MACHINE          = S3C44B0X
 INCDIR           = $(MACHINE)
-CORE_FILES	:= $(CORE_FILES) romfs.o
+CORE_FILES	:= $(CORE_FILES) #romfs.o
 endif
 
 ifeq ($(CONFIG_ARCH_C5471), y)
diff -urN uClinux-dist/linux-2.4.x/arch/armnommu/mm/init.c linux-2.4.x/arch/armnommu/mm/init.c
--- uClinux-dist/linux-2.4.x/arch/armnommu/mm/init.c	2004-02-17 20:52:21.000000000 +0800
+++ linux-2.4.x/arch/armnommu/mm/init.c	2004-04-02 00:15:20.000000000 +0800
@@ -380,6 +380,9 @@
 	    machine_is_netarm()    || machine_is_evS3C4530HEI() ||
 	    machine_is_smdk2500() || machine_is_S3C2500REFRGP() )
 		reserve_bootmem_node(pgdat, 0, __pa(&_stext));
+	
+	if(machine_is_S3C44B0X())
+		reserve_bootmem_node(pgdat, DRAM_BASE, __pa(&_stext)-DRAM_BASE);
 
 
 	/*
@@ -659,7 +662,7 @@
 	    !machine_is_cx821xx() &&
 	    !machine_is_atmel() &&
 	    !machine_is_netarm() &&
-	    !machine_is_ta7v() &&
+//	    !machine_is_ta7v() &&
 	    !machine_is_ta7s()) {
 		free_area((unsigned long)(&__init_begin),
 			  (unsigned long)(&__init_end),
diff -urN uClinux-dist/linux-2.4.x/drivers/block/blkmem.c linux-2.4.x/drivers/block/blkmem.c
--- uClinux-dist/linux-2.4.x/drivers/block/blkmem.c	2004-02-17 20:52:52.000000000 +0800
+++ linux-2.4.x/drivers/block/blkmem.c	2004-05-18 10:20:56.000000000 +0800
@@ -381,7 +381,11 @@
 #endif
 
 #ifdef CONFIG_BOARD_SNDS100
-	{0, romfs_data, -1},
+	{0, 0x01100000, -1},//	{0, romfs_data, -1},
+#endif
+
+#ifdef CONFIG_BOARD_MBA44
+	{0, 0xc700000, -1},/*{0, 0x100000, -1},*/
 #endif
 
 #if defined(CONFIG_ARCH_CNXT) && !defined(CONFIG_ARCH_CX821XX)
diff -urN uClinux-dist/linux-2.4.x/drivers/char/Config.in linux-2.4.x/drivers/char/Config.in
--- uClinux-dist/linux-2.4.x/drivers/char/Config.in	2004-02-17 20:52:53.000000000 +0800
+++ linux-2.4.x/drivers/char/Config.in	2004-03-25 23:31:37.000000000 +0800
@@ -239,6 +239,8 @@
   fi
 fi
 
+source drivers/serial/Config.in
+
 bool 'LED Manager support' CONFIG_LEDMAN
 bool 'DS1302 Real Time Clock support' CONFIG_DS1302
 
diff -urN uClinux-dist/linux-2.4.x/drivers/char/Makefile linux-2.4.x/drivers/char/Makefile
--- uClinux-dist/linux-2.4.x/drivers/char/Makefile	2004-02-17 20:52:53.000000000 +0800
+++ linux-2.4.x/drivers/char/Makefile	2004-03-26 00:43:22.000000000 +0800
@@ -237,7 +237,7 @@
 obj-$(CONFIG_SERIAL_SAMSUNG) += serial_samsung.o
 obj-$(CONFIG_SERIAL_S3C2500) += serial_s3c2500.o
 obj-$(CONFIG_SERIAL_S3C3410) += serial_s3c3410.o
-obj-$(CONFIG_SERIAL_S3C44B0X) += serial_s3c44b0x.o
+#obj-$(CONFIG_SERIAL_S3C44B0X) += serial_s3c44b0x.o
 obj-$(CONFIG_SERIAL_S3C4530) += serial_s3c4530.o
 obj-$(CONFIG_SERIAL_CNXT) += cnxtserial.o
 obj-$(CONFIG_SERIAL_KS8695) += serial_ks8695.o generic_serial.o
diff -urN uClinux-dist/linux-2.4.x/drivers/char/serial_samsung.c linux-2.4.x/drivers/char/serial_samsung.c
--- uClinux-dist/linux-2.4.x/drivers/char/serial_samsung.c	2004-02-17 20:52:57.000000000 +0800
+++ linux-2.4.x/drivers/char/serial_samsung.c	2004-05-18 09:48:49.000000000 +0800
@@ -4466,7 +4466,7 @@
 	static struct async_struct *info;
 	struct serial_state *state;
 	unsigned cval;
-	int	baud = 19200;
+	int	baud = 57600;
 	int	bits = 8;
 	int	parity = 'n';
 	int	doflow = 0;
diff -urN uClinux-dist/linux-2.4.x/drivers/Makefile linux-2.4.x/drivers/Makefile
--- uClinux-dist/linux-2.4.x/drivers/Makefile	2004-02-17 20:52:48.000000000 +0800
+++ linux-2.4.x/drivers/Makefile	2004-03-25 23:23:40.000000000 +0800
@@ -8,9 +8,9 @@
 
 mod-subdirs :=	dio hil mtd sbus video macintosh usb input telephony ide \
 		message/i2o message/fusion scsi md ieee1394 pnp isdn atm \
-		fc4 net/hamradio i2c acpi bluetooth usb/gadget
+		fc4 net/hamradio i2c acpi bluetooth usb/gadget serial
 
-subdir-y :=	parport char block net sound misc media cdrom hotplug
+subdir-y :=	parport char block net sound misc media cdrom hotplug serial
 subdir-m :=	$(subdir-y)
 
 
diff -urN uClinux-dist/linux-2.4.x/drivers/mtd/nand/Config.in linux-2.4.x/drivers/mtd/nand/Config.in
--- uClinux-dist/linux-2.4.x/drivers/mtd/nand/Config.in	2004-02-17 20:53:08.000000000 +0800
+++ linux-2.4.x/drivers/mtd/nand/Config.in	2004-05-15 16:19:32.000000000 +0800
@@ -33,4 +33,8 @@
 fi
 fi
 
+if [ "$CONFIG_CPU_S3C44B0X" = "y" ]; then
+   dep_tristate '  NAND Flash device on FS44B0-CORE V2.00 board' CONFIG_MTD_NAND_S3C44B0X $CONFIG_MTD_NAND
+fi
+
 endmenu
diff -urN uClinux-dist/linux-2.4.x/drivers/mtd/nand/Makefile linux-2.4.x/drivers/mtd/nand/Makefile
--- uClinux-dist/linux-2.4.x/drivers/mtd/nand/Makefile	2004-02-17 20:53:08.000000000 +0800
+++ linux-2.4.x/drivers/mtd/nand/Makefile	2004-05-15 16:16:11.000000000 +0800
@@ -12,5 +12,6 @@
 obj-$(CONFIG_MTD_NAND_AUTCPU12)	+= autcpu12.o
 obj-$(CONFIG_MTD_NAND_EDB7312)  += edb7312.o
 obj-$(CONFIG_MTD_NAND_IDS)	+= nand_ids.o
+obj-$(CONFIG_MTD_NAND_S3C44B0X) += s3c44b0x.o
 
 include $(TOPDIR)/Rules.make
diff -urN uClinux-dist/linux-2.4.x/drivers/net/8390.h linux-2.4.x/drivers/net/8390.h
--- uClinux-dist/linux-2.4.x/drivers/net/8390.h	2004-02-17 20:53:08.000000000 +0800
+++ linux-2.4.x/drivers/net/8390.h	2004-05-17 11:28:08.000000000 +0800
@@ -50,7 +50,6 @@
 extern int ei_open(struct net_device *dev);
 extern int ei_close(struct net_device *dev);
 extern void ei_interrupt(int irq, void *dev_id, struct pt_regs *regs);
-extern struct net_device *alloc_ei_netdev(void);
 
 /* Most of these entries should be in 'struct net_device' (or most of the
    things in there should be here!) */
@@ -115,10 +114,16 @@
  *	Only generate indirect loads given a machine that needs them.
  *      - removed AMIGA_PCMCIA from this list, handled as ISA io now
  */
- 
+#ifdef	CONFIG_NE2000_16b
+#define	ETH_ADDR_SFT	(9) //(1)
+#else
+#define	ETH_ADDR_SFT	(8) //(0)
+#endif
+
 #if defined(CONFIG_MAC) ||  \
-    defined(CONFIG_ZORRO8390) || defined(CONFIG_ZORRO8390_MODULE) || \
-    defined(CONFIG_HYDRA) || defined(CONFIG_HYDRA_MODULE)
+    defined(CONFIG_ARIADNE2) || defined(CONFIG_ARIADNE2_MODULE) || \
+    defined(CONFIG_HYDRA) || defined(CONFIG_HYDRA_MODULE) || \
+    defined(CONFIG_ARM_ETHERH) || defined(CONFIG_ARM_ETHERH_MODULE)
 #define EI_SHIFT(x)	(ei_local->reg_offset[x])
 #undef inb
 #undef inb_p
@@ -130,10 +135,8 @@
 #define inb_p(port)   in_8(port)
 #define outb_p(val,port)  out_8(port,val)
 
-#elif defined(CONFIG_ARM_ETHERH) || defined(CONFIG_ARM_ETHERH_MODULE)
-#define EI_SHIFT(x)    (ei_local->reg_offset[x])
 #else
-#define EI_SHIFT(x)	(x)
+#define EI_SHIFT(x)	((x)<<ETH_ADDR_SFT)
 #endif
 
 #define E8390_CMD	EI_SHIFT(0x00)  /* The command register (for all pages) */
diff -urN uClinux-dist/linux-2.4.x/drivers/net/Config.in linux-2.4.x/drivers/net/Config.in
--- uClinux-dist/linux-2.4.x/drivers/net/Config.in	2004-02-17 20:53:08.000000000 +0800
+++ linux-2.4.x/drivers/net/Config.in	2004-05-17 11:27:38.000000000 +0800
@@ -177,6 +177,9 @@
       tristate '    LP486E on board Ethernet' CONFIG_LP486E
       tristate '    ICL EtherTeam 16i/32 support' CONFIG_ETH16I
       tristate '    NE2000/NE1000 support' CONFIG_NE2000
+      if [ "$CONFIG_NE2000" = "y" -o "CONFIG_NE2000" = "m" ]; then
+	bool '       16Bits mode support' CONFIG_NE2000_16b
+      fi
       if [ "$CONFIG_OBSOLETE" = "y" ]; then
 	 dep_tristate '    SEEQ8005 support (EXPERIMENTAL)' CONFIG_SEEQ8005 $CONFIG_EXPERIMENTAL
       fi
diff -urN uClinux-dist/linux-2.4.x/drivers/net/ne.c linux-2.4.x/drivers/net/ne.c
--- uClinux-dist/linux-2.4.x/drivers/net/ne.c	2004-02-17 20:53:12.000000000 +0800
+++ linux-2.4.x/drivers/net/ne.c	2004-05-17 11:27:56.000000000 +0800
@@ -130,10 +130,10 @@
 /* ---- No user-serviceable parts below ---- */
 
 #define NE_BASE	 (dev->base_addr)
-#define NE_CMD	 	0x00
-#define NE_DATAPORT	0x10	/* NatSemi-defined port window offset. */
-#define NE_RESET	0x1f	/* Issue a read to reset, a write to clear. */
-#define NE_IO_EXTENT	0x20
+#define NE_CMD		0x00
+#define NE_DATAPORT	(0x10<<ETH_ADDR_SFT)	/* NatSemi-defined port window offset. */
+#define NE_RESET	(0x1f<<ETH_ADDR_SFT)	/* Issue a read to reset, a write to clear. */
+#define NE_IO_EXTENT	(0x20<<ETH_ADDR_SFT)
 
 #define NE1SM_START_PG	0x20	/* First page of TX buffer */
 #define NE1SM_STOP_PG 	0x40	/* Last page +1 of RX ring */
@@ -203,6 +203,13 @@
 	dev->base_addr = base_addr = NE2000_ADDR;
 	dev->irq = NE2000_IRQ_VECTOR;
 	once++;
+#elif defined(CONFIG_BOARD_MBA44)
+	static int once = 0;
+	if (once)
+		return -ENXIO;
+	dev->base_addr = base_addr = 0x08000000;//NE2000_ADDR;
+	dev->irq = 24;//NE2000_IRQ_VECTOR;
+	once++;
 #endif
 
 	SET_MODULE_OWNER(dev);
@@ -281,7 +288,7 @@
 	int reg0, ret;
 	static unsigned version_printed;
 
-#if !defined(CONFIG_COLDFIRE)
+#if !defined(CONFIG_COLDFIRE) && !defined(CONFIG_CPU_H8300H)
 	if (!request_region(ioaddr, NE_IO_EXTENT, dev->name))
 		return -EBUSY;
 #endif
@@ -373,6 +380,7 @@
 	for(i = 0; i < 32 /*sizeof(SA_prom)*/; i+=2) {
 		SA_prom[i] = inb(ioaddr + NE_DATAPORT);
 		SA_prom[i+1] = inb(ioaddr + NE_DATAPORT);
+//			printk("%p=%x,%x\n", ioaddr + NE_DATAPORT, SA_prom[i], SA_prom[i+1]);			
 		if (SA_prom[i] != SA_prom[i+1])
 			wordlength = 1;
 	}
@@ -456,7 +464,29 @@
 	}
 	SA_prom[14] = SA_prom[15] = 0x57;
     }
-#endif /* CONFIG_M5206e */
+#elif defined(CONFIG_BOARD_MBA44)
+    {
+	unsigned char ne_defethaddr[6] = {0x00, 0x80, 0x49, 0x12, 0x34, 0x56};
+//	ne_defethaddr[5]++;
+
+	printk("NE2000 driver modified by antisle, Http://www.uCdragon.com\n");
+	outb_p(E8390_NODMA+E8390_PAGE1+E8390_STOP, ioaddr + E8390_CMD);
+	for(i = 0; i < 6; i++)
+	{
+		SA_prom[i] = ne_defethaddr[i];
+	}
+	SA_prom[14] = SA_prom[15] = 0x57;
+  #if (ETH_ADDR_SFT==0)
+	wordlength = 1;
+	/* We must set the 8390 for 8bit mode. */
+        outb_p(0x48, ioaddr + EN0_DCFG);
+  #else
+	wordlength = 2;
+	/* We must set the 8390 for 16bit mode. */	
+	outb_p(0x49, ioaddr + EN0_DCFG);
+  #endif
+    }
+#endif /* CONFIG_BOARD_MBA44 */
 
 #if !(defined(CONFIG_M5206e) && defined(CONFIG_NETtel))
 	if (wordlength == 2)
@@ -479,6 +509,10 @@
 	stop_page = NESM_STOP_PG;
 	H8300_INIT_NE();
 #endif
+#if defined(CONFIG_BOARD_MBA44)
+	start_page = NESM_START_PG;
+	stop_page = NESM_STOP_PG;	
+#endif
 
 	neX000 = (SA_prom[14] == 0x57  &&  SA_prom[15] == 0x57);
 	ctron =  (SA_prom[0] == 0x00 && SA_prom[1] == 0x00 && SA_prom[2] == 0x1d);
@@ -578,7 +612,7 @@
 		dev->dev_addr[i] = SA_prom[i];
 	}
 
-	printk("\n%s: %s found at %#x, using IRQ %d.\n",
+	printk("\n%s: %s found at %#x, using IRQ %d\n",
 		dev->name, name, ioaddr, dev->irq);
 
 	ei_status.name = name;
@@ -670,6 +704,7 @@
 	}
 
 	ei_status.dmaing |= 0x01;
+
 	outb_p(E8390_NODMA+E8390_PAGE0+E8390_START, nic_base+ NE_CMD);
 	outb_p(sizeof(struct e8390_pkt_hdr), nic_base + EN0_RCNTLO);
 	outb_p(0, nic_base + EN0_RCNTHI);
@@ -677,15 +712,23 @@
 	outb_p(ring_page, nic_base + EN0_RSARHI);
 	outb_p(E8390_RREAD+E8390_START, nic_base + NE_CMD);
 
-	if (ei_status.word16)
-		insw(NE_BASE + NE_DATAPORT, hdr, sizeof(struct e8390_pkt_hdr)>>1);
-	else
-		insb(NE_BASE + NE_DATAPORT, hdr, sizeof(struct e8390_pkt_hdr));
+	if (ei_status.word16) {
+		//insw(NE_BASE + NE_DATAPORT, hdr, sizeof(struct e8390_pkt_hdr)>>1);
+		__u16  *pDat = (__u16 *)hdr;
+		__u16 iDat, TotalCnt;
+
+		TotalCnt = sizeof(struct e8390_pkt_hdr)>>1;
+		for(iDat=0; iDat<TotalCnt; iDat++) {
+			pDat[iDat] = inw(nic_base + NE_DATAPORT);
+		}
+	}
+	else 
+		insb(NE_BASE + NE_DATAPORT, hdr, sizeof(struct e8390_pkt_hdr));		
 
 	outb_p(ENISR_RDC, nic_base + EN0_ISR);	/* Ack intr. */
 	ei_status.dmaing &= ~0x01;
 
-	le16_to_cpus(&hdr->count);
+	le16_to_cpus(&hdr->count);	
 }
 
 /* Block input and output, similar to the Crynwr packet driver.  If you
@@ -718,7 +761,14 @@
 	outb_p(E8390_RREAD+E8390_START, nic_base + NE_CMD);
 	if (ei_status.word16)
 	{
-		insw(NE_BASE + NE_DATAPORT,buf,count>>1);
+		__u16  *pDat = (__u16 *)buf;
+		__u16 iDat, TotalCnt;
+
+		TotalCnt = count>>1;
+		for(iDat=0; iDat<TotalCnt; iDat++) {
+			pDat[iDat] = inw(nic_base + NE_DATAPORT);
+		}
+		//insw(NE_BASE + NE_DATAPORT,buf,count>>1);
 		if (count & 0x01)
 		{
 			buf[count-1] = inb(NE_BASE + NE_DATAPORT);
@@ -816,7 +866,13 @@
 
 	outb_p(E8390_RWRITE+E8390_START, nic_base + NE_CMD);
 	if (ei_status.word16) {
-		outsw(NE_BASE + NE_DATAPORT, buf, count>>1);
+		//outsw(NE_BASE + NE_DATAPORT, buf, count>>1);
+		__u16  *pDat = (__u16 *)buf;
+		__u16 iDat, TotalCnt;
+
+		TotalCnt = count>>1;
+		for(iDat=0; iDat<TotalCnt; iDat++)
+			outw_p(pDat[iDat], nic_base + NE_DATAPORT);
 	} else {
 		outsb(NE_BASE + NE_DATAPORT, buf, count);
 	}
diff -urN uClinux-dist/linux-2.4.x/drivers/serial/Config.in linux-2.4.x/drivers/serial/Config.in
--- uClinux-dist/linux-2.4.x/drivers/serial/Config.in	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.4.x/drivers/serial/Config.in	2004-03-26 00:34:17.000000000 +0800
@@ -0,0 +1,87 @@
+#
+# Serial device configuration
+#
+# $Id: Config.in,v 1.4 2001/10/12 15:46:58 rmk Exp $
+#
+mainmenu_option next_comment
+comment 'Serial drivers'
+
+if [ "$CONFIG_ARM" = "y" ]; then
+  # I don't have this in my tree yet.
+  dep_bool 'Anakin serial port support' CONFIG_SERIAL_ANAKIN $CONFIG_ARCH_ANAKIN
+  dep_bool '  Console on Anakin serial port' CONFIG_SERIAL_ANAKIN_CONSOLE $CONFIG_SERIAL_ANAKIN
+  if [ "$CONFIG_SERIAL_ANAKIN" = "y" ]; then
+     int  '  Default Anakin serial baudrate' CONFIG_ANAKIN_DEFAULT_BAUDRATE 9600
+  fi
+
+  dep_tristate 'S3C44B0 serial port support' CONFIG_SERIAL_S3C44B0X $CONFIG_BOARD_MBA44
+  dep_bool '  Support for console on S3C44B0 serial port' CONFIG_SERIAL_S3C44B0X_CONSOLE $CONFIG_SERIAL_S3C44B0X
+  if [ "$CONFIG_SERIAL_S3C44B0X" = "y" ]; then
+     int  '  Default S3C44B0 serial baudrate' CONFIG_S3C44B0_DEFAULT_BAUDRATE 115200
+  fi
+
+  dep_tristate 'ARM AMBA serial port support' CONFIG_SERIAL_AMBA $CONFIG_ARCH_INTEGRATOR
+  dep_bool '  Support for console on AMBA serial port' CONFIG_SERIAL_AMBA_CONSOLE $CONFIG_SERIAL_AMBA
+  if [ "$CONFIG_SERIAL_AMBA" = "y" ]; then
+     define_bool CONFIG_SERIAL_INTEGRATOR y
+  fi
+
+  dep_tristate 'CLPS711X serial port support' CONFIG_SERIAL_CLPS711X $CONFIG_ARCH_CLPS711X
+  dep_bool '  Support for console on CLPS711X serial port' CONFIG_SERIAL_CLPS711X_CONSOLE $CONFIG_SERIAL_CLPS711X
+
+  dep_bool 'DC21285 serial port support' CONFIG_SERIAL_21285 $CONFIG_FOOTBRIDGE
+  dep_bool '  Use /dev/ttyS0 device (OBSOLETE)' CONFIG_SERIAL_21285_OLD $CONFIG_SERIAL_21285 $CONFIG_OBSOLETE
+  dep_bool '  Console on DC21285 serial port' CONFIG_SERIAL_21285_CONSOLE $CONFIG_SERIAL_21285
+
+  dep_bool 'Excalibur serial port (uart00) support' CONFIG_SERIAL_UART00 $CONFIG_ARCH_CAMELOT
+  dep_bool '  Support for console on Excalibur serial port' CONFIG_SERIAL_UART00_CONSOLE $CONFIG_SERIAL_UART00
+
+
+  dep_bool 'SA1100 serial port support' CONFIG_SERIAL_SA1100 $CONFIG_ARCH_SA1100
+  dep_bool '  Console on SA1100 serial port' CONFIG_SERIAL_SA1100_CONSOLE $CONFIG_SERIAL_SA1100
+  if [ "$CONFIG_SERIAL_SA1100" = "y" ]; then
+     int  '  Default SA1100 serial baudrate' CONFIG_SA1100_DEFAULT_BAUDRATE 9600
+  fi
+fi
+#
+# The new 8250/16550 serial drivers
+dep_tristate '8250/16550 and compatible serial support (EXPERIMENTAL)' CONFIG_SERIAL_8250 $CONFIG_EXPERIMENTAL
+dep_bool '  Console on 8250/16550 and compatible serial port (EXPERIMENTAL)' CONFIG_SERIAL_8250_CONSOLE $CONFIG_SERIAL_8250 $CONFIG_EXPERIMENTAL
+
+dep_mbool 'Extended 8250/16550 serial driver options' CONFIG_SERIAL_8250_EXTENDED $CONFIG_SERIAL_8250
+dep_bool '  Support more than 4 serial ports' CONFIG_SERIAL_8250_MANY_PORTS $CONFIG_SERIAL_8250_EXTENDED
+dep_bool '  Support for sharing serial interrupts' CONFIG_SERIAL_8250_SHARE_IRQ $CONFIG_SERIAL_8250_EXTENDED
+dep_bool '  Autodetect IRQ on standard ports (unsafe)' CONFIG_SERIAL_8250_DETECT_IRQ $CONFIG_SERIAL_8250_EXTENDED
+dep_bool '  Support special multiport boards' CONFIG_SERIAL_8250_MULTIPORT $CONFIG_SERIAL_8250_EXTENDED
+dep_bool '  Support Bell Technologies HUB6 card' CONFIG_SERIAL_8250_HUB6 $CONFIG_SERIAL_8250_EXTENDED
+
+if [ "$CONFIG_SERIAL_AMBA" = "y" -o \
+     "$CONFIG_SERIAL_CLPS711X" = "y" -o \
+     "$CONFIG_SERIAL_SA1100" = "y" -o \
+     "$CONFIG_SERIAL_ANAKIN" = "y" -o \
+     "$CONFIG_SERIAL_UART00" = "y" -o \
+     "$CONFIG_SERIAL_S3C44B0X" = "y" -o \
+     "$CONFIG_SERIAL_8250" = "y" ]; then
+   define_bool CONFIG_SERIAL_CORE y
+else
+   if [ "$CONFIG_SERIAL_AMBA" = "m" -o \
+        "$CONFIG_SERIAL_CLPS711X" = "m" -o \
+        "$CONFIG_SERIAL_SA1100" = "m" -o \
+        "$CONFIG_SERIAL_ANAKIN" = "m" -o \
+        "$CONFIG_SERIAL_UART00" = "m" -o \
+        "$CONFIG_SERIAL_S3C44B0X" = "m" -o \
+        "$CONFIG_SERIAL_8250" = "m" ]; then
+      define_bool CONFIG_SERIAL_CORE m
+   fi
+fi
+if [ "$CONFIG_SERIAL_AMBA_CONSOLE" = "y" -o \
+     "$CONFIG_SERIAL_CLPS711X_CONSOLE" = "y" -o \
+     "$CONFIG_SERIAL_SA1100_CONSOLE" = "y" -o \
+     "$CONFIG_SERIAL_ANAKIN_CONSOLE" = "y" -o \
+     "$CONFIG_SERIAL_UART00_CONSOLE" = "y" -o \
+     "$CONFIG_SERIAL_S3C44B0X_CONSOLE" = "y" -o \
+     "$CONFIG_SERIAL_8250_CONSOLE" = "y" ]; then
+   define_bool CONFIG_SERIAL_CORE_CONSOLE y
+fi
+
+endmenu
diff -urN uClinux-dist/linux-2.4.x/drivers/serial/hardware.h linux-2.4.x/drivers/serial/hardware.h
--- uClinux-dist/linux-2.4.x/drivers/serial/hardware.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.4.x/drivers/serial/hardware.h	2004-03-25 23:54:13.000000000 +0800
@@ -0,0 +1,286 @@
+/********************************************************/
+/*							*/
+/* Samsung S3C44B0					*/
+/* tpu <tapu@371.net>					*/
+/*							*/
+/********************************************************/
+//#ifndef __ASM_ARCH_HARDWARE_H
+//#define __ASM_ARCH_HARDWARE_H
+
+#define REGBASE		0x01c00000
+#define REGL(addr)	(*(volatile unsigned int *)(REGBASE+addr))
+#define REGW(addr)	(*(volatile unsigned short *)(REGBASE+addr))
+#define REGB(addr)	(*(volatile unsigned char *)(REGBASE+addr))
+
+
+/*****************************/
+/* CPU Wrapper Registers     */
+/*****************************/
+
+#define SYSCFG		REGL(0x000000)
+#define NCACHBE0	REGL(0x000004)
+#define NCACHBE1	REGL(0x000008)
+#define SBUSCON		REGL(0x040000)
+
+/************************************/
+/* Memory Controller Registers      */
+/************************************/
+
+#define BWSCON		REGL(0x080000)
+#define BANKCON0	REGL(0x080004)
+#define BANKCON1	REGL(0x080008)
+#define BANKCON2	REGL(0x08000c)
+#define BANKCON3	REGL(0x080010)
+#define BANKCON4	REGL(0x080014)
+#define BANKCON5	REGL(0x080018)
+#define BANKCON6	REGL(0x08001c)
+#define BANKCON7	REGL(0x080020)
+#define REFRESH		REGL(0x080024)
+#define BANKSIZE	REGL(0x080028)
+#define MRSRB6		REGL(0x08002c)
+#define MRSRB7		REGL(0x080030)
+
+/*********************/
+/* UART Registers    */
+/*********************/
+
+#define ULCON0		REGL(0x100000)
+#define ULCON1		REGL(0x104000)
+#define UCON0		REGL(0x100004)
+#define UCON1		REGL(0x104004)
+#define UFCON0		REGL(0x100008)
+#define UFCON1		REGL(0x104008)
+#define UMCON0		REGL(0x10000c)
+#define UMCON1		REGL(0x10400c)
+#define UTRSTAT0	REGL(0x100010)
+#define UTRSTAT1	REGL(0x104010)
+#define UERSTAT0	REGL(0x100014)
+#define UERSTAT1	REGL(0x104014)
+#define UFSTAT0		REGL(0x100018)
+#define UFSTAT1		REGL(0x104018)
+#define UMSTAT0		REGL(0x10001c)
+#define UMSTAT1		REGL(0x10401c)
+#define UTXH0		REGB(0x100020)
+#define UTXH1		REGB(0x104020)
+#define URXH0		REGB(0x100024)
+#define URXH1		REGB(0x104024)
+#define UBRDIV0		REGL(0x100028)
+#define UBRDIV1		REGL(0x104028)
+
+/*******************/
+/* SIO Registers   */
+/*******************/
+
+#define SIOCON		REGL(0x114000)
+#define SIODAT		REGL(0x114004)
+#define SBRDR		REGL(0x114008)
+#define ITVCNT		REGL(0x11400c)
+#define DCNTZ		REGL(0x114010)
+
+/********************/
+/* IIS Registers    */
+/********************/
+
+#define IISCON		REGL(0x118000)
+#define IISMOD		REGL(0x118004)
+#define IISPSR		REGL(0x118008)
+#define IISFIFCON	REGL(0x11800c)
+#define IISFIF		REGW(0x118010)
+
+/**************************/
+/* I/O Ports Registers    */
+/**************************/
+
+#define PCONA		REGL(0x120000)
+#define PDATA		REGL(0x120004)
+#define PCONB		REGL(0x120008)
+#define PDATB		REGL(0x12000c)
+#define PCONC		REGL(0x120010)
+#define PDATC		REGL(0x120014)
+#define PUPC		REGL(0x120018)
+#define PCOND		REGL(0x12001c)
+#define PDATD		REGL(0x120020)
+#define PUPD		REGL(0x120024)
+#define PCONE		REGL(0x120028)
+#define PDATE		REGL(0x12002c)
+#define PUPE		REGL(0x120030)
+#define PCONF		REGL(0x120034)
+#define PDATF		REGL(0x120038)
+#define PUPF		REGL(0x12003c)
+#define PCONG		REGL(0x120040)
+#define PDATG		REGL(0x120044)
+#define PUPG		REGL(0x120048)
+#define SPUCR		REGL(0x12004c)
+#define EXTINT		REGL(0x120050)
+#define EXTINPND	REGL(0x120054)
+
+/*********************************/
+/* WatchDog Timers Registers     */
+/*********************************/
+
+#define WTCON		REGL(0x130000)
+#define WTDAT		REGL(0x130004)
+#define WTCNT		REGL(0x130008)
+
+/*********************************/
+/* A/D Converter Registers       */
+/*********************************/
+
+#define ADCCON		REGL(0x140000)
+#define ADCPSR		REGL(0x140004)
+#define ADCDAT		REGL(0x140008)
+
+/***************************/
+/* PWM Timer Registers     */
+/***************************/
+
+#define TCFG0		REGL(0x150000)
+#define TCFG1		REGL(0x150004)
+#define TCON		REGL(0x150008)
+#define TCNTB0		REGL(0x15000c)
+#define TCMPB0		REGL(0x150010)
+#define TCNTO0		REGL(0x150014)
+#define TCNTB1		REGL(0x150018)
+#define TCMPB1		REGL(0x15001c)
+#define TCNTO1		REGL(0x150020)
+#define TCNTB2		REGL(0x150024)
+#define TCMPB2		REGL(0x150028)
+#define TCNTO2		REGL(0x15002c)
+#define TCNTB3		REGL(0x150030)
+#define TCMPB3		REGL(0x150034)
+#define TCNTO3		REGL(0x150038)
+#define TCNTB4		REGL(0x15003c)
+#define TCMPB4		REGL(0x150040)
+#define TCNTO4		REGL(0x150044)
+#define TCNTB5		REGL(0x150048)
+#define TCNTO5		REGL(0x15004c)
+
+/*********************/
+/* IIC Registers     */
+/*********************/
+
+#define IICCON		REGL(0x160000)
+#define IICSTAT		REGL(0x160004)
+#define IICADD		REGL(0x160008)
+#define IICDS		REGL(0x16000c)
+
+/*********************/
+/* RTC Registers     */
+/*********************/
+
+#define RTCCON		REGB(0x170040)
+#define RTCALM		REGB(0x170050)
+#define ALMSEC		REGB(0x170054)
+#define ALMMIN		REGB(0x170058)
+#define ALMHOUR		REGB(0x17005c)
+#define ALMDAY		REGB(0x170060)
+#define ALMMON		REGB(0x170064)
+#define ALMYEAR		REGB(0x170068)
+#define RTCRST		REGB(0x17006c)
+#define BCDSEC		REGB(0x170070)
+#define BCDMIN		REGB(0x170074)
+#define BCDHOUR		REGB(0x170078)
+#define BCDDAY		REGB(0x17007c)
+#define BCDDATE		REGB(0x170080)
+#define BCDMON		REGB(0x170084)
+#define BCDYEAR		REGB(0x170088)
+#define TICINT		REGB(0x17008c)
+
+/*********************************/
+/* Clock & Power Registers       */
+/*********************************/
+
+#define PLLCON		REGL(0x180000)
+#define CLKCON		REGL(0x180004)
+#define CLKSLOW		REGL(0x180008)
+#define LOCKTIME	REGL(0x18000c)
+
+/**************************************/
+/* Interrupt Controller Registers     */
+/**************************************/
+
+#define INTCON		REGL(0x200000)
+#define INTPND		REGL(0x200004)
+#define INTMOD		REGL(0x200008)
+#define INTMSK		REGL(0x20000c)
+#define I_PSLV		REGL(0x200010)
+#define I_PMST		REGL(0x200014)
+#define I_CSLV		REGL(0x200018)
+#define I_CMST		REGL(0x20001c)
+#define I_ISPR		REGL(0x200020)
+#define I_ISPC		REGL(0x200024)
+#define F_ISPR		REGL(0x200038)
+#define F_ISPC		REGL(0x20003c)
+
+/********************************/
+/* LCD Controller Registers     */
+/********************************/
+
+#define LCDCON1		REGL(0x300000)
+#define LCDCON2		REGL(0x300004)
+#define LCDSADDR1	REGL(0x300008)
+#define LCDSADDR2	REGL(0x30000c)
+#define LCDSADDR3	REGL(0x300010)
+#define REDLUT		REGL(0x300014)
+#define GREENLUT	REGL(0x300018)
+#define BLUELUT		REGL(0x30001c)
+#define DP1_2		REGL(0x300020)
+#define DP4_7		REGL(0x300024)
+#define DP3_5		REGL(0x300028)
+#define DP2_3		REGL(0x30002c)
+#define DP5_7		REGL(0x300030)
+#define DP3_4		REGL(0x300034)
+#define DP4_5		REGL(0x300038)
+#define DP6_7		REGL(0x30003c)
+#define LCDCON3		REGL(0x300040)
+#define DITHMODE	REGL(0x300044)
+
+/*********************/
+/* DMA Registers     */
+/*********************/
+
+#define ZDCON0		REGL(0x280000)
+#define ZDISRC0		REGL(0x280004)
+#define ZDIDES0		REGL(0x280008)
+#define ZDICNT0		REGL(0x28000c)
+#define ZDCSRC0		REGL(0x280010)
+#define ZDCDES0		REGL(0x280014)
+#define ZDCCNT0		REGL(0x280018)
+
+#define ZDCON1		REGL(0x280020)
+#define ZDISRC1		REGL(0x280024)
+#define ZDIDES1		REGL(0x280028)
+#define ZDICNT1		REGL(0x28002c)
+#define ZDCSRC1		REGL(0x280030)
+#define ZDCDES1		REGL(0x280034)
+#define ZDCCNT1		REGL(0x280038)
+
+#define BDCON0		REGL(0x380000)
+#define BDISRC0		REGL(0x380004)
+#define BDIDES0		REGL(0x380008)
+#define BDICNT0		REGL(0x38000c)
+#define BDCSRC0		REGL(0x380010)
+#define BDCDES0		REGL(0x380014)
+#define BDCCNT0		REGL(0x380018)
+
+#define BDCON1		REGL(0x380020)
+#define BDISRC1		REGL(0x380024)
+#define BDIDES1		REGL(0x380028)
+#define BDICNT1		REGL(0x38002c)
+#define BDCSRC1		REGL(0x380030)
+#define BDCDES1		REGL(0x380034)
+#define BDCCNT1		REGL(0x380038)
+
+
+#define CLEAR_PEND_INT(n)       I_ISPC = (1<<(n))
+#define INT_ENABLE(n)		INTMSK &= ~(1<<(n))
+#define INT_DISABLE(n)		INTMSK |= (1<<(n))
+
+#define	INT_UTXD1	2
+#define	INT_UTXD0	3
+#define	INT_URXD1	6
+#define	INT_URXD0	7
+
+//#define HARD_RESET_NOW()
+
+//#endif /* __ASM_ARCH_HARDWARE_H */
diff -urN uClinux-dist/linux-2.4.x/drivers/serial/Makefile linux-2.4.x/drivers/serial/Makefile
--- uClinux-dist/linux-2.4.x/drivers/serial/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.4.x/drivers/serial/Makefile	2004-03-26 00:47:45.000000000 +0800
@@ -0,0 +1,38 @@
+#
+# Makefile for the kernel serial device drivers.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definitions are now inherited from the
+# parent makes..
+#
+#  $Id: Makefile,v 1.2 2001/10/12 15:46:58 rmk Exp $
+#
+
+O_TARGET := serial.o
+
+export-objs	:= serial_core.o serial_8250.o
+obj-y		:=
+obj-m		:=
+obj-n		:=
+obj-		:=
+
+serial-8250-y :=
+serial-8250-$(CONFIG_PCI) += serial_8250_pci.o
+serial-8250-$(CONFIG_ISAPNP) += serial_8250_pnp.o
+obj-$(CONFIG_SERIAL_CORE) += serial_core.o
+obj-$(CONFIG_SERIAL_21285) += serial_21285.o
+obj-$(CONFIG_SERIAL_8250) += serial_8250.o $(serial-8250-y)
+obj-$(CONFIG_SERIAL_ANAKIN) += serial_anakin.o
+obj-$(CONFIG_SERIAL_AMBA) += serial_amba.o
+obj-$(CONFIG_SERIAL_CLPS711X) += serial_clps711x.o
+obj-$(CONFIG_SERIAL_SA1100) += serial_sa1100.o
+obj-$(CONFIG_SERIAL_UART00) += serial_uart00.o
+obj-$(CONFIG_SERIAL_S3C44B0X) += serial_s3c44b0x.o
+
+include $(TOPDIR)/Rules.make
+
+fastdep:
+
diff -urN uClinux-dist/linux-2.4.x/drivers/serial/ser2.c linux-2.4.x/drivers/serial/ser2.c
--- uClinux-dist/linux-2.4.x/drivers/serial/ser2.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.4.x/drivers/serial/ser2.c	2004-03-25 23:16:48.000000000 +0800
@@ -0,0 +1,56 @@
+
+
+#include <asm/hardware.h>
+
+
+
+static int sput(int c)
+{
+	/* wait for room in the transmit FIFO */
+	while(!((UTRSTAT1)&0x02));
+
+	(UTXH1) = (unsigned char)c;
+
+	return 0;
+}
+
+static void sputs(char *s)
+{
+	int len, i;
+
+        len = strlen(s);
+        for(i=0; i<len; i++){
+            sput(s[i]);
+            if(s[i] == '\n')
+                sput('\r');
+        }
+}
+
+static void shexb(int h)
+{
+	int dt;
+
+	dt = (h>>4)&0x0f;
+	if(dt>9)
+		dt += 7;
+	dt += 0x30;
+	sput(dt);
+
+	dt = (h)&0x0f;
+	if(dt>9)
+		dt += 7;
+	dt += 0x30;
+	sput(dt);
+}
+
+static void shexw(int w)
+{
+	shexb(w>>8);
+	shexb(w);
+}
+
+static void shex(int d)
+{
+	shexw(d>>16);
+	shexw(d);
+}
diff -urN uClinux-dist/linux-2.4.x/drivers/serial/serial_21285.c linux-2.4.x/drivers/serial/serial_21285.c
--- uClinux-dist/linux-2.4.x/drivers/serial/serial_21285.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.4.x/drivers/serial/serial_21285.c	2004-03-25 23:16:48.000000000 +0800
@@ -0,0 +1,570 @@
+/*
+ * linux/drivers/char/serial_21285.c
+ *
+ * Driver for the serial port on the 21285 StrongArm-110 core logic chip.
+ *
+ * Based on drivers/char/serial.c
+ *
+ *  $Id: serial_21285.c,v 1.4 2001/10/14 20:10:03 rmk Exp $
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial.h>
+#include <linux/major.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/console.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <asm/hardware/dec21285.h>
+#include <asm/hardware.h>
+
+#define BAUD_BASE		(mem_fclk_21285/64)
+
+#define SERIAL_21285_NAME	"ttyFB"
+#define SERIAL_21285_MAJOR	204
+#define SERIAL_21285_MINOR	4
+
+#define SERIAL_21285_AUXNAME	"cuafb"
+#define SERIAL_21285_AUXMAJOR	205
+#define SERIAL_21285_AUXMINOR	4
+
+#ifdef CONFIG_SERIAL_21285_OLD
+#include <asm/mach-types.h>
+/*
+ * Compatability with a mistake made a long time ago.
+ * Note - the use of "ttyI", "/dev/ttyS0" and major/minor 5,64
+ * is HIGHLY DEPRECIATED, and will be removed in the 2.5
+ * kernel series.
+ *					-- rmk 15/04/2000 
+ */
+#define SERIAL_21285_OLD_NAME	"ttyI"
+#define SERIAL_21285_OLD_MAJOR	TTY_MAJOR
+#define SERIAL_21285_OLD_MINOR	64
+
+static struct tty_driver rs285_old_driver;
+#endif
+
+static struct tty_driver rs285_driver, callout_driver;
+static int rs285_refcount;
+static struct tty_struct *rs285_table[1];
+
+static struct termios *rs285_termios[1];
+static struct termios *rs285_termios_locked[1];
+
+static char wbuf[1000], *putp = wbuf, *getp = wbuf, x_char;
+static struct tty_struct *rs285_tty;
+static int rs285_use_count;
+
+static int rs285_write_room(struct tty_struct *tty)
+{
+	return putp >= getp ? (sizeof(wbuf) - (long) putp + (long) getp) : ((long) getp - (long) putp - 1);
+}
+
+static void rs285_rx_int(int irq, void *dev_id, struct pt_regs *regs)
+{
+	if (!rs285_tty) {
+		disable_irq(IRQ_CONRX);
+		return;
+	}
+	while (!(*CSR_UARTFLG & 0x10)) {
+		int ch, flag;
+		ch = *CSR_UARTDR;
+		flag = *CSR_RXSTAT;
+		if (flag & 4)
+			tty_insert_flip_char(rs285_tty, 0, TTY_OVERRUN);
+		if (flag & 2)
+			flag = TTY_PARITY;
+		else if (flag & 1)
+			flag = TTY_FRAME;
+		tty_insert_flip_char(rs285_tty, ch, flag);
+	}
+	tty_flip_buffer_push(rs285_tty);
+}
+
+static void rs285_send_xchar(struct tty_struct *tty, char ch)
+{
+	x_char = ch;
+	enable_irq(IRQ_CONTX);
+}
+
+static void rs285_throttle(struct tty_struct *tty)
+{
+	if (I_IXOFF(tty))
+		rs285_send_xchar(tty, STOP_CHAR(tty));
+}
+
+static void rs285_unthrottle(struct tty_struct *tty)
+{
+	if (I_IXOFF(tty)) {
+		if (x_char)
+			x_char = 0;
+		else
+			rs285_send_xchar(tty, START_CHAR(tty));
+	}
+}
+
+static void rs285_tx_int(int irq, void *dev_id, struct pt_regs *regs)
+{
+	while (!(*CSR_UARTFLG & 0x20)) {
+		if (x_char) {
+			*CSR_UARTDR = x_char;
+			x_char = 0;
+			continue;
+		}
+		if (putp == getp) {
+			disable_irq(IRQ_CONTX);
+			break;
+		}
+		*CSR_UARTDR = *getp;
+		if (++getp >= wbuf + sizeof(wbuf))
+			getp = wbuf;
+	}
+	if (rs285_tty)
+		wake_up_interruptible(&rs285_tty->write_wait);
+}
+
+static inline int rs285_xmit(int ch)
+{
+	if (putp + 1 == getp || (putp + 1 == wbuf + sizeof(wbuf) && getp == wbuf))
+		return 0;
+	*putp = ch;
+	if (++putp >= wbuf + sizeof(wbuf))
+		putp = wbuf;
+	enable_irq(IRQ_CONTX);
+	return 1;
+}
+
+static int rs285_write(struct tty_struct *tty, int from_user,
+		       const u_char * buf, int count)
+{
+	int i;
+
+	if (from_user && verify_area(VERIFY_READ, buf, count))
+		return -EINVAL;
+
+	for (i = 0; i < count; i++) {
+		char ch;
+		if (from_user)
+			__get_user(ch, buf + i);
+		else
+			ch = buf[i];
+		if (!rs285_xmit(ch))
+			break;
+	}
+	return i;
+}
+
+static void rs285_put_char(struct tty_struct *tty, u_char ch)
+{
+	rs285_xmit(ch);
+}
+
+static int rs285_chars_in_buffer(struct tty_struct *tty)
+{
+	return sizeof(wbuf) - rs285_write_room(tty);
+}
+
+static void rs285_flush_buffer(struct tty_struct *tty)
+{
+	disable_irq(IRQ_CONTX);
+	putp = getp = wbuf;
+	if (x_char)
+		enable_irq(IRQ_CONTX);
+}
+
+static inline void rs285_set_cflag(int cflag)
+{
+	int h_lcr, baud, quot;
+
+	switch (cflag & CSIZE) {
+	case CS5:
+		h_lcr = 0x10;
+		break;
+	case CS6:
+		h_lcr = 0x30;
+		break;
+	case CS7:
+		h_lcr = 0x50;
+		break;
+	default: /* CS8 */
+		h_lcr = 0x70;
+		break;
+
+	}
+	if (cflag & CSTOPB)
+		h_lcr |= 0x08;
+	if (cflag & PARENB)
+		h_lcr |= 0x02;
+	if (!(cflag & PARODD))
+		h_lcr |= 0x04;
+
+	switch (cflag & CBAUD) {
+	case B200:	baud = 200;		break;
+	case B300:	baud = 300;		break;
+	case B1200:	baud = 1200;		break;
+	case B1800:	baud = 1800;		break;
+	case B2400:	baud = 2400;		break;
+	case B4800:	baud = 4800;		break;
+	default:
+	case B9600:	baud = 9600;		break;
+	case B19200:	baud = 19200;		break;
+	case B38400:	baud = 38400;		break;
+	case B57600:	baud = 57600;		break;
+	case B115200:	baud = 115200;		break;
+	}
+
+	/*
+	 * The documented expression for selecting the divisor is:
+	 *  BAUD_BASE / baud - 1
+	 * However, typically BAUD_BASE is not divisible by baud, so
+	 * we want to select the divisor that gives us the minimum
+	 * error.  Therefore, we want:
+	 *  int(BAUD_BASE / baud - 0.5) ->
+	 *  int(BAUD_BASE / baud - (baud >> 1) / baud) ->
+	 *  int((BAUD_BASE - (baud >> 1)) / baud)
+	 */
+	quot = (BAUD_BASE - (baud >> 1)) / baud;
+
+	*CSR_UARTCON = 0;
+	*CSR_L_UBRLCR = quot & 0xff;
+	*CSR_M_UBRLCR = (quot >> 8) & 0x0f;
+	*CSR_H_UBRLCR = h_lcr;
+	*CSR_UARTCON = 1;
+}
+
+static void rs285_set_termios(struct tty_struct *tty, struct termios *old)
+{
+	if (old && tty->termios->c_cflag == old->c_cflag)
+		return;
+	rs285_set_cflag(tty->termios->c_cflag);
+}
+
+
+static void rs285_stop(struct tty_struct *tty)
+{
+	disable_irq(IRQ_CONTX);
+}
+
+static void rs285_start(struct tty_struct *tty)
+{
+	enable_irq(IRQ_CONTX);
+}
+
+static void rs285_wait_until_sent(struct tty_struct *tty, int timeout)
+{
+	int orig_jiffies = jiffies;
+	while (*CSR_UARTFLG & 8) {
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(1);
+		if (signal_pending(current))
+			break;
+		if (timeout && time_after(jiffies, orig_jiffies + timeout))
+			break;
+	}
+	set_current_state(TASK_RUNNING);
+}
+
+static int rs285_open(struct tty_struct *tty, struct file *filp)
+{
+	int line;
+
+	MOD_INC_USE_COUNT;
+	line = MINOR(tty->device) - tty->driver.minor_start;
+	if (line) {
+		MOD_DEC_USE_COUNT;
+		return -ENODEV;
+	}
+
+	tty->driver_data = NULL;
+	if (!rs285_tty)
+		rs285_tty = tty;
+
+	enable_irq(IRQ_CONRX);
+	rs285_use_count++;
+	return 0;
+}
+
+static void rs285_close(struct tty_struct *tty, struct file *filp)
+{
+	if (!--rs285_use_count) {
+		rs285_wait_until_sent(tty, 0);
+		disable_irq(IRQ_CONRX);
+		disable_irq(IRQ_CONTX);
+		rs285_tty = NULL;
+	}
+	MOD_DEC_USE_COUNT;
+}
+
+static int __init rs285_init(void)
+{
+	int baud = B9600;
+
+	if (machine_is_personal_server())
+		baud = B57600;
+
+	rs285_driver.magic = TTY_DRIVER_MAGIC;
+	rs285_driver.driver_name = "serial_21285";
+	rs285_driver.name = SERIAL_21285_NAME;
+	rs285_driver.major = SERIAL_21285_MAJOR;
+	rs285_driver.minor_start = SERIAL_21285_MINOR;
+	rs285_driver.num = 1;
+	rs285_driver.type = TTY_DRIVER_TYPE_SERIAL;
+	rs285_driver.subtype = SERIAL_TYPE_NORMAL;
+	rs285_driver.init_termios = tty_std_termios;
+	rs285_driver.init_termios.c_cflag = baud | CS8 | CREAD | HUPCL | CLOCAL;
+	rs285_driver.flags = TTY_DRIVER_REAL_RAW;
+	rs285_driver.refcount = &rs285_refcount;
+	rs285_driver.table = rs285_table;
+	rs285_driver.termios = rs285_termios;
+	rs285_driver.termios_locked = rs285_termios_locked;
+
+	rs285_driver.open = rs285_open;
+	rs285_driver.close = rs285_close;
+	rs285_driver.write = rs285_write;
+	rs285_driver.put_char = rs285_put_char;
+	rs285_driver.write_room = rs285_write_room;
+	rs285_driver.chars_in_buffer = rs285_chars_in_buffer;
+	rs285_driver.flush_buffer = rs285_flush_buffer;
+	rs285_driver.throttle = rs285_throttle;
+	rs285_driver.unthrottle = rs285_unthrottle;
+	rs285_driver.send_xchar = rs285_send_xchar;
+	rs285_driver.set_termios = rs285_set_termios;
+	rs285_driver.stop = rs285_stop;
+	rs285_driver.start = rs285_start;
+	rs285_driver.wait_until_sent = rs285_wait_until_sent;
+
+	callout_driver = rs285_driver;
+	callout_driver.name = SERIAL_21285_AUXNAME;
+	callout_driver.major = SERIAL_21285_AUXMAJOR;
+	callout_driver.subtype = SERIAL_TYPE_CALLOUT;
+
+	if (request_irq(IRQ_CONRX, rs285_rx_int, 0, "rs285", NULL))
+		panic("Couldn't get rx irq for rs285");
+
+	if (request_irq(IRQ_CONTX, rs285_tx_int, 0, "rs285", NULL))
+		panic("Couldn't get tx irq for rs285");
+
+#ifdef CONFIG_SERIAL_21285_OLD
+	if (!machine_is_ebsa285() && !machine_is_netwinder()) {
+		rs285_old_driver = rs285_driver;
+		rs285_old_driver.name = SERIAL_21285_OLD_NAME;
+		rs285_old_driver.major = SERIAL_21285_OLD_MAJOR;
+		rs285_old_driver.minor_start = SERIAL_21285_OLD_MINOR;
+
+		if (tty_register_driver(&rs285_old_driver))
+			printk(KERN_ERR "Couldn't register old 21285 serial driver\n");
+	}
+#endif
+
+	if (tty_register_driver(&rs285_driver))
+		printk(KERN_ERR "Couldn't register 21285 serial driver\n");
+	if (tty_register_driver(&callout_driver))
+		printk(KERN_ERR "Couldn't register 21285 callout driver\n");
+
+	return 0;
+}
+
+static void __exit rs285_fini(void)
+{
+	unsigned long flags;
+	int ret;
+
+	save_flags(flags);
+	cli();
+	ret = tty_unregister_driver(&callout_driver);
+	if (ret)
+		printk(KERN_ERR "Unable to unregister 21285 callout driver "
+			"(%d)\n", ret);
+	ret = tty_unregister_driver(&rs285_driver);
+	if (ret)
+		printk(KERN_ERR "Unable to unregister 21285 driver (%d)\n",
+			ret);
+#ifdef CONFIG_SERIAL_21285_OLD
+	if (!machine_is_ebsa285() && !machine_is_netwinder()) {
+		ret = tty_unregister_driver(&rs285_old_driver);
+		if (ret)
+			printk(KERN_ERR "Unable to unregister old 21285 "
+				"driver (%d)\n", ret);
+	}
+#endif
+	free_irq(IRQ_CONTX, NULL);
+	free_irq(IRQ_CONRX, NULL);
+	restore_flags(flags);
+}
+
+module_init(rs285_init);
+module_exit(rs285_fini);
+
+#ifdef CONFIG_SERIAL_21285_CONSOLE
+/************** console driver *****************/
+
+static void rs285_console_write(struct console *co, const char *s, u_int count)
+{
+	int i;
+
+	disable_irq(IRQ_CONTX);
+	for (i = 0; i < count; i++) {
+		while (*CSR_UARTFLG & 0x20);
+		*CSR_UARTDR = s[i];
+		if (s[i] == '\n') {
+			while (*CSR_UARTFLG & 0x20);
+			*CSR_UARTDR = '\r';
+		}
+	}
+	enable_irq(IRQ_CONTX);
+}
+
+static int rs285_console_wait_key(struct console *co)
+{
+	int c;
+
+	disable_irq(IRQ_CONRX);
+	while (*CSR_UARTFLG & 0x10);
+	c = *CSR_UARTDR;
+	enable_irq(IRQ_CONRX);
+	return c;
+}
+
+static kdev_t rs285_console_device(struct console *c)
+{
+	return MKDEV(SERIAL_21285_MAJOR, SERIAL_21285_MINOR);
+}
+
+static int __init rs285_console_setup(struct console *co, char *options)
+{
+	int baud = 9600;
+	int bits = 8;
+	int parity = 'n';
+	int cflag = CREAD | HUPCL | CLOCAL;
+
+	if (machine_is_personal_server())
+		baud = 57600;
+
+	if (options) {
+		char *s = options;
+		baud = simple_strtoul(options, NULL, 10);
+		while (*s >= '0' && *s <= '9')
+			s++;
+		if (*s)
+			parity = *s++;
+		if (*s)
+			bits = *s - '0';
+	}
+
+	/*
+	 *    Now construct a cflag setting.
+	 */
+	switch (baud) {
+	case 1200:
+		cflag |= B1200;
+		break;
+	case 2400:
+		cflag |= B2400;
+		break;
+	case 4800:
+		cflag |= B4800;
+		break;
+	case 9600:
+		cflag |= B9600;
+		break;
+	case 19200:
+		cflag |= B19200;
+		break;
+	case 38400:
+		cflag |= B38400;
+		break;
+	case 57600:
+		cflag |= B57600;
+		break;
+	case 115200:
+		cflag |= B115200;
+		break;
+	default:
+		cflag |= B9600;
+		break;
+	}
+	switch (bits) {
+	case 7:
+		cflag |= CS7;
+		break;
+	default:
+		cflag |= CS8;
+		break;
+	}
+	switch (parity) {
+	case 'o':
+	case 'O':
+		cflag |= PARODD;
+		break;
+	case 'e':
+	case 'E':
+		cflag |= PARENB;
+		break;
+	}
+	co->cflag = cflag;
+	rs285_set_cflag(cflag);
+	rs285_console_write(NULL, "\e[2J\e[Hboot ", 12);
+	if (options)
+		rs285_console_write(NULL, options, strlen(options));
+	else
+		rs285_console_write(NULL, "no options", 10);
+	rs285_console_write(NULL, "\n", 1);
+
+	return 0;
+}
+
+#ifdef CONFIG_SERIAL_21285_OLD
+static struct console rs285_old_cons =
+{
+	SERIAL_21285_OLD_NAME,
+	rs285_console_write,
+	NULL,
+	rs285_console_device,
+	rs285_console_wait_key,
+	NULL,
+	rs285_console_setup,
+	CON_PRINTBUFFER,
+	-1,
+	0,
+	NULL
+};
+#endif
+
+static struct console rs285_cons =
+{
+	name:		SERIAL_21285_NAME,
+	write:		rs285_console_write,
+	device:		rs285_console_device,
+	wait_key:	rs285_console_wait_key,
+	setup:		rs285_console_setup,
+	flags:		CON_PRINTBUFFER,
+	index:		-1,
+};
+
+void __init rs285_console_init(void)
+{
+#ifdef CONFIG_SERIAL_21285_OLD
+	if (!machine_is_ebsa285() && !machine_is_netwinder())
+		register_console(&rs285_old_cons);
+#endif
+	register_console(&rs285_cons);
+}
+
+#endif /* CONFIG_SERIAL_21285_CONSOLE */
+
+EXPORT_NO_SYMBOLS;
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Intel Footbridge (21285) serial driver");
diff -urN uClinux-dist/linux-2.4.x/drivers/serial/serial_8250.c linux-2.4.x/drivers/serial/serial_8250.c
--- uClinux-dist/linux-2.4.x/drivers/serial/serial_8250.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.4.x/drivers/serial/serial_8250.c	2004-03-25 23:16:48.000000000 +0800
@@ -0,0 +1,1956 @@
+/*
+ *  linux/drivers/char/serial_8250.c
+ *
+ *  Driver for 8250/16550-type serial ports
+ *
+ *  Based on drivers/char/serial.c, by Linus Torvalds, Theodore Ts'o.
+ *
+ *  Copyright (C) 2001 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ *  $Id: serial_8250.c,v 1.14.2.6 2002/02/04 17:51:22 rmk Exp $
+ *
+ * A note about mapbase / membase
+ *
+ *  mapbase is the physical address of the IO port.  Currently, we don't
+ *  support this very well, and it may well be dropped from this driver
+ *  in future.  As such, mapbase should be NULL.
+ *
+ *  membase is an 'ioremapped' cookie.  This is compatible with the old
+ *  serial.c driver, and is currently the preferred form.
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/major.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/serial.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/serial_reg.h>
+#include <linux/serialP.h>
+#include <linux/delay.h>
+#include <linux/serial_core.h>
+#include <linux/kmod.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <asm/bitops.h>
+
+#include "serial_8250.h"
+
+/*
+ * This converts from our new CONFIG_ symbols to the symbols
+ * that asm/serial.h expects.  You _NEED_ to comment out the
+ * linux/config.h include contained inside asm/serial.h for
+ * this to work.
+ */
+#undef CONFIG_SERIAL_MANY_PORTS
+#undef CONFIG_SERIAL_DETECT_IRQ
+#undef CONFIG_SERIAL_MULTIPORT
+#undef CONFIG_HUB6
+
+#ifdef CONFIG_SERIAL_8250_MANY_PORTS
+#define CONFIG_SERIAL_MANY_PORTS 1
+#endif
+#ifdef CONFIG_SERIAL_8250_DETECT_IRQ
+#define CONFIG_SERIAL_DETECT_IRQ 1
+#endif
+#ifdef CONFIG_SERIAL_8250_MULTIPORT
+#define CONFIG_SERIAL_MULTIPORT 1
+#endif
+#ifdef CONFIG_SERIAL_8250_HUB6
+#define CONFIG_HUB6 1
+#endif
+
+#include <asm/serial.h>
+
+static struct old_serial_port old_serial_port[] = {
+	SERIAL_PORT_DFNS /* defined in asm/serial.h */
+};
+
+#define UART_NR	ARRAY_SIZE(old_serial_port)
+
+static struct tty_driver normal, callout;
+static struct tty_struct *serial8250_table[UART_NR];
+static struct termios *serial8250_termios[UART_NR], *serial8250_termios_locked[UART_NR];
+#ifdef CONFIG_SERIAL_8250_CONSOLE
+static struct console serial8250_console;
+static unsigned int lsr_break_flag;
+#endif
+static struct uart_info *IRQ_ports[NR_IRQS];
+
+#if defined(CONFIG_SERIAL_RSA) && defined(MODULE)
+
+#define PORT_RSA_MAX 4
+static int probe_rsa[PORT_RSA_MAX];
+static int force_rsa[PORT_RSA_MAX];
+
+MODULE_PARM(probe_rsa, "1-" __MODULE_STRING(PORT_RSA_MAX) "i");
+MODULE_PARM_DESC(probe_rsa, "Probe I/O ports for RSA");
+MODULE_PARM(force_rsa, "1-" __MODULE_STRING(PORT_RSA_MAX) "i");
+MODULE_PARM_DESC(force_rsa, "Force I/O ports for RSA");
+#endif /* CONFIG_SERIAL_RSA  */
+
+#define port_acr	unused[0]	/* 8bit */
+#define port_ier	unused[1]	/* 8bit */
+#define port_rev	unused[2]	/* 8bit */
+#define port_lcr	unused[3]	/* 8bit */
+
+/*
+ * Here we define the default xmit fifo size used for each type of UART.
+ */
+static const struct serial_uart_config uart_config[PORT_MAX_8250+1] = {
+	{ "unknown",	1,	0 },
+	{ "8250",	1,	0 },
+	{ "16450",	1,	0 },
+	{ "16550",	1,	0 },
+	{ "16550A",	16,	UART_CLEAR_FIFO | UART_USE_FIFO },
+	{ "Cirrus",	1, 	0 },
+	{ "ST16650",	1,	UART_CLEAR_FIFO | UART_STARTECH },
+	{ "ST16650V2",	32,	UART_CLEAR_FIFO | UART_USE_FIFO | UART_STARTECH },
+	{ "TI16750",	64,	UART_CLEAR_FIFO | UART_USE_FIFO },
+	{ "Startech",	1,	0 },
+	{ "16C950/954",	128,	UART_CLEAR_FIFO | UART_USE_FIFO },
+	{ "ST16654",	64,	UART_CLEAR_FIFO | UART_USE_FIFO | UART_STARTECH },
+	{ "XR16850",	128,	UART_CLEAR_FIFO | UART_USE_FIFO | UART_STARTECH },
+	{ "RSA",	2048,	UART_CLEAR_FIFO | UART_USE_FIFO }
+};
+
+static _INLINE_ unsigned int serial_in(struct uart_port *port, int offset)
+{
+	offset <<= port->regshift;
+
+	switch (port->iotype) {
+#ifdef CONFIG_SERIAL_8250_HUB6
+	case SERIAL_IO_HUB6:
+		outb(port->hub6 - 1 + offset, port->iobase);
+		return inb(port->iobase + 1);
+#endif
+
+	case SERIAL_IO_MEM:
+		return readb((unsigned long)port->membase + offset);
+
+	default:
+		return inb(port->iobase + offset);
+	}
+}
+
+static _INLINE_ void
+serial_out(struct uart_port *port, int offset, int value)
+{
+	offset <<= port->regshift;
+
+	switch (port->iotype) {
+#ifdef CONFIG_SERIAL_8250_HUB6
+	case SERIAL_IO_HUB6:
+		outb(port->hub6 - 1 + offset, port->iobase);
+		outb(value, port->iobase + 1);
+		break;
+#endif
+
+	case SERIAL_IO_MEM:
+		writeb(value, (unsigned long)port->membase + offset);
+		break;
+
+	default:
+		outb(value, port->iobase + offset);
+	}
+}
+
+/*
+ * We used to support using pause I/O for certain machines.  We
+ * haven't supported this for a while, but just in case it's badly
+ * needed for certain old 386 machines, I've left these #define's
+ * in....
+ */
+#define serial_inp(port, offset)		serial_in(port, offset)
+#define serial_outp(port, offset, value)	serial_out(port, offset, value)
+
+
+/*
+ * For the 16C950
+ */
+static void serial_icr_write(struct uart_port *port, int offset, int  value)
+{
+	serial_out(port, UART_SCR, offset);
+	serial_out(port, UART_ICR, value);
+}
+
+static unsigned int serial_icr_read(struct uart_port *port, int offset)
+{
+	unsigned int value;
+
+	serial_icr_write(port, UART_ACR, port->port_acr | UART_ACR_ICRRD);
+	serial_out(port, UART_SCR, offset);
+	value = serial_in(port, UART_ICR);
+	serial_icr_write(port, UART_ACR, port->port_acr);
+
+	return value;
+}
+
+#ifdef CONFIG_SERIAL_RSA
+/* Attempts to turn on the RSA FIFO.  Returns zero on failure */
+static int enable_rsa(struct uart_port *port)
+{
+	unsigned char mode;
+	int result;
+	unsigned long flags;
+
+	save_flags(flags); cli();
+	mode = serial_inp(port, UART_RSA_MSR);
+	result = mode & UART_RSA_MSR_FIFO;
+
+	if (!result) {
+		serial_outp(port, UART_RSA_MSR, mode | UART_RSA_MSR_FIFO);
+		mode = serial_inp(port, UART_RSA_MSR);
+		result = mode & UART_RSA_MSR_FIFO;
+	}
+
+	restore_flags(flags);
+	return result;
+}
+
+/* Attempts to turn off the RSA FIFO.  Returns zero on failure */
+static int disable_rsa(struct uart_port *port)
+{
+	unsigned char mode;
+	int result;
+	unsigned long flags;
+
+	save_flags(flags); cli();
+	mode = serial_inp(port, UART_RSA_MSR);
+	result = !(mode & UART_RSA_MSR_FIFO);
+
+	if (!result) {
+		serial_outp(port, UART_RSA_MSR, mode & ~UART_RSA_MSR_FIFO);
+		mode = serial_inp(port, UART_RSA_MSR);
+		result = !(mode & UART_RSA_MSR_FIFO);
+	}
+
+	restore_flags(flags);
+	return result;
+}
+#endif /* CONFIG_SERIAL_RSA */
+
+/*
+ * This is a quickie test to see how big the FIFO is.
+ * It doesn't work at all the time, more's the pity.
+ */
+static int size_fifo(struct uart_port *port)
+{
+	unsigned char old_fcr, old_mcr, old_dll, old_dlm;
+	int count;
+
+	old_fcr = serial_inp(port, UART_FCR);
+	old_mcr = serial_inp(port, UART_MCR);
+	serial_outp(port, UART_FCR, UART_FCR_ENABLE_FIFO |
+		    UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);
+	serial_outp(port, UART_MCR, UART_MCR_LOOP);
+	serial_outp(port, UART_LCR, UART_LCR_DLAB);
+	old_dll = serial_inp(port, UART_DLL);
+	old_dlm = serial_inp(port, UART_DLM);
+	serial_outp(port, UART_DLL, 0x01);
+	serial_outp(port, UART_DLM, 0x00);
+	serial_outp(port, UART_LCR, 0x03);
+	for (count = 0; count < 256; count++)
+		serial_outp(port, UART_TX, count);
+	mdelay(20);
+	for (count = 0; (serial_inp(port, UART_LSR) & UART_LSR_DR) &&
+	     (count < 256); count++)
+		serial_inp(port, UART_RX);
+	serial_outp(port, UART_FCR, old_fcr);
+	serial_outp(port, UART_MCR, old_mcr);
+	serial_outp(port, UART_LCR, UART_LCR_DLAB);
+	serial_outp(port, UART_DLL, old_dll);
+	serial_outp(port, UART_DLM, old_dlm);
+
+	return count;
+}
+
+/*
+ * This is a helper routine to autodetect StarTech/Exar/Oxsemi UART's.
+ * When this function is called we know it is at least a StarTech
+ * 16650 V2, but it might be one of several StarTech UARTs, or one of
+ * its clones.  (We treat the broken original StarTech 16650 V1 as a
+ * 16550, and why not?  Startech doesn't seem to even acknowledge its
+ * existence.)
+ * 
+ * What evil have men's minds wrought...
+ */
+static void
+autoconfig_startech_uarts(struct uart_port *port)
+{
+	unsigned char scratch, scratch2, scratch3, scratch4;
+
+	/*
+	 * First we check to see if it's an Oxford Semiconductor UART.
+	 *
+	 * If we have to do this here because some non-National
+	 * Semiconductor clone chips lock up if you try writing to the
+	 * LSR register (which serial_icr_read does)
+	 */
+	if (port->type == PORT_16550A) {
+		/*
+		 * EFR [4] must be set else this test fails
+		 *
+		 * This shouldn't be necessary, but Mike Hudson
+		 * (Exoray@isys.ca) claims that it's needed for 952
+		 * dual UART's (which are not recommended for new designs).
+		 */
+		port->port_acr = 0;
+		serial_out(port, UART_LCR, 0xBF);
+		serial_out(port, UART_EFR, 0x10);
+		serial_out(port, UART_LCR, 0x00);
+		/* Check for Oxford Semiconductor 16C950 */
+		scratch = serial_icr_read(port, UART_ID1);
+		scratch2 = serial_icr_read(port, UART_ID2);
+		scratch3 = serial_icr_read(port, UART_ID3);
+		
+		if (scratch == 0x16 && scratch2 == 0xC9 &&
+		    (scratch3 == 0x50 || scratch3 == 0x52 ||
+		     scratch3 == 0x54)) {
+			port->type = PORT_16C950;
+			port->port_rev = serial_icr_read(port, UART_REV) |
+				(scratch3 << 8);
+			return;
+		}
+	}
+	
+	/*
+	 * We check for a XR16C850 by setting DLL and DLM to 0, and then
+	 * reading back DLL and DLM.  The chip type depends on the DLM
+	 * value read back:
+	 *  0x10 - XR16C850 and the DLL contains the chip revision.
+	 *  0x12 - XR16C2850.
+	 *  0x14 - XR16C854.
+	 */
+
+	/* Save the DLL and DLM */
+
+	serial_outp(port, UART_LCR, UART_LCR_DLAB);
+	scratch3 = serial_inp(port, UART_DLL);
+	scratch4 = serial_inp(port, UART_DLM);
+
+	serial_outp(port, UART_DLL, 0);
+	serial_outp(port, UART_DLM, 0);
+	scratch2 = serial_inp(port, UART_DLL);
+	scratch = serial_inp(port, UART_DLM);
+	serial_outp(port, UART_LCR, 0);
+
+	if (scratch == 0x10 || scratch == 0x12 || scratch == 0x14) {
+		if (scratch == 0x10)
+			port->port_rev = scratch2;
+		port->type = PORT_16850;
+		return;
+	}
+
+	/* Restore the DLL and DLM */
+
+	serial_outp(port, UART_LCR, UART_LCR_DLAB);
+	serial_outp(port, UART_DLL, scratch3);
+	serial_outp(port, UART_DLM, scratch4);
+	serial_outp(port, UART_LCR, 0);
+
+	/*
+	 * We distinguish between the '654 and the '650 by counting
+	 * how many bytes are in the FIFO.  I'm using this for now,
+	 * since that's the technique that was sent to me in the
+	 * serial driver update, but I'm not convinced this works.
+	 * I've had problems doing this in the past.  -TYT
+	 */
+	if (size_fifo(port) == 64)
+		port->type = PORT_16654;
+	else
+		port->type = PORT_16650V2;
+}
+
+/*
+ * This routine is called by rs_init() to initialize a specific serial
+ * port.  It determines what type of UART chip this serial port is
+ * using: 8250, 16450, 16550, 16550A.  The important question is
+ * whether or not this UART is a 16550A or not, since this will
+ * determine whether or not we can use its FIFO features or not.
+ */
+static void autoconfig(struct uart_port *port, unsigned int probeflags)
+{
+	unsigned char status1, status2, scratch, scratch2, scratch3;
+	unsigned char save_lcr, save_mcr;
+	unsigned long flags;
+
+#ifdef SERIAL_DEBUG_AUTOCONF
+	printk("Testing ttyS%d (0x%04x, 0x%08lx)...\n",
+		port->line, port->iobase, port->membase);
+#endif
+
+	if (!port->iobase && !port->membase)
+		return;
+
+	save_flags(flags); cli();
+
+	if (!(port->flags & ASYNC_BUGGY_UART)) {
+		/*
+		 * Do a simple existence test first; if we fail this,
+		 * there's no point trying anything else.
+		 * 
+		 * 0x80 is used as a nonsense port to prevent against
+		 * false positives due to ISA bus float.  The
+		 * assumption is that 0x80 is a non-existent port;
+		 * which should be safe since include/asm/io.h also
+		 * makes this assumption.
+		 */
+		scratch = serial_inp(port, UART_IER);
+		serial_outp(port, UART_IER, 0);
+#ifdef __i386__
+		outb(0xff, 0x080);
+#endif
+		scratch2 = serial_inp(port, UART_IER);
+		serial_outp(port, UART_IER, 0x0F);
+#ifdef __i386__
+		outb(0, 0x080);
+#endif
+		scratch3 = serial_inp(port, UART_IER);
+		serial_outp(port, UART_IER, scratch);
+		if (scratch2 || scratch3 != 0x0F) {
+#ifdef SERIAL_DEBUG_AUTOCONF
+			printk("serial: ttyS%d: simple autoconfig failed "
+			       "(%02x, %02x)\n", port->line, 
+			       scratch2, scratch3);
+#endif
+			restore_flags(flags);
+			return;		/* We failed; there's nothing here */
+		}
+	}
+
+	save_mcr = serial_in(port, UART_MCR);
+	save_lcr = serial_in(port, UART_LCR);
+
+	/* 
+	 * Check to see if a UART is really there.  Certain broken
+	 * internal modems based on the Rockwell chipset fail this
+	 * test, because they apparently don't implement the loopback
+	 * test mode.  So this test is skipped on the COM 1 through
+	 * COM 4 ports.  This *should* be safe, since no board
+	 * manufacturer would be stupid enough to design a board
+	 * that conflicts with COM 1-4 --- we hope!
+	 */
+	if (!(port->flags & ASYNC_SKIP_TEST)) {
+		serial_outp(port, UART_MCR, UART_MCR_LOOP | 0x0A);
+		status1 = serial_inp(port, UART_MSR) & 0xF0;
+		serial_outp(port, UART_MCR, save_mcr);
+		if (status1 != 0x90) {
+#ifdef SERIAL_DEBUG_AUTOCONF
+			printk("serial: ttyS%d: no UART loopback failed\n",
+			       port->line);
+#endif
+			restore_flags(flags);
+			return;
+		}
+	}
+	serial_outp(port, UART_LCR, 0xBF); /* set up for StarTech test */
+	serial_outp(port, UART_EFR, 0);	/* EFR is the same as FCR */
+	serial_outp(port, UART_LCR, 0);
+	serial_outp(port, UART_FCR, UART_FCR_ENABLE_FIFO);
+	scratch = serial_in(port, UART_IIR) >> 6;
+	switch (scratch) {
+		case 0:
+			port->type = PORT_16450;
+			break;
+		case 1:
+			port->type = PORT_UNKNOWN;
+			break;
+		case 2:
+			port->type = PORT_16550;
+			break;
+		case 3:
+			port->type = PORT_16550A;
+			break;
+	}
+	if (port->type == PORT_16550A) {
+		/* Check for Startech UART's */
+		serial_outp(port, UART_LCR, UART_LCR_DLAB);
+		if (serial_in(port, UART_EFR) == 0) {
+			port->type = PORT_16650;
+		} else {
+			serial_outp(port, UART_LCR, 0xBF);
+			if (serial_in(port, UART_EFR) == 0)
+				autoconfig_startech_uarts(port);
+		}
+	}
+	if (port->type == PORT_16550A) {
+		/* Check for TI 16750 */
+		serial_outp(port, UART_LCR, save_lcr | UART_LCR_DLAB);
+		serial_outp(port, UART_FCR,
+			    UART_FCR_ENABLE_FIFO | UART_FCR7_64BYTE);
+		scratch = serial_in(port, UART_IIR) >> 5;
+		if (scratch == 7) {
+			/*
+			 * If this is a 16750, and not a cheap UART
+			 * clone, then it should only go into 64 byte
+			 * mode if the UART_FCR7_64BYTE bit was set
+			 * while UART_LCR_DLAB was latched.
+			 */
+ 			serial_outp(port, UART_FCR, UART_FCR_ENABLE_FIFO);
+			serial_outp(port, UART_LCR, 0);
+			serial_outp(port, UART_FCR,
+				    UART_FCR_ENABLE_FIFO | UART_FCR7_64BYTE);
+			scratch = serial_in(port, UART_IIR) >> 5;
+			if (scratch == 6)
+				port->type = PORT_16750;
+		}
+		serial_outp(port, UART_FCR, UART_FCR_ENABLE_FIFO);
+	}
+#if defined(CONFIG_SERIAL_RSA) && defined(MODULE)
+	/*
+	 * Only probe for RSA ports if we got the region.
+	 */
+	if (port->type == PORT_16550A && probeflags & PROBE_RSA) {
+		int i;
+
+		for (i = 0 ; i < PORT_RSA_MAX ; ++i) {
+			if (!probe_rsa[i] && !force_rsa[i])
+				break;
+			if (((probe_rsa[i] != port->iobase) ||
+			     check_region(port->iobase + UART_RSA_BASE, 16)) &&
+			    (force_rsa[i] != port->iobase))
+				continue;
+			if (!enable_rsa(port))
+				continue;
+			port->type = PORT_RSA;
+			port->uartclk = SERIAL_RSA_BAUD_BASE * 16;
+			break;
+		}
+	}
+#endif
+	serial_outp(port, UART_LCR, save_lcr);
+	if (port->type == PORT_16450) {
+		scratch = serial_in(port, UART_SCR);
+		serial_outp(port, UART_SCR, 0xa5);
+		status1 = serial_in(port, UART_SCR);
+		serial_outp(port, UART_SCR, 0x5a);
+		status2 = serial_in(port, UART_SCR);
+		serial_outp(port, UART_SCR, scratch);
+
+		if ((status1 != 0xa5) || (status2 != 0x5a))
+			port->type = PORT_8250;
+	}
+	port->fifosize = uart_config[port->type].dfl_xmit_fifo_size;
+
+	if (port->type == PORT_UNKNOWN) {
+		restore_flags(flags);
+		return;
+	}
+
+#ifdef CONFIG_SERIAL_RSA
+	if (port->iobase && port->type == PORT_RSA) {
+		release_region(port->iobase, 8);
+		request_region(port->iobase + UART_RSA_BASE, 16,
+			       "serial_rsa");
+	}
+#endif
+
+	/*
+	 * Reset the UART.
+	 */
+#ifdef CONFIG_SERIAL_RSA
+	if (port->type == PORT_RSA)
+		serial_outp(port, UART_RSA_FRR, 0);
+#endif
+	serial_outp(port, UART_MCR, save_mcr);
+	serial_outp(port, UART_FCR, (UART_FCR_ENABLE_FIFO |
+				     UART_FCR_CLEAR_RCVR |
+				     UART_FCR_CLEAR_XMIT));
+	serial_outp(port, UART_FCR, 0);
+	(void)serial_in(port, UART_RX);
+	serial_outp(port, UART_IER, 0);
+	
+	restore_flags(flags);
+}
+
+static void autoconfig_irq(struct uart_port *port)
+{
+	unsigned char save_mcr, save_ier;
+	unsigned long irqs;
+	int irq;
+
+#ifdef CONFIG_SERIAL_MANY_PORTS
+	unsigned char save_ICP = 0;
+	unsigned short ICP = 0;
+
+	if (port->flags & ASYNC_FOURPORT) {
+		ICP = (port->iobase & 0xfe0) | 0x1f;
+		save_ICP = inb_p(ICP);
+		outb_p(0x80, ICP);
+		(void) inb_p(ICP);
+	}
+#endif
+
+	/* forget possible initially masked and pending IRQ */
+	probe_irq_off(probe_irq_on());
+	save_mcr = serial_inp(port, UART_MCR);
+	save_ier = serial_inp(port, UART_IER);
+	serial_outp(port, UART_MCR, UART_MCR_OUT1 | UART_MCR_OUT2);
+	
+	irqs = probe_irq_on();
+	serial_outp(port, UART_MCR, 0);
+	udelay (10);
+	if (port->flags & ASYNC_FOURPORT)  {
+		serial_outp(port, UART_MCR,
+			    UART_MCR_DTR | UART_MCR_RTS);
+	} else {
+		serial_outp(port, UART_MCR,
+			    UART_MCR_DTR | UART_MCR_RTS | UART_MCR_OUT2);
+	}
+	serial_outp(port, UART_IER, 0x0f);	/* enable all intrs */
+	(void)serial_inp(port, UART_LSR);
+	(void)serial_inp(port, UART_RX);
+	(void)serial_inp(port, UART_IIR);
+	(void)serial_inp(port, UART_MSR);
+	serial_outp(port, UART_TX, 0xFF);
+	udelay (20);
+	irq = probe_irq_off(irqs);
+
+	serial_outp(port, UART_MCR, save_mcr);
+	serial_outp(port, UART_IER, save_ier);
+#ifdef CONFIG_SERIAL_MANY_PORTS
+	if (port->flags & ASYNC_FOURPORT)
+		outb_p(save_ICP, ICP);
+#endif
+	port->irq = (irq > 0)? irq : 0;
+}
+
+static void serial8250_stop_tx(struct uart_port *port, u_int from_tty)
+{
+	if (port->port_ier & UART_IER_THRI) {
+		port->port_ier &= ~UART_IER_THRI;
+		serial_out(port, UART_IER, port->port_ier);
+	}
+	if (port->type == PORT_16C950) {
+		port->port_acr |= UART_ACR_TXDIS;
+		serial_icr_write(port, UART_ACR, port->port_acr);
+	}
+}
+
+static void serial8250_start_tx(struct uart_port *port, u_int nonempty, u_int from_tty)
+{
+	if (nonempty && !(port->port_ier & UART_IER_THRI)) {
+		port->port_ier |= UART_IER_THRI;
+		serial_out(port, UART_IER, port->port_ier);
+	}
+	/*
+	 * We only do this from uart_start
+	 */
+	if (from_tty && port->type == PORT_16C950) {
+		port->port_acr &= ~UART_ACR_TXDIS;
+		serial_icr_write(port, UART_ACR, port->port_acr);
+	}
+}
+
+static void serial8250_stop_rx(struct uart_port *port)
+{
+	port->port_ier &= ~UART_IER_RLSI;
+	port->read_status_mask &= ~UART_LSR_DR;
+	serial_out(port, UART_IER, port->port_ier);
+}
+
+static void serial8250_enable_ms(struct uart_port *port)
+{
+	port->port_ier |= UART_IER_MSI;
+	serial_out(port, UART_IER, port->port_ier);
+}
+
+static _INLINE_ void
+receive_chars(struct uart_info *info, int *status, struct pt_regs *regs)
+{
+	struct tty_struct *tty = info->tty;
+	struct uart_port *port = info->port;
+	unsigned char ch;
+	int max_count = 256;
+
+	do {
+		if (tty->flip.count >= TTY_FLIPBUF_SIZE) {
+			tty->flip.tqueue.routine((void *)tty);
+			if (tty->flip.count >= TTY_FLIPBUF_SIZE)
+				return; // if TTY_DONT_FLIP is set
+		}
+		ch = serial_inp(port, UART_RX);
+		*tty->flip.char_buf_ptr = ch;
+		*tty->flip.flag_buf_ptr = TTY_NORMAL;
+		port->icount.rx++;
+
+		if (*status & (UART_LSR_BI | UART_LSR_PE |
+			       UART_LSR_FE | UART_LSR_OE)) {
+			/*
+			 * For statistics only
+			 */
+			if (*status & UART_LSR_BI) {
+				*status &= ~(UART_LSR_FE | UART_LSR_PE);
+				port->icount.brk++;
+				/*
+				 * We do the SysRQ and SAK checking
+				 * here because otherwise the break
+				 * may get masked by ignore_status_mask
+				 * or read_status_mask.
+				 */
+				uart_handle_break(info, &serial8250_console);
+			} else if (*status & UART_LSR_PE)
+				port->icount.parity++;
+			else if (*status & UART_LSR_FE)
+				port->icount.frame++;
+			if (*status & UART_LSR_OE)
+				port->icount.overrun++;
+
+			/*
+			 * Mask off conditions which should be ingored.
+			 */
+			*status &= port->read_status_mask;
+
+#ifdef CONFIG_SERIAL_8250_CONSOLE
+			if (port->line == serial8250_console.index) {
+				/* Recover the break flag from console xmit */
+				*status |= lsr_break_flag;
+				lsr_break_flag = 0;
+			}
+#endif
+			if (*status & UART_LSR_BI) {
+#ifdef SERIAL_DEBUG_INTR
+				printk("handling break....");
+#endif
+				*tty->flip.flag_buf_ptr = TTY_BREAK;
+			} else if (*status & UART_LSR_PE)
+				*tty->flip.flag_buf_ptr = TTY_PARITY;
+			else if (*status & UART_LSR_FE)
+				*tty->flip.flag_buf_ptr = TTY_FRAME;
+		}
+		if (uart_handle_sysrq_char(info, ch, regs))
+			goto ignore_char;
+		if ((*status & port->ignore_status_mask) == 0) {
+			tty->flip.flag_buf_ptr++;
+			tty->flip.char_buf_ptr++;
+			tty->flip.count++;
+		}
+		if ((*status & UART_LSR_OE) &&
+		    tty->flip.count < TTY_FLIPBUF_SIZE) {
+			/*
+			 * Overrun is special, since it's reported
+			 * immediately, and doesn't affect the current
+			 * character.
+			 */
+			*tty->flip.flag_buf_ptr = TTY_OVERRUN;
+			tty->flip.flag_buf_ptr++;
+			tty->flip.char_buf_ptr++;
+			tty->flip.count++;
+		}
+	ignore_char:
+		*status = serial_inp(port, UART_LSR);
+	} while ((*status & UART_LSR_DR) && (max_count-- > 0));
+	tty_flip_buffer_push(tty);
+}
+
+static _INLINE_ void transmit_chars(struct uart_info *info, int *intr_done)
+{
+	struct uart_port *port = info->port;
+	int count;
+
+	if (port->x_char) {
+		serial_outp(port, UART_TX, port->x_char);
+		port->icount.tx++;
+		port->x_char = 0;
+		if (intr_done)
+			*intr_done = 0;
+		return;
+	}
+	if (info->xmit.head == info->xmit.tail
+	    || info->tty->stopped
+	    || info->tty->hw_stopped) {
+		serial8250_stop_tx(port, 0);
+		return;
+	}
+
+	count = port->fifosize;
+	do {
+		serial_out(port, UART_TX, info->xmit.buf[info->xmit.tail]);
+		info->xmit.tail = (info->xmit.tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+		if (info->xmit.head == info->xmit.tail)
+			break;
+	} while (--count > 0);
+
+	if (CIRC_CNT(info->xmit.head, info->xmit.tail, UART_XMIT_SIZE) <
+			WAKEUP_CHARS)
+		uart_event(info, EVT_WRITE_WAKEUP);
+
+#ifdef SERIAL_DEBUG_INTR
+	printk("THRE...");
+#endif
+	if (intr_done)
+		*intr_done = 0;
+
+	if (info->xmit.head == info->xmit.tail)
+		serial8250_stop_tx(info->port, 0);
+}
+
+static _INLINE_ void check_modem_status(struct uart_info *info)
+{
+	struct uart_port *port = info->port;
+	int status;
+
+	status = serial_in(port, UART_MSR);
+
+	if (status & UART_MSR_ANY_DELTA) {
+		if (status & UART_MSR_TERI)
+			port->icount.rng++;
+		if (status & UART_MSR_DDSR)
+			port->icount.dsr++;
+		if (status & UART_MSR_DDCD)
+			uart_handle_dcd_change(info, status & UART_MSR_DCD);
+		if (status & UART_MSR_DCTS)
+			uart_handle_cts_change(info, status & UART_MSR_CTS);
+
+		wake_up_interruptible(&info->delta_msr_wait);
+	}
+}
+
+/*
+ * This handles the interrupt from one port.
+ */
+static inline void
+serial8250_handle_port(struct uart_info *info, struct pt_regs *regs)
+{
+	int status = serial_inp(info->port, UART_LSR);
+#ifdef SERIAL_DEBUG_INTR
+	printk("status = %x...", status);
+#endif
+	if (status & UART_LSR_DR)
+		receive_chars(info, &status, regs);
+	check_modem_status(info);
+	if (status & UART_LSR_THRE)
+		transmit_chars(info, 0);
+}
+
+#ifdef CONFIG_SERIAL_8250_SHARE_IRQ
+/*
+ * This is the serial driver's generic interrupt routine
+ */
+static void rs_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct uart_info *info, *end_mark = NULL;
+	int pass_counter = 0;
+#ifdef CONFIG_SERIAL_8250_MULTIPORT
+	int first_multi = 0;
+	unsigned long port_monitor = rs_multiport[irq].port_monitor;
+#endif
+
+#ifdef SERIAL_DEBUG_INTR
+	printk("rs_interrupt(%d)...", irq);
+#endif
+
+	info = *(struct uart_info **)dev_id;
+	if (!info)
+		return;
+
+#ifdef CONFIG_SERIAL_8250_MULTIPORT
+	if (port_monitor)
+		first_multi = inb(port_monitor);
+#endif
+
+	do {
+		if (!info->tty ||
+		    (serial_in(info->port, UART_IIR) & UART_IIR_NO_INT)) {
+		    	if (!end_mark)
+		    		end_mark = info;
+			goto next;
+		}
+#ifdef SERIAL_DEBUG_INTR
+		printk("IIR = %x...", serial_in(info->port, UART_IIR));
+#endif
+		end_mark = NULL;
+
+		serial8250_handle_port(info, regs);
+
+	next:
+		info = info->next_info;
+		if (info)
+			continue;
+		info = *(struct uart_info **)dev_id;
+		if (pass_counter++ > RS_ISR_PASS_LIMIT) {
+#if 0
+			printk("rs loop break\n");
+#endif
+			break; /* Prevent infinite loops */
+		}
+	} while (end_mark != info);
+#ifdef CONFIG_SERIAL_8250_MULTIPORT
+	if (port_monitor)
+		printk("rs port monitor (normal) irq %d: 0x%x, 0x%x\n",
+			info->port->irq, first_multi, inb(port_monitor));
+#endif
+#ifdef SERIAL_DEBUG_INTR
+	printk("end.\n");
+#endif
+}
+#endif
+
+/*
+ * This is the serial driver's interrupt routine for a single port
+ */
+static void rs_interrupt_single(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct uart_info *info;
+	int pass_counter = 0;
+#ifdef CONFIG_SERIAL_8250_MULTIPORT
+	int first_multi = 0;
+	unsigned long port_monitor = rs_multiport[irq].port_monitor;
+#endif
+
+#ifdef SERIAL_DEBUG_INTR
+	printk("rs_interrupt_single(%d)...", irq);
+#endif
+
+	info = *(struct uart_info **)dev_id;
+	if (!info || !info->tty)
+		return;
+
+#ifdef CONFIG_SERIAL_8250_MULTIPORT
+	if (port_monitor)
+		first_multi = inb(port_monitor);
+#endif
+
+	do {
+		serial8250_handle_port(info, regs);
+		if (pass_counter++ > RS_ISR_PASS_LIMIT) {
+#if 0
+			printk("rs_single loop break.\n");
+#endif
+			break;
+		}
+#ifdef SERIAL_DEBUG_INTR
+		printk("IIR = %x...", serial_in(info->port, UART_IIR));
+#endif
+	} while (!(serial_in(info->port, UART_IIR) & UART_IIR_NO_INT));
+#ifdef CONFIG_SERIAL_8250_MULTIPORT
+	if (port_monitor)
+		printk("rs port monitor (single) irq %d: 0x%x, 0x%x\n",
+			info->port->irq, first_multi, inb(port_monitor));
+#endif
+#ifdef SERIAL_DEBUG_INTR
+	printk("end.\n");
+#endif
+}
+
+#ifdef CONFIG_SERIAL_8250_MULTIPORT
+/*
+ * This is the serial driver's interrupt routine for multiport boards
+ */
+static void rs_interrupt_multi(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct uart_info *info;
+	int pass_counter = 0;
+	struct rs_multiport_struct *multi = &rs_multiport[irq];
+	int first_multi = 0;
+
+#ifdef SERIAL_DEBUG_INTR
+	printk("rs_interrupt_multi(%d)...", irq);
+#endif
+
+	info = *(struct uart_info **)dev_id;
+	if (!info)
+		return;
+
+	if (!multi->port1) {
+		/* should never happen */
+		printk("rs_interrupt_multi: port1 NULL!\n");
+		return;
+	}
+	if (multi->port_monitor)
+		first_multi = inb(multi->port_monitor);
+
+	while (1) {
+		if (!info->tty ||
+		    (serial_in(info->port, UART_IIR) & UART_IIR_NO_INT))
+			goto next;
+
+		serial8250_handle_port(info, regs);
+
+	next:
+		info = info->next;
+		if (info)
+			continue;
+		info = *(struct uart_info **)dev_id;
+
+		/*
+		 * The user was a bonehead, and misconfigured their
+		 * multiport info.  Rather than lock up the kernel
+		 * in an infinite loop, if we loop too many times,
+		 * print a message and break out of the loop.
+		 */
+		if (pass_counter++ > RS_ISR_PASS_LIMIT) {
+			printk("Misconfigured multiport serial info "
+			       "for irq %d.  Breaking out irq loop\n", irq);
+			break;
+		}
+		if (multi->port_monitor)
+			printk("rs port monitor irq %d: 0x%x, 0x%x\n",
+				info->port->irq, first_multi,
+				inb(multi->port_monitor));
+		if ((inb(multi->port1) & multi->mask1) != multi->match1)
+			continue;
+		if (!multi->port2)
+			break;
+		if ((inb(multi->port2) & multi->mask2) != multi->match2)
+			continue;
+		if (!multi->port3)
+			break;
+		if ((inb(multi->port3) & multi->mask3) != multi->match3)
+			continue;
+		if (!multi->port4)
+			break;
+		if ((inb(multi->port4) & multi->mask4) != multi->match4)
+			continue;
+		break;
+	}
+#ifdef SERIAL_DEBUG_INTR
+	printk("end.\n");
+#endif
+}
+#endif
+
+static u_int serial8250_tx_empty(struct uart_port *port)
+{
+	return serial_in(port, UART_LSR) & UART_LSR_TEMT ? TIOCSER_TEMT : 0;
+}
+
+static u_int serial8250_get_mctrl(struct uart_port *port)
+{
+	unsigned long flags;
+	unsigned char status;
+	unsigned int ret;
+
+	save_flags(flags); cli();
+	status = serial_in(port, UART_MSR);
+	restore_flags(flags);
+
+	ret = 0;
+	if (status & UART_MSR_DCD)
+		ret |= TIOCM_CAR;
+	if (status & UART_MSR_RI)
+		ret |= TIOCM_RNG;
+	if (status & UART_MSR_DSR)
+		ret |= TIOCM_DSR;
+	if (status & UART_MSR_CTS)
+		ret |= TIOCM_CTS;
+	return ret;
+}
+
+static void serial8250_set_mctrl(struct uart_port *port, u_int mctrl)
+{
+	unsigned char mcr = 0;
+
+	if (mctrl & TIOCM_RTS)
+		mcr |= UART_MCR_RTS;
+	if (mctrl & TIOCM_DTR)
+		mcr |= UART_MCR_DTR;
+	if (mctrl & TIOCM_OUT1)
+		mcr |= UART_MCR_OUT1;
+	if (mctrl & TIOCM_OUT2)
+		mcr |= UART_MCR_OUT2;
+	if (mctrl & TIOCM_LOOP)
+		mcr |= UART_MCR_LOOP;
+
+	serial_out(port, UART_MCR, mcr);
+}
+
+static void serial8250_break_ctl(struct uart_port *port, int break_state)
+{
+	if (break_state == -1)
+		port->port_lcr |= UART_LCR_SBC;
+	else
+		port->port_lcr &= ~UART_LCR_SBC;
+	serial_out(port, UART_LCR, port->port_lcr);
+}
+
+static int serial8250_startup(struct uart_port *port, struct uart_info *info)
+{
+	void (*handler)(int, void *, struct pt_regs *);
+	unsigned long flags;
+	int retval;
+
+	if (port->type == PORT_16C950) {
+		/* Wake up and initialize UART */
+		port->port_acr = 0;
+		serial_outp(port, UART_LCR, 0xBF);
+		serial_outp(port, UART_EFR, UART_EFR_ECB);
+		serial_outp(port, UART_IER, 0);
+		serial_outp(port, UART_LCR, 0);
+		serial_icr_write(port, UART_CSR, 0); /* Reset the UART */
+		serial_outp(port, UART_LCR, 0xBF);
+		serial_outp(port, UART_EFR, UART_EFR_ECB);
+		serial_outp(port, UART_LCR, 0);
+	}
+
+#ifdef CONFIG_SERIAL_RSA
+	/*
+	 * If this is an RSA port, see if we can kick it up to the
+	 * higher speed clock.
+	 */
+	if (port->type == PORT_RSA) {
+		if (port->uartclk != SERIAL_RSA_BAUD_BASE * 16 &&
+		    enable_rsa(port))
+			port->uartclk = SERIAL_RSA_BAUD_BASE * 16;
+		if (port->uartclk == SERIAL_RSA_BAUD_BASE * 16)
+			serial_outp(port, UART_RSA_FRR, 0);
+	}
+#endif
+
+	/*
+	 * Clear the FIFO buffers and disable them.
+	 * (they will be reeanbled in change_speed())
+	 */
+	if (uart_config[port->type].flags & UART_CLEAR_FIFO) {
+		serial_outp(port, UART_FCR, UART_FCR_ENABLE_FIFO);
+		serial_outp(port, UART_FCR, UART_FCR_ENABLE_FIFO |
+				UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);
+		serial_outp(port, UART_FCR, 0);
+	}
+
+	/*
+	 * Clear the interrupt registers.
+	 */
+	(void) serial_inp(port, UART_LSR);
+	(void) serial_inp(port, UART_RX);
+	(void) serial_inp(port, UART_IIR);
+	(void) serial_inp(port, UART_MSR);
+
+	/*
+	 * At this point, there's no way the LSR could still be 0xff;
+	 * if it is, then bail out, because there's likely no UART
+	 * here.
+	 */
+	if (!(port->flags & ASYNC_BUGGY_UART) &&
+	    (serial_inp(port, UART_LSR) == 0xff)) {
+		printk("ttyS%d: LSR safety check engaged!\n", port->line);
+		return -ENODEV;
+	}
+
+	/*
+	 * Allocate the IRQ if necessary
+	 */
+	if (port->irq && (!IRQ_ports[port->irq] ||
+			  !IRQ_ports[port->irq]->next_info)) {
+		handler = rs_interrupt_single;
+		if (IRQ_ports[port->irq]) {
+#ifdef CONFIG_SERIAL_8250_SHARE_IRQ
+			handler = rs_interrupt;
+			free_irq(port->irq, &IRQ_ports[port->irq]);
+#ifdef CONFIG_SERIAL_8250_MULTIPORT
+			if (rs_multiport[port->irq].port1)
+				handler = serial8250_interrupt_multi;
+#endif
+#else
+			return -EBUSY;
+#endif /* CONFIG_SERIAL_8250_SHARE_IRQ */
+		}
+
+		retval = request_irq(port->irq, handler, SA_SHIRQ,
+				     "serial", &IRQ_ports[port->irq]);
+		if (retval)
+			return retval;
+	}
+
+	/*
+	 * Insert serial port into IRQ chain.
+	 */
+	info->next_info = IRQ_ports[port->irq];
+	IRQ_ports[port->irq] = info;
+
+	/*
+	 * Now, initialize the UART
+	 */
+	serial_outp(port, UART_LCR, UART_LCR_WLEN8);
+
+#ifdef CONFIG_SERIAL_MANY_PORTS
+	if (port->flags & ASYNC_FOURPORT) {
+		if (port->irq == 0)
+			info->mctrl |= TIOCM_OUT1;
+	} else
+#endif
+		/*
+		 * Most PC uarts need OUT2 raised to enable interrupts.
+		 */
+		if (port->irq != 0)
+			info->mctrl |= TIOCM_OUT2;
+
+	/* FIXME: ALPHA_KLUDGE_MCR; */
+	serial8250_set_mctrl(port, info->mctrl);
+
+	/*
+	 * Finally, enable interrupts.  Note: Modem status interrupts
+	 * are set via change_speed(), which will be occuring imminently
+	 * anyway, so we don't enable them here.
+	 */
+	port->port_ier = UART_IER_RLSI | UART_IER_RDI;
+	serial_outp(port, UART_IER, port->port_ier);
+
+#ifdef CONFIG_SERIAL_MANY_PORTS
+	if (port->flags & ASYNC_FOURPORT) {
+		unsigned int ICP;
+		/*
+		 * Enable interrupts on the AST Fourport board
+		 */
+		ICP = (port->iobase & 0xfe0) | 0x01f;
+		outb_p(0x80, ICP);
+		(void) inb_p(ICP);
+	}
+#endif
+
+	/*
+	 * And clear the interrupt registers again for luck.
+	 */
+	(void) serial_inp(port, UART_LSR);
+	(void) serial_inp(port, UART_RX);
+	(void) serial_inp(port, UART_IIR);
+	(void) serial_inp(port, UART_MSR);
+
+	return 0;
+}
+
+static void serial8250_shutdown(struct uart_port *port, struct uart_info *info)
+{
+	struct uart_info **infop;
+	unsigned long flags;
+	int retval;
+
+	/*
+	 * First, disable all intrs from the port.
+	 */
+	port->port_ier = 0;
+	serial_outp(port, UART_IER, 0);
+
+	synchronize_irq();
+
+	/*
+	 * unlink the serial port from the IRQ chain...
+	 */
+	for (infop = &IRQ_ports[port->irq]; *infop; infop = &(*infop)->next_info)
+		if (*infop == info)
+			break;
+
+	if (*infop == info)
+		*infop = info->next_info;
+
+	/*
+	 * Free the IRQ, if necessary
+	 */
+	if (port->irq && (!IRQ_ports[port->irq] ||
+			  !IRQ_ports[port->irq]->next_info)) {
+		free_irq(port->irq, &IRQ_ports[port->irq]);
+		if (IRQ_ports[port->irq]) {
+			retval = request_irq(port->irq, rs_interrupt_single,
+					     SA_SHIRQ, "serial", &IRQ_ports[port->irq]);
+			if (retval)
+				printk("serial shutdown: request_irq: error %d"
+				       " couldn't reacquire IRQ.\n", retval);
+		}
+	}
+
+#ifdef CONFIG_SERIAL_MANY_PORTS
+	if (port->flags & ASYNC_FOURPORT) {
+		/* reset interrupts on the AST Fourport board */
+		inb((port->iobase & 0xfe0) | 0x1f);
+		info->mctrl |= TIOCM_OUT1;
+	} else
+#endif
+		info->mctrl &= ~TIOCM_OUT2;
+
+	/* FIXME: ALPHA_KLUDGE_MCR; */
+	serial8250_set_mctrl(port, info->mctrl);
+
+	/*
+	 * Disable break condition and FIFOs
+	 */
+	serial_out(port, UART_LCR, serial_inp(port, UART_LCR) & ~UART_LCR_SBC);
+	serial_outp(port, UART_FCR, UART_FCR_ENABLE_FIFO |
+				    UART_FCR_CLEAR_RCVR |
+				    UART_FCR_CLEAR_XMIT);
+	serial_outp(port, UART_FCR, 0);
+
+#ifdef CONFIG_SERIAL_RSA
+	/*
+	 * Reset the RSA board back to 115kbps compat mode.
+	 */
+	if (port->type == PORT_RSA &&
+	    port->uartclk == SERIAL_RSA_BAUD_BASE * 16 &&
+	    disable_rsa(port))
+		port->uartclk = SERIAL_RSA_BAUD_BASE_LO * 16;
+#endif
+
+	/*
+	 * Read data port to reset things
+	 */
+	(void) serial_in(port, UART_RX);
+}
+
+static void serial8250_change_speed(struct uart_port *port, u_int cflag, u_int iflag, u_int quot)
+{
+	unsigned char cval, fcr = 0;
+	unsigned long flags;
+
+	switch (cflag & CSIZE) {
+	case CS5:	cval = 0x00;	break;
+	case CS6:	cval = 0x01;	break;
+	case CS7:	cval = 0x02;	break;
+	default:
+	case CS8:	cval = 0x03;	break;
+	}
+
+	if (cflag & CSTOPB)
+		cval |= 0x04;
+	if (cflag & PARENB)
+		cval |= UART_LCR_PARITY;
+	if (!(cflag & PARODD))
+		cval |= UART_LCR_EPAR;
+#ifdef CMSPAR
+	if (cflag & CMSPAR)
+		cval |= UART_LCR_SPAR;
+#endif
+
+	/*
+	 * Work around a bug in the Oxford Semiconductor 952 rev B
+	 * chip which causes it to seriously miscalculate baud rates
+	 * when DLL is 0.
+	 */
+	if ((quot & 0xff) == 0 && port->type == PORT_16C950 &&
+	    port->port_rev == 0x5201)
+		quot ++;
+
+	if (uart_config[port->type].flags & UART_USE_FIFO) {
+		if ((port->uartclk / quot) < (2400 * 16))
+			fcr = UART_FCR_ENABLE_FIFO | UART_FCR_TRIGGER_1;
+#ifdef CONFIG_SERIAL_RSA
+		else if (port->type == PORT_RSA)
+			fcr = UART_FCR_ENABLE_FIFO | UART_FCR_TRIGGER_14;
+#endif
+		else
+			fcr = UART_FCR_ENABLE_FIFO | UART_FCR_TRIGGER_8;
+	}
+	if (port->type == PORT_16750)
+		fcr |= UART_FCR7_64BYTE;
+
+	port->read_status_mask = UART_LSR_OE | UART_LSR_THRE | UART_LSR_DR;
+	if (iflag & IGNPAR)
+		port->read_status_mask |= UART_LSR_FE | UART_LSR_PE;
+	if (iflag & (BRKINT | PARMRK))
+		port->read_status_mask |= UART_LSR_BI;
+
+	/*
+	 * Characteres to ignore
+	 */
+	port->ignore_status_mask = 0;
+	if (iflag & IGNPAR)
+		port->ignore_status_mask |= UART_LSR_PE | UART_LSR_FE;
+	if (iflag & IGNBRK) {
+		port->ignore_status_mask |= UART_LSR_BI;
+		/*
+		 * If we're ignoring parity and break indicators,
+		 * ignore overruns too (for real raw support).
+		 */
+		if (iflag & IGNPAR)
+			port->ignore_status_mask |= UART_LSR_OE;
+	}
+
+	/*
+	 * ignore all characters if CREAD is not set
+	 */
+	if ((cflag & CREAD) == 0)
+		port->ignore_status_mask |= UART_LSR_DR;
+
+	/*
+	 * CTS flow control flag and modem status interrupts
+	 */
+	port->port_ier &= ~UART_IER_MSI;
+	if (port->flags & ASYNC_HARDPPS_CD || cflag & CRTSCTS ||
+	    !(cflag & CLOCAL))
+		port->port_ier |= UART_IER_MSI;
+
+	/*
+	 * Ok, we're now changing the port state.  Do it with
+	 * interrupts disabled.
+	 */
+	save_flags(flags); cli();
+	serial_out(port, UART_IER, port->port_ier);
+
+	if (uart_config[port->type].flags & UART_STARTECH) {
+		serial_outp(port, UART_LCR, 0xBF);
+		serial_outp(port, UART_EFR, cflag & CRTSCTS ? UART_EFR_CTS :0);
+	}
+	serial_outp(port, UART_LCR, cval | UART_LCR_DLAB);	/* set DLAB */
+	serial_outp(port, UART_DLL, quot & 0xff);	/* LS of divisor */
+	serial_outp(port, UART_DLM, quot >> 8);		/* MS of divisor */
+	if (port->type == PORT_16750)
+		serial_outp(port, UART_FCR, fcr);	/* set fcr */
+	serial_outp(port, UART_LCR, cval);		/* reset DLAB */
+	port->port_lcr = cval;				/* Save LCR */
+	if (port->type != PORT_16750) {
+		if (fcr & UART_FCR_ENABLE_FIFO) {
+			/* emulated UARTs (Lucent Venus 167x) need two steps */
+			serial_outp(port, UART_FCR, UART_FCR_ENABLE_FIFO);
+		}
+		serial_outp(port, UART_FCR, fcr);	/* set fcr */
+	}
+	restore_flags(flags);
+}
+
+static void serial8250_pm(struct uart_port *port, u_int state, u_int oldstate)
+{
+	if (state) {
+		/* sleep */
+		if (uart_config[port->type].flags & UART_STARTECH) {
+			/* Arrange to enter sleep mode */
+			serial_outp(port, UART_LCR, 0xBF);
+			serial_outp(port, UART_EFR, UART_EFR_ECB);
+			serial_outp(port, UART_LCR, 0);
+			serial_outp(port, UART_IER, UART_IERX_SLEEP);
+			serial_outp(port, UART_LCR, 0xBF);
+			serial_outp(port, UART_EFR, 0);
+			serial_outp(port, UART_LCR, 0);
+		}
+		if (port->type == PORT_16750) {
+			/* Arrange to enter sleep mode */
+			serial_outp(port, UART_IER, UART_IERX_SLEEP);
+		}
+	} else {
+		/* wake */
+		if (uart_config[port->type].flags & UART_STARTECH) {
+			/* Wake up UART */
+			serial_outp(port, UART_LCR, 0xBF);
+			serial_outp(port, UART_EFR, UART_EFR_ECB);
+			/*
+			 * Turn off LCR == 0xBF so we actually set the IER
+			 * register on the XR16C850
+			 */
+			serial_outp(port, UART_LCR, 0);
+			serial_outp(port, UART_IER, 0);
+			/*
+			 * Now reset LCR so we can turn off the ECB bit
+			 */
+			serial_outp(port, UART_LCR, 0xBF);
+			serial_outp(port, UART_EFR, 0);
+			/*
+			 * For a XR16C850, we need to set the trigger levels
+			 */
+			if (port->type == PORT_16850) {
+				unsigned char fctr;
+
+				fctr = serial_inp(port, UART_FCTR) &
+					 ~(UART_FCTR_RX | UART_FCTR_TX);
+				serial_outp(port, UART_FCTR, fctr |
+						UART_FCTR_TRGD |
+						UART_FCTR_RX);
+				serial_outp(port, UART_TRG, UART_TRG_96);
+				serial_outp(port, UART_FCTR, fctr |
+						UART_FCTR_TRGD |
+						UART_FCTR_TX);
+				serial_outp(port, UART_TRG, UART_TRG_96);
+			}
+			serial_outp(port, UART_LCR, 0);
+		}
+
+		if (port->type == PORT_16750) {
+			/* Wake up UART */
+			serial_outp(port, UART_IER, 0);
+		}
+	}
+}
+
+/*
+ * Resource handling.  This is complicated by the fact that resources
+ * depend on the port type.  Maybe we should be claiming the standard
+ * 8250 ports, and then trying to get other resources as necessary?
+ */
+static int
+serial8250_request_std_resource(struct uart_port *port, struct resource **res)
+{
+	unsigned int size = 8 << port->regshift;
+	int ret = 0;
+
+	switch (port->iotype) {
+	case SERIAL_IO_MEM:
+		if (port->mapbase) {
+			*res = request_mem_region(port->mapbase, size, "serial");
+			if (!*res)
+				ret = -EBUSY;
+		}
+		break;
+
+	case SERIAL_IO_HUB6:
+	case SERIAL_IO_PORT:
+		*res = request_region(port->iobase, size, "serial");
+		if (!*res)
+			ret = -EBUSY;
+		break;
+	}
+	return ret;
+}
+
+static int
+serial8250_request_rsa_resource(struct uart_port *port, struct resource **res)
+{
+	unsigned long start, size = 8 << port->regshift;
+	int ret = 0;
+
+	switch (port->iotype) {
+	case SERIAL_IO_MEM:
+		if (port->mapbase) {
+			start = port->mapbase;
+			start += UART_RSA_BASE << port->regshift;
+			*res = request_mem_region(start, size, "serial-rsa");
+			if (!*res)
+				ret = -EBUSY;
+		}
+		break;
+
+	case SERIAL_IO_HUB6:
+	case SERIAL_IO_PORT:
+		start = port->iobase;
+		start += UART_RSA_BASE << port->regshift;
+		*res = request_region(start, size, "serial-rsa");
+		if (!*res)
+			ret = -EBUSY;
+		break;
+	}
+
+	return ret;
+}
+
+static void serial8250_release_port(struct uart_port *port)
+{
+	unsigned long start, offset = 0, size = 0;
+
+	if (port->type == PORT_RSA) {
+		offset = UART_RSA_BASE << port->regshift;
+		size = 8;
+	}
+
+	offset <<= port->regshift;
+	size <<= port->regshift;
+
+	switch (port->iotype) {
+	case SERIAL_IO_MEM:
+		if (port->mapbase) {
+			/*
+			 * Unmap the area.
+			 */
+			iounmap(port->membase);
+			port->membase = NULL;
+
+			start = port->mapbase;
+
+			if (size)
+				release_mem_region(start + offset, size);
+			release_mem_region(start, 8 << port->regshift);
+		}
+		break;
+
+	case SERIAL_IO_HUB6:
+	case SERIAL_IO_PORT:
+		start = port->iobase;
+
+		if (size)
+			release_region(start + offset, size);
+		release_region(start + offset, 8 << port->regshift);
+		break;
+
+	default:
+		break;
+	}
+}
+
+static int serial8250_request_port(struct uart_port *port)
+{
+	struct resource *res = NULL, *res_rsa = NULL;
+	int ret = -EBUSY;
+
+	if (port->type == PORT_RSA) {
+		ret = serial8250_request_rsa_resource(port, &res_rsa);
+		if (ret)
+			return ret;
+	}
+
+	ret = serial8250_request_std_resource(port, &res);
+
+	/*
+	 * If we have a mapbase, then request that as well.
+	 */
+	if (res != NULL && port->iotype == SERIAL_IO_MEM &&
+	    port->mapbase) {
+		int size = res->end - res->start + 1;
+
+		port->membase = ioremap(port->mapbase, size);
+		if (!port->membase)
+			ret = -ENOMEM;
+	}
+
+	if (ret) {
+		if (res_rsa)
+			release_resource(res_rsa);
+		if (res)
+			release_resource(res);
+	}
+	return ret;
+}
+
+static void serial8250_config_port(struct uart_port *port, int flags)
+{
+	struct resource *res_std = NULL, *res_rsa = NULL;
+	int probeflags = PROBE_ANY;
+	int ret;
+
+#ifdef CONFIG_MCA
+	/*
+	 * Don't probe for MCA ports on non-MCA machines.
+	 */
+	if (port->flags & ASYNC_BOOT_ONLYMCA && !MCA_bus)
+		return;
+#endif
+
+	/*
+	 * Find the region that we can probe for.  This in turn
+	 * tells us whether we can probe for the type of port.
+	 */
+	ret = serial8250_request_std_resource(port, &res_std);
+	if (ret)
+		return;
+
+	ret = serial8250_request_rsa_resource(port, &res_rsa);
+	if (ret)
+		probeflags &= ~PROBE_RSA;
+
+	if (flags & UART_CONFIG_TYPE)
+		autoconfig(port, probeflags);
+	if (port->type != PORT_UNKNOWN && flags & UART_CONFIG_IRQ)
+		autoconfig_irq(port);
+
+	/*
+	 * If the port wasn't an RSA port, release the resource.
+	 */
+	if (port->type != PORT_RSA && res_rsa)
+		release_resource(res_rsa);
+
+	if (port->type == PORT_UNKNOWN)
+		release_resource(res_std);
+}
+
+static int
+serial8250_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	if (ser->irq >= NR_IRQS || ser->irq < 0 ||
+	    ser->baud_base < 9600 || ser->type < PORT_UNKNOWN ||
+	    ser->type > PORT_MAX_8250 || ser->type == PORT_CIRRUS ||
+	    ser->type == PORT_STARTECH)
+		return -EINVAL;
+	return 0;
+}
+
+static const char *
+serial8250_type(struct uart_port *port)
+{
+	int type = port->type;
+
+	if (type >= PORT_MAX_8250)
+		type = 0;
+	return uart_config[type].name;
+}
+
+static struct uart_ops serial8250_pops = {
+	tx_empty:	serial8250_tx_empty,
+	set_mctrl:	serial8250_set_mctrl,
+	get_mctrl:	serial8250_get_mctrl,
+	stop_tx:	serial8250_stop_tx,
+	start_tx:	serial8250_start_tx,
+	stop_rx:	serial8250_stop_rx,
+	enable_ms:	serial8250_enable_ms,
+	break_ctl:	serial8250_break_ctl,
+	startup:	serial8250_startup,
+	shutdown:	serial8250_shutdown,
+	change_speed:	serial8250_change_speed,
+	pm:		serial8250_pm,
+	type:		serial8250_type,
+	release_port:	serial8250_release_port,
+	request_port:	serial8250_request_port,
+	config_port:	serial8250_config_port,
+	verify_port:	serial8250_verify_port,
+};
+
+static struct uart_port serial8250_ports[UART_NR];
+
+static void __init serial8250_isa_init_ports(void)
+{
+	static int first = 1;
+	int i;
+
+	if (!first)
+		return;
+	first = 0;
+
+	for (i = 0; i < ARRAY_SIZE(old_serial_port); i++) {
+		serial8250_ports[i].iobase  = old_serial_port[i].port;
+		serial8250_ports[i].irq     = irq_cannonicalize(old_serial_port[i].irq);
+		serial8250_ports[i].uartclk = old_serial_port[i].base_baud * 16;
+		serial8250_ports[i].flags   = old_serial_port[i].flags;
+		serial8250_ports[i].ops     = &serial8250_pops;
+	}
+}
+
+#ifdef CONFIG_SERIAL_8250_CONSOLE
+#ifdef used_and_not_const_char_pointer
+static int serial8250_console_read(struct uart_port *port, char *s, u_int count)
+{
+}
+#endif
+
+#define BOTH_EMPTY (UART_LSR_TEMT | UART_LSR_THRE)
+
+/*
+ *	Wait for transmitter & holding register to empty
+ */
+static inline void wait_for_xmitr(struct uart_port *port)
+{
+	unsigned int status, tmout = 1000000;
+
+	do {
+		status = serial_in(port, UART_LSR);
+
+		if (status & UART_LSR_BI)
+			lsr_break_flag = UART_LSR_BI;
+
+		if (--tmout == 0)
+			break;
+	} while ((status & BOTH_EMPTY) != BOTH_EMPTY);
+
+	/* Wait for flow control if necessary */
+	if (port->flags & ASYNC_CONS_FLOW) {
+		tmout = 1000000;
+		while (--tmout &&
+		       ((serial_in(port, UART_MSR) & UART_MSR_CTS) == 0));
+	}
+}
+
+/*
+ *	Print a string to the serial port trying not to disturb
+ *	any possible real use of the port...
+ *
+ *	The console_lock must be held when we get here.
+ */
+static void serial8250_console_write(struct console *co, const char *s, u_int count)
+{
+	struct uart_port *port = serial8250_ports + co->index;
+	unsigned int ier;
+	int i;
+
+	/*
+	 *	First save the UER then disable the interrupts
+	 */
+	ier = serial_in(port, UART_IER);
+	serial_out(port, UART_IER, 0);
+
+	/*
+	 *	Now, do each character
+	 */
+	for (i = 0; i < count; i++, s++) {
+		wait_for_xmitr(port);
+
+		/*
+		 *	Send the character out.
+		 *	If a LF, also do CR...
+		 */
+		serial_out(port, UART_TX, *s);
+		if (*s == 10) {
+			wait_for_xmitr(port);
+			serial_out(port, UART_TX, 13);
+		}
+	}
+
+	/*
+	 *	Finally, wait for transmitter to become empty
+	 *	and restore the IER
+	 */
+	wait_for_xmitr(port);
+	serial_out(port, UART_IER, ier);
+}
+
+static kdev_t serial8250_console_device(struct console *co)
+{
+	return MKDEV(TTY_MAJOR, 64 + co->index);
+}
+
+static int serial8250_console_wait_key(struct console *co)
+{
+	struct uart_port *port = serial8250_ports + co->index;
+	int ier, c;
+
+	/*
+	 *	First save the IER then disable the interrupts so
+	 *	that the real driver for the port does not get the
+	 *	character.
+	 */
+	ier = serial_in(port, UART_IER);
+	serial_out(port, UART_IER, 0);
+
+	while ((serial_in(port, UART_LSR) & UART_LSR_DR) == 0);
+	c = serial_in(port, UART_RX);
+
+	/*
+	 *	Restore the interrupts
+	 */
+	serial_out(port, UART_IER, ier);
+
+	return c;
+}
+
+static int __init serial8250_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port;
+	int baud = 9600;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	/*
+	 * Check whether an invalid uart number has been specified, and
+	 * if so, search for the first available port that does have
+	 * console support.
+	 */
+	port = uart_get_console(serial8250_ports, UART_NR, co);
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+static struct console serial8250_console = {
+	name:		"ttyS",
+	write:		serial8250_console_write,
+#ifdef used_and_not_const_char_pointer
+	read:		serial8250_console_read,
+#endif
+	device:		serial8250_console_device,
+	wait_key:	serial8250_console_wait_key,
+	setup:		serial8250_console_setup,
+	flags:		CON_PRINTBUFFER,
+	index:		-1,
+};
+
+void __init serial8250_console_init(void)
+{
+	serial8250_isa_init_ports();
+	register_console(&serial8250_console);
+}
+
+#define SERIAL8250_CONSOLE	&serial8250_console
+#else
+#define SERIAL8250_CONSOLE	NULL
+#endif
+
+static struct uart_driver serial8250_reg = {
+	owner:			THIS_MODULE,
+#ifdef CONFIG_DEVFS_FS
+	normal_name:		"tts/%d",
+	callout_name:		"cua/%d",
+#else
+	normal_name:		"ttyS",
+	callout_name:		"cua",
+#endif
+	normal_major:		TTY_MAJOR,
+	callout_major:		TTYAUX_MAJOR,
+	normal_driver:		&normal,
+	callout_driver:		&callout,
+	table:			serial8250_table,
+	termios:		serial8250_termios,
+	termios_locked:		serial8250_termios_locked,
+	minor:			64,
+	nr:			ARRAY_SIZE(old_serial_port),
+	port:			serial8250_ports,
+	cons:			SERIAL8250_CONSOLE,
+};
+
+/*
+ * register_serial and unregister_serial allows for 16x50 serial ports to be
+ * configured at run-time, to support PCMCIA modems.
+ */
+ 
+/**
+ *	register_serial - configure a 16x50 serial port at runtime
+ *	@req: request structure
+ *
+ *	Configure the serial port specified by the request. If the
+ *	port exists and is in use an error is returned. If the port
+ *	is not currently in the table it is added.
+ *
+ *	The port is then probed and if neccessary the IRQ is autodetected
+ *	If this fails an error is returned.
+ *
+ *	On success the port is ready to use and the line number is returned.
+ */
+int register_serial(struct serial_struct *req)
+{
+	struct uart_port port;
+
+	port.iobase   = req->port;
+	port.membase  = req->iomem_base;
+	port.irq      = req->irq;
+	port.uartclk  = req->baud_base * 16;
+	port.fifosize = req->xmit_fifo_size;
+	port.regshift = req->iomem_reg_shift;
+	port.iotype   = req->io_type;
+	port.flags    = req->flags | ASYNC_BOOT_AUTOCONF;
+
+	if (HIGH_BITS_OFFSET)
+		port.iobase |= req->port_high << HIGH_BITS_OFFSET;
+
+	/*
+	 * If a clock rate wasn't specified by the low level
+	 * driver, then default to the standard clock rate.
+	 */
+	if (port.uartclk == 0)
+		port.uartclk = BASE_BAUD * 16;
+
+	return uart_register_port(&serial8250_reg, &port);
+}
+
+void unregister_serial(int line)
+{
+	uart_unregister_port(&serial8250_reg, line);
+}
+
+static int __init serial8250_init(void)
+{
+	serial8250_isa_init_ports();
+	return uart_register_driver(&serial8250_reg);
+}
+
+static void __exit serial8250_exit(void)
+{
+	uart_unregister_driver(&serial8250_reg);
+}
+
+module_init(serial8250_init);
+module_exit(serial8250_exit);
+
+EXPORT_SYMBOL(register_serial);
+EXPORT_SYMBOL(unregister_serial);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Generic 8250/16x50 serial driver");
+
diff -urN uClinux-dist/linux-2.4.x/drivers/serial/serial_8250.h linux-2.4.x/drivers/serial/serial_8250.h
--- uClinux-dist/linux-2.4.x/drivers/serial/serial_8250.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.4.x/drivers/serial/serial_8250.h	2004-03-25 23:16:48.000000000 +0800
@@ -0,0 +1,101 @@
+/*
+ *  linux/drivers/char/serial_8250.h
+ *
+ *  Driver for 8250/16550-type serial ports
+ *
+ *  Based on drivers/char/serial.c, by Linus Torvalds, Theodore Ts'o.
+ *
+ *  Copyright (C) 2001 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ *  $Id: serial_8250.h,v 1.1.1.1 2001/07/08 22:07:04 rmk Exp $
+ */
+
+struct serial8250_probe {
+	struct module	*owner;
+	int		(*pci_init_one)(struct pci_dev *dev);
+	void		(*pci_remove_one)(struct pci_dev *dev);
+	void		(*pnp_init)(void);
+};
+
+int serial8250_register_probe(struct serial8250_probe *probe);
+void serial8250_unregister_probe(struct serial8250_probe *probe);
+
+struct old_serial_port {
+	unsigned int uart;
+	unsigned int base_baud;
+	unsigned int port;
+	unsigned int irq;
+	unsigned int flags;
+};
+
+#undef SERIAL_PARANOIA_CHECK
+#define CONFIG_SERIAL_NOPAUSE_IO
+#define SERIAL_DO_RESTART
+
+#ifdef CONFIG_PCI
+#ifndef CONFIG_SERIAL_SHARE_IRQ
+#define CONFIG_SERIAL_SHARE_IRQ
+#endif
+#ifndef CONFIG_SERIAL_MANY_PORTS
+#define CONFIG_SERIAL_MANY_PORTS
+#endif
+#endif
+
+#if defined(CONFIG_ISAPNP)|| (defined(CONFIG_ISAPNP_MODULE) && defined(MODULE))
+#ifndef ENABLE_SERIAL_PNP
+#define ENABLE_SERIAL_PNP
+#endif
+#endif
+
+/* Set of debugging defines */
+
+#undef SERIAL_DEBUG_INTR
+#undef SERIAL_DEBUG_PCI
+#undef SERIAL_DEBUG_AUTOCONF
+
+/* Sanity checks */
+
+#ifdef CONFIG_SERIAL_MULTIPORT
+#ifndef CONFIG_SERIAL_SHARE_IRQ
+#define CONFIG_SERIAL_SHARE_IRQ
+#endif
+#endif
+
+#ifdef CONFIG_HUB6
+#ifndef CONFIG_SERIAL_MANY_PORTS
+#define CONFIG_SERIAL_MANY_PORTS
+#endif
+#ifndef CONFIG_SERIAL_SHARE_IRQ
+#define CONFIG_SERIAL_SHARE_IRQ
+#endif
+#endif
+
+#ifdef MODULE
+#undef CONFIG_SERIAL_CONSOLE
+#endif
+
+#define CONFIG_SERIAL_RSA
+
+#define RS_ISR_PASS_LIMIT 256
+
+#if defined(__i386__) && (defined(CONFIG_M386) || defined(CONFIG_M486))
+#define SERIAL_INLINE
+#endif
+  
+#ifdef SERIAL_INLINE
+#define _INLINE_ inline
+#else
+#define _INLINE_
+#endif
+
+#define PROBE_RSA	(1 << 0)
+#define PROBE_ANY	(~0)
+
+#define HIGH_BITS_OFFSET ((sizeof(long)-sizeof(int))*8)
+
+
diff -urN uClinux-dist/linux-2.4.x/drivers/serial/serial_8250_pnp.c linux-2.4.x/drivers/serial/serial_8250_pnp.c
--- uClinux-dist/linux-2.4.x/drivers/serial/serial_8250_pnp.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.4.x/drivers/serial/serial_8250_pnp.c	2004-03-25 23:16:48.000000000 +0800
@@ -0,0 +1,553 @@
+/*
+ *  linux/drivers/char/serial_8250_pnp.c
+ *
+ *  Probe module for 8250/16550-type ISAPNP serial ports.
+ *
+ *  Based on drivers/char/serial.c, by Linus Torvalds, Theodore Ts'o.
+ *
+ *  Copyright (C) 2001 Russell King, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License.
+ *
+ *  $Id: serial_8250_pnp.c,v 1.3 2001/10/02 10:13:34 rmk Exp $
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/isapnp.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/serial.h>
+#include <linux/serialP.h>
+
+#include <asm/bitops.h>
+#include <asm/byteorder.h>
+#include <asm/serial.h>
+
+#include "serial_8250.h"
+
+static struct serial_state rs_table[] = { };
+#define NR_PORTS 0
+
+struct pnpbios_device_id
+{
+	char id[8];
+	unsigned long driver_data;
+};
+
+static const struct pnpbios_device_id pnp_dev_table[] = {
+	/* Archtek America Corp. */
+	/* Archtek SmartLink Modem 3334BT Plug & Play */
+	{	"AAC000F",		0	},
+	/* Anchor Datacomm BV */
+	/* SXPro 144 External Data Fax Modem Plug & Play */
+	{	"ADC0001",		0	},
+	/* SXPro 288 External Data Fax Modem Plug & Play */
+	{	"ADC0002",		0	},
+	/* Rockwell 56K ACF II Fax+Data+Voice Modem */
+	{	"AKY1021",		SPCI_FL_NO_SHIRQ	},
+	/* AZT3005 PnP SOUND DEVICE */
+	{	"AZT4001",		0	},
+	/* Best Data Products Inc. Smart One 336F PnP Modem */
+	{	"BDP3336",		0	},
+	/*  Boca Research */
+	/* Boca Complete Ofc Communicator 14.4 Data-FAX */
+	{	"BRI0A49",		0	},
+	/* Boca Research 33,600 ACF Modem */
+	{	"BRI1400",		0	},
+	/* Boca 33.6 Kbps Internal FD34FSVD */
+	{	"BRI3400",		0	},
+	/* Boca 33.6 Kbps Internal FD34FSVD */
+	{	"BRI0A49",		0	},
+	/* Best Data Products Inc. Smart One 336F PnP Modem */
+	{	"BDP3336",		0	},
+	/* Computer Peripherals Inc */
+	/* EuroViVa CommCenter-33.6 SP PnP */
+	{	"CPI4050",		0	},
+	/* Creative Labs */
+	/* Creative Labs Phone Blaster 28.8 DSVD PnP Voice */
+	{	"CTL3001",		0	},
+	/* Creative Labs Modem Blaster 28.8 DSVD PnP Voice */
+	{	"CTL3011",		0	},
+	/* Creative */
+	/* Creative Modem Blaster Flash56 DI5601-1 */
+	{	"DMB1032",		0	},
+	/* Creative Modem Blaster V.90 DI5660 */
+	{	"DMB2001",		0	},
+	/* FUJITSU */
+	/* Fujitsu 33600 PnP-I2 R Plug & Play */
+	{	"FUJ0202",		0	},
+	/* Fujitsu FMV-FX431 Plug & Play */
+	{	"FUJ0205",		0	},
+	/* Fujitsu 33600 PnP-I4 R Plug & Play */
+	{	"FUJ0206",		0	},
+	/* Fujitsu Fax Voice 33600 PNP-I5 R Plug & Play */
+	{	"FUJ0209",		0	},
+	/* Archtek America Corp. */
+	/* Archtek SmartLink Modem 3334BT Plug & Play */
+	{	"GVC000F",		0	},
+	/* Hayes */
+	/* Hayes Optima 288 V.34-V.FC + FAX + Voice Plug & Play */
+	{	"HAY0001",		0	},
+	/* Hayes Optima 336 V.34 + FAX + Voice PnP */
+	{	"HAY000C",		0	},
+	/* Hayes Optima 336B V.34 + FAX + Voice PnP */
+	{	"HAY000D",		0	},
+	/* Hayes Accura 56K Ext Fax Modem PnP */
+	{	"HAY5670",		0	},
+	/* Hayes Accura 56K Ext Fax Modem PnP */
+	{	"HAY5674",		0	},
+	/* Hayes Accura 56K Fax Modem PnP */
+	{	"HAY5675",		0	},
+	/* Hayes 288, V.34 + FAX */
+	{	"HAYF000",		0	},
+	/* Hayes Optima 288 V.34 + FAX + Voice, Plug & Play */
+	{	"HAYF001",		0	},
+	/* IBM */
+	/* IBM Thinkpad 701 Internal Modem Voice */
+	{	"IBM0033",		0	},
+	/* Intertex */
+	/* Intertex 28k8 33k6 Voice EXT PnP */
+	{	"IXDC801",		0	},
+	/* Intertex 33k6 56k Voice EXT PnP */
+	{	"IXDC901",		0	},
+	/* Intertex 28k8 33k6 Voice SP EXT PnP */
+	{	"IXDD801",		0	},
+	/* Intertex 33k6 56k Voice SP EXT PnP */
+	{	"IXDD901",		0	},
+	/* Intertex 28k8 33k6 Voice SP INT PnP */
+	{	"IXDF401",		0	},
+	/* Intertex 28k8 33k6 Voice SP EXT PnP */
+	{	"IXDF801",		0	},
+	/* Intertex 33k6 56k Voice SP EXT PnP */
+	{	"IXDF901",		0	},
+	/* Kortex International */
+	/* KORTEX 28800 Externe PnP */
+	{	"KOR4522",		0	},
+	/* KXPro 33.6 Vocal ASVD PnP */
+	{	"KORF661",		0	},
+	/* Lasat */
+	/* LASAT Internet 33600 PnP */
+	{	"LAS4040",		0	},
+	/* Lasat Safire 560 PnP */
+	{	"LAS4540",		0	},
+	/* Lasat Safire 336  PnP */
+	{	"LAS5440",		0	},
+	/* Microcom, Inc. */
+	/* Microcom TravelPorte FAST V.34 Plug & Play */
+	{	"MNP0281",		0	},
+	/* Microcom DeskPorte V.34 FAST or FAST+ Plug & Play */
+	{	"MNP0336",		0	},
+	/* Microcom DeskPorte FAST EP 28.8 Plug & Play */
+	{	"MNP0339",		0	},
+	/* Microcom DeskPorte 28.8P Plug & Play */
+	{	"MNP0342",		0	},
+	/* Microcom DeskPorte FAST ES 28.8 Plug & Play */
+	{	"MNP0500",		0	},
+	/* Microcom DeskPorte FAST ES 28.8 Plug & Play */
+	{	"MNP0501",		0	},
+	/* Microcom DeskPorte 28.8S Internal Plug & Play */
+	{	"MNP0502",		0	},
+	/* Motorola */
+	/* Motorola BitSURFR Plug & Play */
+	{	"MOT1105",		0	},
+	/* Motorola TA210 Plug & Play */
+	{	"MOT1111",		0	},
+	/* Motorola HMTA 200 (ISDN) Plug & Play */
+	{	"MOT1114",		0	},
+	/* Motorola BitSURFR Plug & Play */
+	{	"MOT1115",		0	},
+	/* Motorola Lifestyle 28.8 Internal */
+	{	"MOT1190",		0	},
+	/* Motorola V.3400 Plug & Play */
+	{	"MOT1501",		0	},
+	/* Motorola Lifestyle 28.8 V.34 Plug & Play */
+	{	"MOT1502",		0	},
+	/* Motorola Power 28.8 V.34 Plug & Play */
+	{	"MOT1505",		0	},
+	/* Motorola ModemSURFR External 28.8 Plug & Play */
+	{	"MOT1509",		0	},
+	/* Motorola Premier 33.6 Desktop Plug & Play */
+	{	"MOT150A",		0	},
+	/* Motorola VoiceSURFR 56K External PnP */
+	{	"MOT150F",		0	},
+	/* Motorola ModemSURFR 56K External PnP */
+	{	"MOT1510",		0	},
+	/* Motorola ModemSURFR 56K Internal PnP */
+	{	"MOT1550",		0	},
+	/* Motorola ModemSURFR Internal 28.8 Plug & Play */
+	{	"MOT1560",		0	},
+	/* Motorola Premier 33.6 Internal Plug & Play */
+	{	"MOT1580",		0	},
+	/* Motorola OnlineSURFR 28.8 Internal Plug & Play */
+	{	"MOT15B0",		0	},
+	/* Motorola VoiceSURFR 56K Internal PnP */
+	{	"MOT15F0",		0	},
+	/* Com 1 */
+	/*  Deskline K56 Phone System PnP */
+	{	"MVX00A1",		0	},
+	/* PC Rider K56 Phone System PnP */
+	{	"MVX00F2",		0	},
+	/* Pace 56 Voice Internal Plug & Play Modem */
+	{	"PMC2430",		0	},
+	/* Generic */
+	/* Generic standard PC COM port	 */
+	{	"PNP0500",		0	},
+	/* Generic 16550A-compatible COM port */
+	{	"PNP0501",		0	},
+	/* Compaq 14400 Modem */
+	{	"PNPC000",		0	},
+	/* Compaq 2400/9600 Modem */
+	{	"PNPC001",		0	},
+	/* Dial-Up Networking Serial Cable between 2 PCs */
+	{	"PNPC031",		0	},
+	/* Dial-Up Networking Parallel Cable between 2 PCs */
+	{	"PNPC032",		0	},
+	/* Standard 9600 bps Modem */
+	{	"PNPC100",		0	},
+	/* Standard 14400 bps Modem */
+	{	"PNPC101",		0	},
+	/*  Standard 28800 bps Modem*/
+	{	"PNPC102",		0	},
+	/*  Standard Modem*/
+	{	"PNPC103",		0	},
+	/*  Standard 9600 bps Modem*/
+	{	"PNPC104",		0	},
+	/*  Standard 14400 bps Modem*/
+	{	"PNPC105",		0	},
+	/*  Standard 28800 bps Modem*/
+	{	"PNPC106",		0	},
+	/*  Standard Modem */
+	{	"PNPC107",		0	},
+	/* Standard 9600 bps Modem */
+	{	"PNPC108",		0	},
+	/* Standard 14400 bps Modem */
+	{	"PNPC109",		0	},
+	/* Standard 28800 bps Modem */
+	{	"PNPC10A",		0	},
+	/* Standard Modem */
+	{	"PNPC10B",		0	},
+	/* Standard 9600 bps Modem */
+	{	"PNPC10C",		0	},
+	/* Standard 14400 bps Modem */
+	{	"PNPC10D",		0	},
+	/* Standard 28800 bps Modem */
+	{	"PNPC10E",		0	},
+	/* Standard Modem */
+	{	"PNPC10F",		0	},
+	/* Standard PCMCIA Card Modem */
+	{	"PNP2000",		0	},
+	/* Rockwell */
+	/* Modular Technology */
+	/* Rockwell 33.6 DPF Internal PnP */
+	/* Modular Technology 33.6 Internal PnP */
+	{	"ROK0030",		0	},
+	/* Kortex International */
+	/* KORTEX 14400 Externe PnP */
+	{	"ROK0100",		0	},
+	/* Viking Components, Inc */
+	/* Viking 28.8 INTERNAL Fax+Data+Voice PnP */
+	{	"ROK4920",		0	},
+	/* Rockwell */
+	/* British Telecom */
+	/* Modular Technology */
+	/* Rockwell 33.6 DPF External PnP */
+	/* BT Prologue 33.6 External PnP */
+	/* Modular Technology 33.6 External PnP */
+	{	"RSS00A0",		0	},
+	/* Viking 56K FAX INT */
+	{	"RSS0262",		0	},
+	/* SupraExpress 28.8 Data/Fax PnP modem */
+	{	"SUP1310",		0	},
+	/* SupraExpress 33.6 Data/Fax PnP modem */
+	{	"SUP1421",		0	},
+	/* SupraExpress 33.6 Data/Fax PnP modem */
+	{	"SUP1590",		0	},
+	/* SupraExpress 33.6 Data/Fax PnP modem */
+	{	"SUP1760",		0	},
+	/* Phoebe Micro */
+	/* Phoebe Micro 33.6 Data Fax 1433VQH Plug & Play */
+	{	"TEX0011",		0	},
+	/* Archtek America Corp. */
+	/* Archtek SmartLink Modem 3334BT Plug & Play */
+	{	"UAC000F",		0	},
+	/* 3Com Corp. */
+	/* Gateway Telepath IIvi 33.6 */
+	{	"USR0000",		0	},
+	/*  Sportster Vi 14.4 PnP FAX Voicemail */
+	{	"USR0004",		0	},
+	/* U.S. Robotics 33.6K Voice INT PnP */
+	{	"USR0006",		0	},
+	/* U.S. Robotics 33.6K Voice EXT PnP */
+	{	"USR0007",		0	},
+	/* U.S. Robotics 33.6K Voice INT PnP */
+	{	"USR2002",		0	},
+	/* U.S. Robotics 56K Voice INT PnP */
+	{	"USR2070",		0	},
+	/* U.S. Robotics 56K Voice EXT PnP */
+	{	"USR2080",		0	},
+	/* U.S. Robotics 56K FAX INT */
+	{	"USR3031",		0	},
+	/* U.S. Robotics 56K Voice INT PnP */
+	{	"USR3070",		0	},
+	/* U.S. Robotics 56K Voice EXT PnP */
+	{	"USR3080",		0	},
+	/* U.S. Robotics 56K Voice INT PnP */
+	{	"USR3090",		0	},
+	/* U.S. Robotics 56K Message  */
+	{	"USR9100",		0	},
+	/* U.S. Robotics 56K FAX EXT PnP*/
+	{	"USR9160",		0	},
+	/* U.S. Robotics 56K FAX INT PnP*/
+	{	"USR9170",		0	},
+	/* U.S. Robotics 56K Voice EXT PnP*/
+	{	"USR9180",		0	},
+	/* U.S. Robotics 56K Voice INT PnP*/
+	{	"USR9190",		0	},
+	{	"",			0	}
+};
+
+static void inline avoid_irq_share(struct pci_dev *dev)
+{
+	int i, map = 0x1FF8;
+	struct serial_state *state = rs_table;
+	struct isapnp_irq *irq;
+	struct isapnp_resources *res = dev->sysdata;
+
+	for (i = 0; i < NR_PORTS; i++) {
+		if (state->type != PORT_UNKNOWN)
+			clear_bit(state->irq, &map);
+		state++;
+	}
+
+	for ( ; res; res = res->alt)
+		for(irq = res->irq; irq; irq = irq->next)
+			irq->map = map;
+}
+
+static char *modem_names[] __devinitdata = {
+	"MODEM", "Modem", "modem", "FAX", "Fax", "fax",
+	"56K", "56k", "K56", "33.6", "28.8", "14.4",
+	"33,600", "28,800", "14,400", "33.600", "28.800", "14.400",
+	"33600", "28800", "14400", "V.90", "V.34", "V.32", 0
+};
+
+static int __devinit check_name(char *name)
+{
+	char **tmp;
+
+	for (tmp = modem_names; *tmp; tmp++)
+		if (strstr(name, *tmp))
+			return 1;
+
+	return 0;
+}
+
+static int inline check_compatible_id(struct pci_dev *dev)
+{
+	int i;
+	for (i = 0; i < DEVICE_COUNT_COMPATIBLE; i++)
+		if ((dev->vendor_compatible[i] ==
+		     ISAPNP_VENDOR('P', 'N', 'P')) &&
+		    (swab16(dev->device_compatible[i]) >= 0xc000) &&
+		    (swab16(dev->device_compatible[i]) <= 0xdfff))
+			return 0;
+	return 1;
+}
+
+/*
+ * Given a complete unknown ISA PnP device, try to use some heuristics to
+ * detect modems. Currently use such heuristic set:
+ *     - dev->name or dev->bus->name must contain "modem" substring;
+ *     - device must have only one IO region (8 byte long) with base adress
+ *       0x2e8, 0x3e8, 0x2f8 or 0x3f8.
+ *
+ * Such detection looks very ugly, but can detect at least some of numerous
+ * ISA PnP modems, alternatively we must hardcode all modems in pnp_devices[]
+ * table.
+ */
+static int serial_pnp_guess_board(struct pci_dev *dev, int *flags)
+{
+	struct isapnp_resources *res = (struct isapnp_resources *)dev->sysdata;
+	struct isapnp_resources *resa;
+
+	if (!(check_name(dev->name) || check_name(dev->bus->name)) &&
+	    !(check_compatible_id(dev)))
+		return -ENODEV;
+
+	if (!res || res->next)
+		return -ENODEV;
+
+	for (resa = res->alt; resa; resa = resa->alt) {
+		struct isapnp_port *port;
+		for (port = res->port; port; port = port->next)
+			if ((port->size == 8) &&
+			    ((port->min == 0x2f8) ||
+			     (port->min == 0x3f8) ||
+			     (port->min == 0x2e8) ||
+			     (port->min == 0x3e8)))
+				return 0;
+	}
+
+	return -ENODEV;
+}
+
+static int
+pnp_init_one(struct pci_dev *dev, const struct pnpbios_device_id *ent,
+	     char *slot_name)
+{
+	struct serial_struct serial_req;
+	int ret, line, flags = ent ? ent->driver_data : 0;
+
+	if (!ent) {
+		ret = serial_pnp_guess_board(dev, &flags);
+		if (ret)
+			return ret;
+	}
+
+	if (dev->prepare(dev) < 0) {
+		printk("serial: PNP device '%s' prepare failed\n",
+			slot_name);
+		return -ENODEV;
+	}
+
+	if (dev->active)
+		return -ENODEV;
+
+	if (flags & SPCI_FL_NO_SHIRQ)
+		avoid_irq_share(dev);
+
+	if (dev->activate(dev) < 0) {
+		printk("serial: PNP device '%s' activate failed\n",
+			slot_name);
+		return -ENODEV;
+	}
+
+	memset(&serial_req, 0, sizeof(serial_req));
+	serial_req.irq = dev->irq_resource[0].start;
+	serial_req.port = pci_resource_start(dev, 0);
+	if (HIGH_BITS_OFFSET)
+		serial_req.port = pci_resource_start(dev, 0) >> HIGH_BITS_OFFSET;
+
+#ifdef SERIAL_DEBUG_PCI
+	printk("Setup PCI/PNP port: port %x, irq %d, type %d\n",
+	       serial_req.port, serial_req.irq, serial_req.io_type);
+#endif
+
+	serial_req.flags = ASYNC_SKIP_TEST | ASYNC_AUTOPROBE;
+	serial_req.baud_base = 115200;
+	line = register_serial(&serial_req);
+
+	if (line >= 0) {
+		pci_set_drvdata(dev, (void *)(line + 1));
+
+		/*
+		 * Public health warning: remove this once the 2.5
+		 * pnpbios_module_init() stuff is incorporated.
+		 */
+		dev->driver = (void *)pnp_dev_table;
+	} else
+		dev->deactivate(dev);
+
+	return line >= 0 ? 0 : -ENODEV;
+}
+
+static void pnp_remove_one(struct pci_dev *dev)
+{
+	int line = (int)pci_get_drvdata(dev);
+
+	if (line) {
+		pci_set_drvdata(dev, NULL);
+
+		unregister_serial(line - 1);
+
+		dev->deactivate(dev);
+	}
+}
+
+static char hex[] = "0123456789ABCDEF";
+
+/*
+ * This function should vanish when 2.5 comes around and
+ * we have pnpbios_module_init()
+ */
+static void pnp_init(void)
+{
+	const struct pnpbios_device_id *id;
+	struct pci_dev *dev = NULL;
+
+#ifdef SERIAL_DEBUG_PNP
+	printk("Entered probe_serial_pnp()\n");
+#endif
+
+	isapnp_for_each_dev(dev) {
+		char slot_name[8];
+		u32 pnpid;
+
+		if (dev->active)
+			continue;
+
+		pnpid = dev->vendor << 16 | dev->device;
+		pnpid = cpu_to_le32(pnpid);
+
+#define HEX(id,a) hex[((id)>>a) & 15]
+#define CHAR(id,a) (0x40 + (((id)>>a) & 31))
+		slot_name[0] = CHAR(pnpid, 26);
+		slot_name[1] = CHAR(pnpid, 21);
+		slot_name[2] = CHAR(pnpid, 16);
+		slot_name[3] = HEX(pnpid, 12);
+		slot_name[4] = HEX(pnpid, 8);
+		slot_name[5] = HEX(pnpid, 4);
+		slot_name[6] = HEX(pnpid, 0);
+		slot_name[7] = '\0';
+		
+		for (id = pnp_dev_table; id->id[0]; id++)
+			if (memcmp(id->id, slot_name, 7) == 0)
+				break;
+
+		if (id->id[0])
+			pnp_init_one(dev, id, slot_name);
+		else
+			pnp_init_one(dev, NULL, slot_name);
+	}
+
+#ifdef SERIAL_DEBUG_PNP
+	printk("Leaving probe_serial_pnp() (probe finished)\n");
+#endif
+}
+
+static int __init serial8250_pnp_init(void)
+{
+	if (!isapnp_present()) {
+#ifdef SERIAL_DEBUG_PNP
+		printk("Leaving probe_serial_pnp() (no isapnp)\n");
+#endif
+		return -ENODEV;
+	}
+	pnp_init();
+	return 0;
+}
+
+static void __exit serial8250_pnp_exit(void)
+{
+	struct pci_dev *dev = NULL;
+
+	isapnp_for_each_dev(dev) {
+		if (dev->driver != (void *)pnp_dev_table)
+			continue;
+		pnp_remove_one(dev);
+	}
+}
+
+module_init(serial8250_pnp_init);
+module_exit(serial8250_pnp_exit);
+
+EXPORT_NO_SYMBOLS;
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Generic 8250/16x50 PNPBIOS serial probe module");
+MODULE_GENERIC_TABLE(pnp, pnp_dev_table);
+
diff -urN uClinux-dist/linux-2.4.x/drivers/serial/serial_amba.c linux-2.4.x/drivers/serial/serial_amba.c
--- uClinux-dist/linux-2.4.x/drivers/serial/serial_amba.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.4.x/drivers/serial/serial_amba.c	2004-03-25 23:16:48.000000000 +0800
@@ -0,0 +1,796 @@
+/*
+ *  linux/drivers/char/serial_amba.c
+ *
+ *  Driver for AMBA serial ports
+ *
+ *  Based on drivers/char/serial.c, by Linus Torvalds, Theodore Ts'o.
+ *
+ *  Copyright 1999 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *  $Id: serial_amba.c,v 1.9.2.1 2001/11/27 17:35:39 rmk Exp $
+ *
+ * This is a generic driver for ARM AMBA-type serial ports.  They
+ * have a lot of 16550-like features, but are not register compatable.
+ * Note that although they do have CTS, DCD and DSR inputs, they do
+ * not have an RI input, nor do they have DTR or RTS outputs.  If
+ * required, these have to be supplied via some other means (eg, GPIO)
+ * and hooked into this driver.
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/major.h>
+#include <linux/string.h>
+#include <linux/fcntl.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/circ_buf.h>
+#include <linux/serial.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <asm/bitops.h>
+
+#if defined(CONFIG_SERIAL_AMBA_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
+#include <linux/serial_core.h>
+
+#include <asm/hardware/serial_amba.h>
+
+#define UART_NR		2
+
+#define SERIAL_AMBA_MAJOR	204
+#define SERIAL_AMBA_MINOR	16
+#define SERIAL_AMBA_NR		UART_NR
+
+#define CALLOUT_AMBA_NAME	"cuaam"
+#define CALLOUT_AMBA_MAJOR	205
+#define CALLOUT_AMBA_MINOR	16
+#define CALLOUT_AMBA_NR		UART_NR
+
+static struct tty_driver normal, callout;
+static struct tty_struct *amba_table[UART_NR];
+static struct termios *amba_termios[UART_NR], *amba_termios_locked[UART_NR];
+#ifdef SUPPORT_SYSRQ
+static struct console amba_console;
+#endif
+
+#define AMBA_ISR_PASS_LIMIT	256
+
+/*
+ * Access macros for the AMBA UARTs
+ */
+#define UART_GET_INT_STATUS(p)	readb((p)->membase + AMBA_UARTIIR)
+#define UART_PUT_ICR(p, c)	writel((c), (p)->membase + AMBA_UARTICR)
+#define UART_GET_FR(p)		readb((p)->membase + AMBA_UARTFR)
+#define UART_GET_CHAR(p)	readb((p)->membase + AMBA_UARTDR)
+#define UART_PUT_CHAR(p, c)	writel((c), (p)->membase + AMBA_UARTDR)
+#define UART_GET_RSR(p)		readb((p)->membase + AMBA_UARTRSR)
+#define UART_GET_CR(p)		readb((p)->membase + AMBA_UARTCR)
+#define UART_PUT_CR(p,c)	writel((c), (p)->membase + AMBA_UARTCR)
+#define UART_GET_LCRL(p)	readb((p)->membase + AMBA_UARTLCR_L)
+#define UART_PUT_LCRL(p,c)	writel((c), (p)->membase + AMBA_UARTLCR_L)
+#define UART_GET_LCRM(p)	readb((p)->membase + AMBA_UARTLCR_M)
+#define UART_PUT_LCRM(p,c)	writel((c), (p)->membase + AMBA_UARTLCR_M)
+#define UART_GET_LCRH(p)	readb((p)->membase + AMBA_UARTLCR_H)
+#define UART_PUT_LCRH(p,c)	writel((c), (p)->membase + AMBA_UARTLCR_H)
+#define UART_RX_DATA(s)		(((s) & AMBA_UARTFR_RXFE) == 0)
+#define UART_TX_READY(s)	(((s) & AMBA_UARTFR_TXFF) == 0)
+#define UART_TX_EMPTY(p)	((UART_GET_FR(p) & AMBA_UARTFR_TMSK) == 0)
+
+#define UART_DUMMY_RSR_RX	256
+#define UART_PORT_SIZE		64
+
+/*
+ * On the Integrator platform, the port RTS and DTR are provided by
+ * bits in the following SC_CTRLS register bits:
+ *        RTS  DTR
+ *  UART0  7    6
+ *  UART1  5    4
+ *
+ * We encode this bit information into port->driver_priv using the
+ * following macros.
+ */
+//#define PORT_CTRLS(dtrbit,rtsbit)	((1 << dtrbit) | (1 << (16 + rtsbit)))
+#define PORT_CTRLS_DTR(port)		(1 << (port)->unused[1])
+#define PORT_CTRLS_RTS(port)		(1 << (port)->unused[0])
+
+#define SC_CTRLC	(IO_ADDRESS(INTEGRATOR_SC_BASE) + INTEGRATOR_SC_CTRLC_OFFSET)
+#define SC_CTRLS	(IO_ADDRESS(INTEGRATOR_SC_BASE) + INTEGRATOR_SC_CTRLS_OFFSET)
+
+/*
+ * Our private driver data mappings.
+ */
+#define drv_old_status	driver_priv
+
+static void ambauart_stop_tx(struct uart_port *port, u_int from_tty)
+{
+	unsigned int cr;
+
+	cr = UART_GET_CR(port);
+	cr &= ~AMBA_UARTCR_TIE;
+	UART_PUT_CR(port, cr);
+}
+
+static void ambauart_start_tx(struct uart_port *port, u_int nonempty, u_int from_tty)
+{
+	if (nonempty) {
+		unsigned int cr;
+
+		cr = UART_GET_CR(port);
+		cr |= AMBA_UARTCR_TIE;
+		UART_PUT_CR(port, cr);
+	}
+}
+
+static void ambauart_stop_rx(struct uart_port *port)
+{
+	unsigned int cr;
+
+	cr = UART_GET_CR(port);
+	cr &= ~(AMBA_UARTCR_RIE | AMBA_UARTCR_RTIE);
+	UART_PUT_CR(port, cr);
+}
+
+static void ambauart_enable_ms(struct uart_port *port)
+{
+	unsigned int cr;
+
+	cr = UART_GET_CR(port);
+	cr |= AMBA_UARTCR_MSIE;
+	UART_PUT_CR(port, cr);
+}
+
+static void
+#ifdef SUPPORT_SYSRQ
+ambauart_rx_chars(struct uart_info *info, struct pt_regs *regs)
+#else
+ambauart_rx_chars(struct uart_info *info)
+#endif
+{
+	struct tty_struct *tty = info->tty;
+	unsigned int status, ch, rsr, max_count = 256;
+	struct uart_port *port = info->port;
+
+	status = UART_GET_FR(port);
+	while (UART_RX_DATA(status) && max_count--) {
+		if (tty->flip.count >= TTY_FLIPBUF_SIZE) {
+			tty->flip.tqueue.routine((void *)tty);
+			if (tty->flip.count >= TTY_FLIPBUF_SIZE) {
+				printk(KERN_WARNING "TTY_DONT_FLIP set\n");
+				return;
+			}
+		}
+
+		ch = UART_GET_CHAR(port);
+
+		*tty->flip.char_buf_ptr = ch;
+		*tty->flip.flag_buf_ptr = TTY_NORMAL;
+		port->icount.rx++;
+
+		/*
+		 * Note that the error handling code is
+		 * out of the main execution path
+		 */
+		rsr = UART_GET_RSR(port) | UART_DUMMY_RSR_RX;
+		if (rsr & AMBA_UARTRSR_ANY) {
+			if (rsr & AMBA_UARTRSR_BE) {
+				rsr &= ~(AMBA_UARTRSR_FE | AMBA_UARTRSR_PE);
+				port->icount.brk++;
+				if (uart_handle_break(info, &amba_console))
+					goto ignore_char;
+			} else if (rsr & AMBA_UARTRSR_PE)
+				port->icount.parity++;
+			else if (rsr & AMBA_UARTRSR_FE)
+				port->icount.frame++;
+			if (rsr & AMBA_UARTRSR_OE)
+				port->icount.overrun++;
+
+			rsr &= port->read_status_mask;
+
+			if (rsr & AMBA_UARTRSR_BE)
+				*tty->flip.flag_buf_ptr = TTY_BREAK;
+			else if (rsr & AMBA_UARTRSR_PE)
+				*tty->flip.flag_buf_ptr = TTY_PARITY;
+			else if (rsr & AMBA_UARTRSR_FE)
+				*tty->flip.flag_buf_ptr = TTY_FRAME;
+		}
+
+		if (uart_handle_sysrq_char(info, ch, regs))
+			goto ignore_char;
+
+		if ((rsr & port->ignore_status_mask) == 0) {
+			tty->flip.flag_buf_ptr++;
+			tty->flip.char_buf_ptr++;
+			tty->flip.count++;
+		}
+		if ((rsr & AMBA_UARTRSR_OE) &&
+		    tty->flip.count < TTY_FLIPBUF_SIZE) {
+			/*
+			 * Overrun is special, since it's reported
+			 * immediately, and doesn't affect the current
+			 * character
+			 */
+			*tty->flip.char_buf_ptr++ = 0;
+			*tty->flip.flag_buf_ptr++ = TTY_OVERRUN;
+			tty->flip.count++;
+		}
+	ignore_char:
+		status = UART_GET_FR(port);
+	}
+	tty_flip_buffer_push(tty);
+	return;
+}
+
+static void ambauart_tx_chars(struct uart_info *info)
+{
+	struct uart_port *port = info->port;
+	int count;
+
+	if (port->x_char) {
+		UART_PUT_CHAR(port, port->x_char);
+		port->icount.tx++;
+		port->x_char = 0;
+		return;
+	}
+	if (info->xmit.head == info->xmit.tail
+	    || info->tty->stopped
+	    || info->tty->hw_stopped) {
+		ambauart_stop_tx(port, 0);
+		return;
+	}
+
+	count = port->fifosize >> 1;
+	do {
+		UART_PUT_CHAR(port, info->xmit.buf[info->xmit.tail]);
+		info->xmit.tail = (info->xmit.tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+		if (info->xmit.head == info->xmit.tail)
+			break;
+	} while (--count > 0);
+
+	if (CIRC_CNT(info->xmit.head, info->xmit.tail, UART_XMIT_SIZE) <
+			WAKEUP_CHARS)
+		uart_event(info, EVT_WRITE_WAKEUP);
+
+	if (info->xmit.head == info->xmit.tail)
+		ambauart_stop_tx(info->port, 0);
+}
+
+static void ambauart_modem_status(struct uart_info *info)
+{
+	struct uart_port *port = info->port;
+	unsigned int status, delta;
+
+	UART_PUT_ICR(port, 0);
+
+	status = UART_GET_FR(port) & AMBA_UARTFR_MODEM_ANY;
+
+	delta = status ^ info->drv_old_status;
+	info->drv_old_status = status;
+
+	if (!delta)
+		return;
+
+	if (delta & AMBA_UARTFR_DCD)
+		uart_handle_dcd_change(info, status & AMBA_UARTFR_DCD);
+
+	if (delta & AMBA_UARTFR_DSR)
+		port->icount.dsr++;
+
+	if (delta & AMBA_UARTFR_CTS)
+		uart_handle_cts_change(info, status & AMBA_UARTFR_CTS);
+
+	wake_up_interruptible(&info->delta_msr_wait);
+}
+
+static void ambauart_int(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct uart_info *info = dev_id;
+	unsigned int status, pass_counter = AMBA_ISR_PASS_LIMIT;
+
+	status = UART_GET_INT_STATUS(info->port);
+	do {
+		if (status & (AMBA_UARTIIR_RTIS | AMBA_UARTIIR_RIS))
+#ifdef SUPPORT_SYSRQ
+			ambauart_rx_chars(info, regs);
+#else
+			ambauart_rx_chars(info);
+#endif
+		if (status & AMBA_UARTIIR_TIS)
+			ambauart_tx_chars(info);
+		if (status & AMBA_UARTIIR_MIS)
+			ambauart_modem_status(info);
+
+		if (pass_counter-- == 0)
+			break;
+
+		status = UART_GET_INT_STATUS(info->port);
+	} while (status & (AMBA_UARTIIR_RTIS | AMBA_UARTIIR_RIS |
+			   AMBA_UARTIIR_TIS));
+}
+
+static u_int ambauart_tx_empty(struct uart_port *port)
+{
+	return UART_GET_FR(port) & AMBA_UARTFR_BUSY ? 0 : TIOCSER_TEMT;
+}
+
+static u_int ambauart_get_mctrl(struct uart_port *port)
+{
+	unsigned int result = 0;
+	unsigned int status;
+
+	status = UART_GET_FR(port);
+	if (status & AMBA_UARTFR_DCD)
+		result |= TIOCM_CAR;
+	if (status & AMBA_UARTFR_DSR)
+		result |= TIOCM_DSR;
+	if (status & AMBA_UARTFR_CTS)
+		result |= TIOCM_CTS;
+
+	return result;
+}
+
+static void ambauart_set_mctrl(struct uart_port *port, u_int mctrl)
+{
+	u_int ctrls = 0, ctrlc = 0;
+
+	if (mctrl & TIOCM_RTS)
+		ctrlc |= PORT_CTRLS_RTS(port);
+	else
+		ctrls |= PORT_CTRLS_RTS(port);
+
+	if (mctrl & TIOCM_DTR)
+		ctrlc |= PORT_CTRLS_DTR(port);
+	else
+		ctrls |= PORT_CTRLS_DTR(port);
+
+	__raw_writel(ctrls, SC_CTRLS);
+	__raw_writel(ctrlc, SC_CTRLC);
+}
+
+static void ambauart_break_ctl(struct uart_port *port, int break_state)
+{
+	unsigned int lcr_h;
+
+	lcr_h = UART_GET_LCRH(port);
+	if (break_state == -1)
+		lcr_h |= AMBA_UARTLCR_H_BRK;
+	else
+		lcr_h &= ~AMBA_UARTLCR_H_BRK;
+	UART_PUT_LCRH(port, lcr_h);
+}
+
+static int ambauart_startup(struct uart_port *port, struct uart_info *info)
+{
+	int retval;
+
+	/*
+	 * Allocate the IRQ
+	 */
+	retval = request_irq(port->irq, ambauart_int, 0, "amba", info);
+	if (retval)
+		return retval;
+
+	/*
+	 * initialise the old status of the modem signals
+	 */
+	info->drv_old_status = UART_GET_FR(port) & AMBA_UARTFR_MODEM_ANY;
+
+	/*
+	 * Finally, enable interrupts
+	 */
+	UART_PUT_CR(port, AMBA_UARTCR_UARTEN | AMBA_UARTCR_RIE |
+			  AMBA_UARTCR_RTIE);
+
+	return 0;
+}
+
+static void ambauart_shutdown(struct uart_port *port, struct uart_info *info)
+{
+	/*
+	 * Free the interrupt
+	 */
+	free_irq(port->irq, info);
+
+	/*
+	 * disable all interrupts, disable the port
+	 */
+	UART_PUT_CR(port, 0);
+
+	/* disable break condition and fifos */
+	UART_PUT_LCRH(port, UART_GET_LCRH(port) &
+		~(AMBA_UARTLCR_H_BRK | AMBA_UARTLCR_H_FEN));
+}
+
+static void ambauart_change_speed(struct uart_port *port, u_int cflag, u_int iflag, u_int quot)
+{
+	u_int lcr_h, old_cr;
+	unsigned long flags;
+
+#if DEBUG
+	printk("ambauart_set_cflag(0x%x) called\n", cflag);
+#endif
+	/* byte size and parity */
+	switch (cflag & CSIZE) {
+	case CS5: lcr_h = AMBA_UARTLCR_H_WLEN_5; break;
+	case CS6: lcr_h = AMBA_UARTLCR_H_WLEN_6; break;
+	case CS7: lcr_h = AMBA_UARTLCR_H_WLEN_7; break;
+	default:  lcr_h = AMBA_UARTLCR_H_WLEN_8; break; // CS8
+	}
+	if (cflag & CSTOPB)
+		lcr_h |= AMBA_UARTLCR_H_STP2;
+	if (cflag & PARENB) {
+		lcr_h |= AMBA_UARTLCR_H_PEN;
+		if (!(cflag & PARODD))
+			lcr_h |= AMBA_UARTLCR_H_EPS;
+	}
+	if (port->fifosize > 1)
+		lcr_h |= AMBA_UARTLCR_H_FEN;
+
+	port->read_status_mask = AMBA_UARTRSR_OE;
+	if (iflag & INPCK)
+		port->read_status_mask |= AMBA_UARTRSR_FE | AMBA_UARTRSR_PE;
+	if (iflag & (BRKINT | PARMRK))
+		port->read_status_mask |= AMBA_UARTRSR_BE;
+
+	/*
+	 * Characters to ignore
+	 */
+	port->ignore_status_mask = 0;
+	if (iflag & IGNPAR)
+		port->ignore_status_mask |= AMBA_UARTRSR_FE | AMBA_UARTRSR_PE;
+	if (iflag & IGNBRK) {
+		port->ignore_status_mask |= AMBA_UARTRSR_BE;
+		/*
+		 * If we're ignoring parity and break indicators,
+		 * ignore overruns too (for real raw support).
+		 */
+		if (iflag & IGNPAR)
+			port->ignore_status_mask |= AMBA_UARTRSR_OE;
+	}
+
+	/*
+	 * Ignore all characters if CREAD is not set.
+	 */
+	if ((cflag & CREAD) == 0)
+		port->ignore_status_mask |= UART_DUMMY_RSR_RX;
+
+	/* first, disable everything */
+	save_flags(flags); cli();
+	old_cr = UART_GET_CR(port) & ~AMBA_UARTCR_MSIE;
+
+	if ((port->flags & ASYNC_HARDPPS_CD) ||
+	    (cflag & CRTSCTS) || !(cflag & CLOCAL))
+		old_cr |= AMBA_UARTCR_MSIE;
+
+	UART_PUT_CR(port, 0);
+
+	/* Set baud rate */
+	quot -= 1;
+	UART_PUT_LCRM(port, ((quot & 0xf00) >> 8));
+	UART_PUT_LCRL(port, (quot & 0xff));
+
+	/*
+	 * ----------v----------v----------v----------v-----
+	 * NOTE: MUST BE WRITTEN AFTER UARTLCR_M & UARTLCR_L
+	 * ----------^----------^----------^----------^-----
+	 */
+	UART_PUT_LCRH(port, lcr_h);
+	UART_PUT_CR(port, old_cr);
+
+	restore_flags(flags);
+}
+
+static const char *ambauart_type(struct uart_port *port)
+{
+	return port->type == PORT_AMBA ? "AMBA" : NULL;
+}
+
+/*
+ * Release the memory region(s) being used by 'port'
+ */
+static void ambauart_release_port(struct uart_port *port)
+{
+	release_mem_region(port->mapbase, UART_PORT_SIZE);
+}
+
+/*
+ * Request the memory region(s) being used by 'port'
+ */
+static int ambauart_request_port(struct uart_port *port)
+{
+	return request_mem_region(port->mapbase, UART_PORT_SIZE, "serial_amba")
+			!= NULL ? 0 : -EBUSY;
+}
+
+/*
+ * Configure/autoconfigure the port.
+ */
+static void ambauart_config_port(struct uart_port *port, int flags)
+{
+	if (flags & UART_CONFIG_TYPE) {
+		port->type = PORT_AMBA;
+		ambauart_request_port(port);
+	}
+}
+
+/*
+ * verify the new serial_struct (for TIOCSSERIAL).
+ */
+static int ambauart_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	int ret = 0;
+	if (ser->type != PORT_UNKNOWN && ser->type != PORT_AMBA)
+		ret = -EINVAL;
+	if (ser->irq < 0 || ser->irq >= NR_IRQS)
+		ret = -EINVAL;
+	if (ser->baud_base < 9600)
+		ret = -EINVAL;
+	return ret;
+}
+
+static struct uart_ops amba_pops = {
+	tx_empty:	ambauart_tx_empty,
+	set_mctrl:	ambauart_set_mctrl,
+	get_mctrl:	ambauart_get_mctrl,
+	stop_tx:	ambauart_stop_tx,
+	start_tx:	ambauart_start_tx,
+	stop_rx:	ambauart_stop_rx,
+	enable_ms:	ambauart_enable_ms,
+	break_ctl:	ambauart_break_ctl,
+	startup:	ambauart_startup,
+	shutdown:	ambauart_shutdown,
+	change_speed:	ambauart_change_speed,
+	type:		ambauart_type,
+	release_port:	ambauart_release_port,
+	request_port:	ambauart_request_port,
+	config_port:	ambauart_config_port,
+	verify_port:	ambauart_verify_port,
+};
+
+static struct uart_port amba_ports[UART_NR] = {
+	{
+		membase:	(void *)IO_ADDRESS(INTEGRATOR_UART0_BASE),
+		mapbase:	INTEGRATOR_UART0_BASE,
+		iotype:		SERIAL_IO_MEM,
+		irq:		IRQ_UARTINT0,
+		uartclk:	14745600,
+		fifosize:	16,
+		unused:		{ 4, 5 }, /*driver_priv:	PORT_CTRLS(5, 4), */
+		ops:		&amba_pops,
+		flags:		ASYNC_BOOT_AUTOCONF,
+	},
+	{
+		membase:	(void *)IO_ADDRESS(INTEGRATOR_UART1_BASE),
+		mapbase:	INTEGRATOR_UART1_BASE,
+		iotype:		SERIAL_IO_MEM,
+		irq:		IRQ_UARTINT1,
+		uartclk:	14745600,
+		fifosize:	16,
+		unused:		{ 6, 7 }, /*driver_priv:	PORT_CTRLS(7, 6), */
+		ops:		&amba_pops,
+		flags:		ASYNC_BOOT_AUTOCONF,
+	}
+};
+
+#ifdef CONFIG_SERIAL_AMBA_CONSOLE
+#ifdef used_and_not_const_char_pointer
+static int ambauart_console_read(struct uart_port *port, char *s, u_int count)
+{
+	unsigned int status;
+	int c;
+#if DEBUG
+	printk("ambauart_console_read() called\n");
+#endif
+
+	c = 0;
+	while (c < count) {
+		status = UART_GET_FR(port);
+		if (UART_RX_DATA(status)) {
+			*s++ = UART_GET_CHAR(port);
+			c++;
+		} else {
+			// nothing more to get, return
+			return c;
+		}
+	}
+	// return the count
+	return c;
+}
+#endif
+
+static void ambauart_console_write(struct console *co, const char *s, u_int count)
+{
+	struct uart_port *port = amba_ports + co->index;
+	unsigned int status, old_cr;
+	int i;
+
+	/*
+	 *	First save the CR then disable the interrupts
+	 */
+	old_cr = UART_GET_CR(port);
+	UART_PUT_CR(port, AMBA_UARTCR_UARTEN);
+
+	/*
+	 *	Now, do each character
+	 */
+	for (i = 0; i < count; i++) {
+		do {
+			status = UART_GET_FR(port);
+		} while (!UART_TX_READY(status));
+		UART_PUT_CHAR(port, s[i]);
+		if (s[i] == '\n') {
+			do {
+				status = UART_GET_FR(port);
+			} while (!UART_TX_READY(status));
+			UART_PUT_CHAR(port, '\r');
+		}
+	}
+
+	/*
+	 *	Finally, wait for transmitter to become empty
+	 *	and restore the TCR
+	 */
+	do {
+		status = UART_GET_FR(port);
+	} while (status & AMBA_UARTFR_BUSY);
+	UART_PUT_CR(port, old_cr);
+}
+
+static kdev_t ambauart_console_device(struct console *co)
+{
+	return MKDEV(SERIAL_AMBA_MAJOR, SERIAL_AMBA_MINOR + co->index);
+}
+
+static int ambauart_console_wait_key(struct console *co)
+{
+	struct uart_port *port = amba_ports + co->index;
+	unsigned int status;
+
+	do {
+		status = UART_GET_FR(port);
+	} while (!UART_RX_DATA(status));
+	return UART_GET_CHAR(port);
+}
+
+static void __init
+ambauart_console_get_options(struct uart_port *port, int *baud, int *parity, int *bits)
+{
+	if (UART_GET_CR(port) & AMBA_UARTCR_UARTEN) {
+		u_int lcr_h, quot;
+		lcr_h = UART_GET_LCRH(port);
+
+		*parity = 'n';
+		if (lcr_h & AMBA_UARTLCR_H_PEN) {
+			if (lcr_h & AMBA_UARTLCR_H_EPS)
+				*parity = 'e';
+			else
+				*parity = 'o';
+		}
+
+		if ((lcr_h & 0x60) == AMBA_UARTLCR_H_WLEN_7)
+			*bits = 7;
+		else
+			*bits = 8;
+
+		quot = UART_GET_LCRL(port) | UART_GET_LCRM(port) << 8;
+		*baud = port->uartclk / (16 * (quot + 1));
+	}
+}
+
+static int __init ambauart_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port;
+	int baud = 38400;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	/*
+	 * Check whether an invalid uart number has been specified, and
+	 * if so, search for the first available port that does have
+	 * console support.
+	 */
+	port = uart_get_console(amba_ports, UART_NR, co);
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+	else
+		ambauart_console_get_options(port, &baud, &parity, &bits);
+
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+static struct console amba_console = {
+	name:		"ttyAM",
+	write:		ambauart_console_write,
+#ifdef used_and_not_const_char_pointer
+	read:		ambauart_console_read,
+#endif
+	device:		ambauart_console_device,
+	wait_key:	ambauart_console_wait_key,
+	setup:		ambauart_console_setup,
+	flags:		CON_PRINTBUFFER,
+	index:		-1,
+};
+
+void __init ambauart_console_init(void)
+{
+	register_console(&amba_console);
+}
+
+#define AMBA_CONSOLE	&amba_console
+#else
+#define AMBA_CONSOLE	NULL
+#endif
+
+static struct uart_driver amba_reg = {
+	owner:			THIS_MODULE,
+	normal_major:		SERIAL_AMBA_MAJOR,
+#ifdef CONFIG_DEVFS_FS
+	normal_name:		"ttyAM%d",
+	callout_name:		"cuaam%d",
+#else
+	normal_name:		"ttyAM",
+	callout_name:		"cuaam",
+#endif
+	normal_driver:		&normal,
+	callout_major:		CALLOUT_AMBA_MAJOR,
+	callout_driver:		&callout,
+	table:			amba_table,
+	termios:		amba_termios,
+	termios_locked:		amba_termios_locked,
+	minor:			SERIAL_AMBA_MINOR,
+	nr:			UART_NR,
+	port:			amba_ports,
+	cons:			AMBA_CONSOLE,
+};
+
+static int __init ambauart_init(void)
+{
+	return uart_register_driver(&amba_reg);
+}
+
+static void __exit ambauart_exit(void)
+{
+	uart_unregister_driver(&amba_reg);
+}
+
+module_init(ambauart_init);
+module_exit(ambauart_exit);
+
+EXPORT_NO_SYMBOLS;
+
+MODULE_AUTHOR("ARM Ltd/Deep Blue Solutions Ltd");
+MODULE_DESCRIPTION("ARM AMBA serial port driver");
+MODULE_LICENSE("GPL");
diff -urN uClinux-dist/linux-2.4.x/drivers/serial/serial_anakin.c linux-2.4.x/drivers/serial/serial_anakin.c
--- uClinux-dist/linux-2.4.x/drivers/serial/serial_anakin.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.4.x/drivers/serial/serial_anakin.c	2004-03-25 23:16:48.000000000 +0800
@@ -0,0 +1,568 @@
+/*
+ *  linux/drivers/char/serial_anakin.c
+ *
+ *  Based on driver for AMBA serial ports, by ARM Limited,
+ *  Deep Blue Solutions Ltd., Linus Torvalds and Theodore Ts'o.
+ *
+ *  Copyright (C) 2001 Aleph One Ltd. for Acunia N.V.
+ *
+ *  Copyright (C) 2001 Blue Mug, Inc. for Acunia N.V.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Changelog:
+ *   20-Apr-2001 TTC	Created
+ *   05-May-2001 W/TTC	Updated for serial_core.c
+ *   27-Jun-2001 jonm	Minor changes; add mctrl support, switch to 
+ *   			SA_INTERRUPT. Works reliably now. No longer requires
+ *   			changes to the serial_core API.
+ *
+ *  $Id: serial_anakin.c,v 1.5.2.1 2001/11/27 17:35:39 rmk Exp $
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/major.h>
+#include <linux/string.h>
+#include <linux/fcntl.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/circ_buf.h>
+#include <linux/serial.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <asm/bitops.h>
+
+#include <linux/serial_core.h>
+
+#include <asm/arch/serial_reg.h>
+
+#define UART_NR			5
+
+#define SERIAL_ANAKIN_NAME	"ttyAN"
+#define SERIAL_ANAKIN_MAJOR	204
+#define SERIAL_ANAKIN_MINOR	32
+
+#define CALLOUT_ANAKIN_NAME	"cuaan"
+#define CALLOUT_ANAKIN_MAJOR	205
+#define CALLOUT_ANAKIN_MINOR	32
+
+static struct tty_driver normal, callout;
+static struct tty_struct *anakin_table[UART_NR];
+static struct termios *anakin_termios[UART_NR], *anakin_termios_locked[UART_NR];
+static struct uart_state anakin_state[UART_NR];
+static u_int txenable[NR_IRQS];		/* Software interrupt register */
+
+static inline unsigned int
+anakin_in(struct uart_port *port, u_int offset)
+{
+	return __raw_readl(port->base + offset);
+}
+
+static inline void
+anakin_out(struct uart_port *port, u_int offset, unsigned int value)
+{
+	__raw_writel(value, port->base + offset);
+}
+
+static void
+anakin_stop_tx(struct uart_port *port, u_int from_tty)
+{
+	txenable[port->irq] = 0;
+}
+
+static inline void
+anakin_transmit_buffer(struct uart_info *info)
+{
+	struct uart_port *port = info->port;
+
+	while (!(anakin_in(port, 0x10) & TXEMPTY));
+	anakin_out(port, 0x14, info->xmit.buf[info->xmit.tail]);
+	anakin_out(port, 0x18, anakin_in(port, 0x18) | SENDREQUEST);
+	info->xmit.tail = (info->xmit.tail + 1) & (UART_XMIT_SIZE-1);
+        info->state->icount.tx++;
+
+	if (info->xmit.head == info->xmit.tail)
+		anakin_stop_tx(port, 0); 
+}
+
+static inline void
+anakin_transmit_x_char(struct uart_info *info)
+{
+	struct uart_port *port = info->port;
+
+	anakin_out(port, 0x14, info->x_char);
+	anakin_out(port, 0x18, anakin_in(port, 0x18) | SENDREQUEST);
+	info->state->icount.tx++;
+	info->x_char = 0;
+}
+
+static void
+anakin_start_tx(struct uart_port *port, u_int nonempty, u_int from_tty)
+{
+	unsigned int flags;
+
+	save_flags_cli(flags);
+
+	// is it this... or below: if (nonempty
+	if (!txenable[port->irq]) {
+		txenable[port->irq] = TXENABLE;
+
+		if ((anakin_in(port, 0x10) & TXEMPTY) && nonempty) {
+		    anakin_transmit_buffer((struct uart_info*)port->unused);
+		}
+	}
+
+	restore_flags(flags);
+}
+
+static void
+anakin_stop_rx(struct uart_port *port)
+{
+	unsigned long flags;
+
+	save_flags_cli(flags);
+	while (anakin_in(port, 0x10) & RXRELEASE) 
+	    anakin_in(port, 0x14);
+	anakin_out(port, 0x18, anakin_in(port, 0x18) | BLOCKRX);
+	restore_flags(flags);
+}
+
+static void
+anakin_enable_ms(struct uart_port *port)
+{
+}
+
+static inline void
+anakin_rx_chars(struct uart_info *info)
+{
+	unsigned int ch;
+	struct tty_struct *tty = info->tty;
+
+	if (!(anakin_in(info->port, 0x10) & RXRELEASE))
+		return;
+
+	ch = anakin_in(info->port, 0x14) & 0xff;
+
+	if (tty->flip.count < TTY_FLIPBUF_SIZE) {
+		*tty->flip.char_buf_ptr++ = ch;
+		*tty->flip.flag_buf_ptr++ = TTY_NORMAL;
+		info->state->icount.rx++;
+		tty->flip.count++;
+	} 
+	tty_flip_buffer_push(tty);
+}
+
+static inline void
+anakin_overrun_chars(struct uart_info *info)
+{
+	unsigned int ch;
+
+	ch = anakin_in(info->port, 0x14);
+	info->state->icount.overrun++;
+}
+
+static inline void
+anakin_tx_chars(struct uart_info *info)
+{
+	if (info->x_char) {
+		anakin_transmit_x_char(info);
+		return; 
+	}
+
+	if (info->xmit.head == info->xmit.tail
+	    || info->tty->stopped
+	    || info->tty->hw_stopped) {
+		anakin_stop_tx(info->port, 0);
+		return;
+	}
+
+	anakin_transmit_buffer(info);
+
+	if (CIRC_CNT(info->xmit.head,
+		     info->xmit.tail,
+		     UART_XMIT_SIZE) < WAKEUP_CHARS)
+		uart_event(info, EVT_WRITE_WAKEUP);
+}
+
+static void
+anakin_int(int irq, void *dev_id, struct pt_regs *regs)
+{
+	unsigned int status;
+	struct uart_info *info = dev_id;
+
+	status = anakin_in(info->port, 0x1c);
+
+	if (status & RX) 
+		anakin_rx_chars(info);
+
+	if (status & OVERRUN) 
+		anakin_overrun_chars(info);
+
+	if (txenable[info->port->irq] && (status & TX)) 
+		anakin_tx_chars(info);
+}
+
+static u_int
+anakin_tx_empty(struct uart_port *port)
+{
+	return anakin_in(port, 0x10) & TXEMPTY ? TIOCSER_TEMT : 0;
+}
+
+static u_int
+anakin_get_mctrl(struct uart_port *port)
+{
+	unsigned int status = 0;
+
+	status |= (anakin_in(port, 0x10) & CTS ? TIOCM_CTS : 0);
+	status |= (anakin_in(port, 0x18) & DCD ? TIOCM_CAR : 0);
+	status |= (anakin_in(port, 0x18) & DTR ? TIOCM_DTR : 0);
+	status |= (anakin_in(port, 0x18) & RTS ? TIOCM_RTS : 0);
+	
+	return status;
+}
+
+static void
+anakin_set_mctrl(struct uart_port *port, u_int mctrl)
+{
+	unsigned int status;
+
+	status = anakin_in(port, 0x18);
+
+	if (mctrl & TIOCM_RTS) 
+		status |= RTS;
+	else 
+		status &= ~RTS;
+
+	if (mctrl & TIOCM_CAR)
+		status |= DCD;
+	else 
+		status &= ~DCD;
+
+	anakin_out(port, 0x18, status);
+}
+
+static void
+anakin_break_ctl(struct uart_port *port, int break_state)
+{
+	unsigned int status;
+
+	status = anakin_in(port, 0x20);
+
+	if (break_state == -1)
+		status |= SETBREAK;
+	else
+		status &= ~SETBREAK;
+
+	anakin_out(port, 0x20, status);
+}
+
+static int
+anakin_startup(struct uart_port *port, struct uart_info *info)
+{
+	int retval;
+	unsigned int read,write;
+
+	/*
+	 * Allocate the IRQ
+	 */
+	retval = request_irq(port->irq, anakin_int, SA_INTERRUPT, "serial_anakin", info);
+	if (retval)
+		return retval;
+
+	port->ops->set_mctrl(port, info->mctrl);
+
+	/*
+	 * initialise the old status of the modem signals
+	 */
+	port->old_status = 0;
+
+	/*
+	 * Finally, disable IRQ and softIRQs for first byte)
+	 */
+	txenable[port->irq] = 0;
+	read = anakin_in(port, 0x18);
+	write = (read & ~(RTS | DTR | BLOCKRX)) | IRQENABLE;
+	anakin_out(port, 0x18, write);
+
+	/* Store the uart_info pointer so we can reference it in 
+	 * anakin_start_tx() */
+	port->unused = (u_int)info;
+	
+	return 0;
+}
+
+static void
+anakin_shutdown(struct uart_port *port, struct uart_info *info)
+{
+	/*
+	 * Free the interrupt
+	 */
+	free_irq(port->irq, info);
+
+	/*
+	 * disable all interrupts, disable the port
+	 */
+	anakin_out(port, 0x18, anakin_in(port, 0x18) & ~IRQENABLE);
+}
+
+static void
+anakin_change_speed(struct uart_port *port, u_int cflag, u_int iflag, u_int quot)
+{
+	unsigned int flags;
+
+	save_flags_cli(flags);
+	while (!(anakin_in(port, 0x10) & TXEMPTY));
+	anakin_out(port, 0x10, (anakin_in(port, 0x10) & ~PRESCALER)
+			| (quot << 3));
+
+	//parity always set to none
+	anakin_out(port, 0x18, anakin_in(port, 0x18) & ~PARITY);
+	restore_flags(flags);
+}
+
+static const char *anakin_type(struct port *port)
+{
+	return port->type == PORT_ANAKIN ? "ANAKIN" : NULL;
+}
+
+static struct uart_ops anakin_pops = {
+	tx_empty:	anakin_tx_empty,
+	set_mctrl:	anakin_set_mctrl,
+	get_mctrl:	anakin_get_mctrl,
+	stop_tx:	anakin_stop_tx,
+	start_tx:	anakin_start_tx,
+	stop_rx:	anakin_stop_rx,
+	enable_ms:	anakin_enable_ms,
+	break_ctl:	anakin_break_ctl,
+	startup:	anakin_startup,
+	shutdown:	anakin_shutdown,
+	change_speed:	anakin_change_speed,
+	type:		anakin_type,
+};
+
+static struct uart_port anakin_ports[UART_NR] = {
+	{
+		base:		IO_BASE + UART0,
+		irq:		IRQ_UART0,
+		uartclk:	3686400,
+		fifosize:	0,
+		ops:		&anakin_pops,
+	},
+	{
+		base:		IO_BASE + UART1,
+		irq:		IRQ_UART1,
+		uartclk:	3686400,
+		fifosize:	0,
+		ops:		&anakin_pops,
+	},
+	{
+		base:		IO_BASE + UART2,
+		irq:		IRQ_UART2,
+		uartclk:	3686400,
+		fifosize:	0,
+		ops:		&anakin_pops,
+	},
+	{
+		base:		IO_BASE + UART3,
+		irq:		IRQ_UART3,
+		uartclk:	3686400,
+		fifosize:	0,
+		ops:		&anakin_pops,
+	},
+	{
+		base:		IO_BASE + UART4,
+		irq:		IRQ_UART4,
+		uartclk:	3686400,
+		fifosize:	0,
+		ops:		&anakin_pops,
+	},
+};
+
+
+#ifdef CONFIG_SERIAL_ANAKIN_CONSOLE
+
+static void
+anakin_console_write(struct console *co, const char *s, u_int count)
+{
+	struct uart_port *port = anakin_ports + co->index;
+	unsigned int flags, status, i;
+
+	/*
+	 *	First save the status then disable the interrupts
+	 */
+	save_flags_cli(flags);
+	status = anakin_in(port, 0x18);
+	anakin_out(port, 0x18, status & ~IRQENABLE);
+	restore_flags(flags);
+
+	/*
+	 *	Now, do each character
+	 */
+	for (i = 0; i < count; i++, s++) {
+		while (!(anakin_in(port, 0x10) & TXEMPTY));
+
+		/*
+		 *	Send the character out.
+		 *	If a LF, also do CR...
+		 */
+		anakin_out(port, 0x14, *s);
+		anakin_out(port, 0x18, anakin_in(port, 0x18) | SENDREQUEST);
+
+		if (*s == 10) {
+			while (!(anakin_in(port, 0x10) & TXEMPTY));
+			anakin_out(port, 0x14, 13);
+			anakin_out(port, 0x18, anakin_in(port, 0x18)
+					| SENDREQUEST);
+		}
+	}
+
+	/*
+	 *	Finally, wait for transmitter to become empty
+	 *	and restore the interrupts
+	 */
+	while (!(anakin_in(port, 0x10) & TXEMPTY));
+
+	if (status & IRQENABLE)
+		save_flags_cli(flags);
+ 		anakin_out(port, 0x18, anakin_in(port, 0x18) | IRQENABLE);
+		restore_flags(flags);
+}
+
+static kdev_t
+anakin_console_device(struct console *co)
+{
+	return MKDEV(SERIAL_ANAKIN_MAJOR, SERIAL_ANAKIN_MINOR + co->index);
+}
+
+static int
+anakin_console_wait_key(struct console *co)
+{
+	struct uart_port *port = anakin_ports + co->index;
+	unsigned int flags, status, ch;
+
+	save_flags_cli(flags);
+	status = anakin_in(port, 0x18);
+	anakin_out(port, 0x18, status & ~IRQENABLE);
+	restore_flags(flags);
+
+	while (!(anakin_in(port, 0x10) & RXRELEASE));
+	ch = anakin_in(port, 0x14);
+
+	if (status & IRQENABLE) {
+		save_flags_cli(flags);
+		anakin_out(port, 0x18, anakin_in(port, 0x18) | IRQENABLE);
+		restore_flags(flags);
+	}
+	return ch;
+}
+
+/*
+ * Read the current UART setup.
+ */
+static void __init
+anakin_console_get_options(struct uart_port *port, int *baud, int *parity, int *bits)
+{
+	int paritycode;
+
+	*baud = GETBAUD (anakin_in(port, 0x10) & PRESCALER);
+	paritycode = GETPARITY(anakin_in(port, 0x18) & PARITY);
+	switch (paritycode) {
+	  case NONEPARITY: *parity = 'n'; break;
+	  case ODDPARITY: *parity = 'o'; break;
+	  case EVENPARITY: *parity = 'e'; break;
+	}
+	*bits = 8;
+}
+
+static int __init
+anakin_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port;
+	int baud = CONFIG_ANAKIN_DEFAULT_BAUDRATE;
+	int bits = 8;
+	int parity = 'n';
+
+	/*
+	 * Check whether an invalid uart number has been specified, and
+	 * if so, search for the first available port that does have
+	 * console support.
+	 */
+	port = uart_get_console(anakin_ports, UART_NR, co);
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits);
+	else
+		anakin_console_get_options(port, &baud, &parity, &bits);
+
+	return uart_set_options(port, co, baud, parity, bits);
+}
+
+static struct console anakin_console = {
+	name:		SERIAL_ANAKIN_NAME,
+	write:		anakin_console_write,
+	device:		anakin_console_device,
+	wait_key:	anakin_console_wait_key,
+	setup:		anakin_console_setup,
+	flags:		CON_PRINTBUFFER,
+	index:		-1,
+};
+
+void __init
+anakin_console_init(void)
+{
+	register_console(&anakin_console);
+}
+
+#define ANAKIN_CONSOLE		&anakin_console
+#else
+#define ANAKIN_CONSOLE		NULL
+#endif
+
+static struct uart_register anakin_reg = {
+	normal_major:		SERIAL_ANAKIN_MAJOR,
+	normal_name:		SERIAL_ANAKIN_NAME,
+	normal_driver:		&normal,
+	callout_major:		CALLOUT_ANAKIN_MAJOR,
+	callout_name:		CALLOUT_ANAKIN_NAME,
+	callout_driver:		&callout,
+	table:			anakin_table,
+	termios:		anakin_termios,
+	termios_locked:		anakin_termios_locked,
+	minor:			SERIAL_ANAKIN_MINOR,
+	nr:			UART_NR,
+	state:			anakin_state,
+	port:			anakin_ports,
+	cons:			ANAKIN_CONSOLE,
+};
+
+static int __init
+anakin_init(void)
+{
+	return uart_register_port(&anakin_reg);
+}
+
+__initcall(anakin_init);
+
+MODULE_DESCRIPTION("Anakin serial driver");
+MODULE_AUTHOR("Tak-Shing Chan <chan@aleph1.co.uk>");
+MODULE_SUPPORTED_DEVICE("ttyAN");
+MODULE_LICENSE("GPL");
+
+EXPORT_NO_SYMBOLS;
diff -urN uClinux-dist/linux-2.4.x/drivers/serial/serial_clps711x.c linux-2.4.x/drivers/serial/serial_clps711x.c
--- uClinux-dist/linux-2.4.x/drivers/serial/serial_clps711x.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.4.x/drivers/serial/serial_clps711x.c	2004-03-25 23:16:48.000000000 +0800
@@ -0,0 +1,693 @@
+/*
+ *  linux/drivers/char/serial_clps711x.c
+ *
+ *  Driver for CLPS711x serial ports
+ *
+ *  Based on drivers/char/serial.c, by Linus Torvalds, Theodore Ts'o.
+ *
+ *  Copyright 1999 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *  $Id: serial_clps711x.c,v 1.12.2.1 2001/11/27 17:35:39 rmk Exp $
+ *
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/major.h>
+#include <linux/string.h>
+#include <linux/fcntl.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/circ_buf.h>
+#include <linux/serial.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+
+#include <asm/bitops.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/uaccess.h>
+
+#include <linux/serial_core.h>
+
+#include <asm/hardware/clps7111.h>
+
+#define UART_NR		2
+
+#define SERIAL_CLPS711X_NAME	"ttyAM"
+#define SERIAL_CLPS711X_MAJOR	204
+#define SERIAL_CLPS711X_MINOR	16
+#define SERIAL_CLPS711X_NR	UART_NR
+
+#define CALLOUT_CLPS711X_NAME	"cuaam"
+#define CALLOUT_CLPS711X_MAJOR	205
+#define CALLOUT_CLPS711X_MINOR	16
+#define CALLOUT_CLPS711X_NR	UART_NR
+
+static struct tty_driver normal, callout;
+static struct tty_struct *clps711x_table[UART_NR];
+static struct termios *clps711x_termios[UART_NR], *clps711x_termios_locked[UART_NR];
+
+/*
+ * We use the relevant SYSCON register as a base address for these ports.
+ */
+#define UBRLCR(port)		((port)->iobase + UBRLCR1 - SYSCON1)
+#define UARTDR(port)		((port)->iobase + UARTDR1 - SYSCON1)
+#define SYSFLG(port)		((port)->iobase + SYSFLG1 - SYSCON1)
+#define SYSCON(port)		((port)->iobase + SYSCON1 - SYSCON1)
+
+#define TX_IRQ(port)		((port)->irq)
+#define RX_IRQ(port)		((port)->irq + 1)
+
+#define UART_ANY_ERR		(UARTDR_FRMERR | UARTDR_PARERR | UARTDR_OVERR)
+
+static void clps711xuart_stop_tx(struct uart_port *port, u_int from_tty)
+{
+	disable_irq(TX_IRQ(port));
+}
+
+static void clps711xuart_start_tx(struct uart_port *port, u_int nonempty, u_int from_tty)
+{
+	if (nonempty)
+		enable_irq(TX_IRQ(port));
+}
+
+static void clps711xuart_stop_rx(struct uart_port *port)
+{
+	disable_irq(RX_IRQ(port));
+}
+
+static void clps711xuart_enable_ms(struct uart_port *port)
+{
+}
+
+#if 0
+static void ambauart_modem_status(struct uart_info *info)
+{
+	unsigned int status, delta;
+	struct uart_icount *icount = &info->port->icount;
+
+	UART_PUT_ICR(info->port, 0);
+
+	status = UART_GET_FR(info->port) & AMBA_UARTFR_MODEM_ANY;
+
+	delta = status ^ info->port->old_status;
+	info->port->old_status = status;
+
+	if (!delta)
+		return;
+
+	if (delta & AMBA_UARTFR_DCD)
+		uart_handle_dcd_change(info, status & AMBA_UARTFR_DCD);
+
+	if (delta & AMBA_UARTFR_DSR)
+		icount->dsr++;
+
+	if (delta & AMBA_UARTFR_CTS)
+		uart_handle_cts_change(info, status & AMBA_UARTFR_CTS);
+
+	wake_up_interruptible(&info->delta_msr_wait);
+}
+#endif
+
+static void clps711xuart_int_rx(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct uart_info *info = dev_id;
+	struct tty_struct *tty = info->tty;
+	unsigned int status, ch, flg, ignored = 0;
+	struct uart_port *port = info->port;
+
+	status = clps_readl(SYSFLG(port));
+	while (!(status & SYSFLG_URXFE)) {
+		ch = clps_readl(UARTDR(port));
+
+		if (tty->flip.count >= TTY_FLIPBUF_SIZE)
+			goto ignore_char;
+		port->icount.rx++;
+
+		flg = TTY_NORMAL;
+
+		/*
+		 * Note that the error handling code is
+		 * out of the main execution path
+		 */
+		if (ch & UART_ANY_ERR)
+			goto handle_error;
+
+		if (uart_handle_sysrq_char(info, ch, regs))
+			goto ignore_char;
+
+	error_return:
+		*tty->flip.flag_buf_ptr++ = flg;
+		*tty->flip.char_buf_ptr++ = ch;
+		tty->flip.count++;
+	ignore_char:
+		status = clps_readl(SYSFLG(port));
+	}
+out:
+	tty_flip_buffer_push(tty);
+	return;
+
+handle_error:
+	if (ch & UARTDR_PARERR)
+		port->icount.parity++;
+	else if (ch & UARTDR_FRMERR)
+		port->icount.frame++;
+	if (ch & UARTDR_OVERR)
+		port->icount.overrun++;
+
+	if (ch & port->ignore_status_mask) {
+		if (++ignored > 100)
+			goto out;
+		goto ignore_char;
+	}
+	ch &= port->read_status_mask;
+
+	if (ch & UARTDR_PARERR)
+		flg = TTY_PARITY;
+	else if (ch & UARTDR_FRMERR)
+		flg = TTY_FRAME;
+
+	if (ch & UARTDR_OVERR) {
+		/*
+		 * CHECK: does overrun affect the current character?
+		 * ASSUMPTION: it does not.
+		 */
+		*tty->flip.flag_buf_ptr++ = flg;
+		*tty->flip.char_buf_ptr++ = ch;
+		tty->flip.count++;
+		if (tty->flip.count >= TTY_FLIPBUF_SIZE)
+			goto ignore_char;
+		ch = 0;
+		flg = TTY_OVERRUN;
+	}
+#ifdef SUPPORT_SYSRQ
+	info->sysrq = 0;
+#endif
+	goto error_return;
+}
+
+static void clps711xuart_int_tx(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct uart_info *info = dev_id;
+	struct uart_port *port = info->port;
+	int count;
+
+	if (port->x_char) {
+		clps_writel(port->x_char, UARTDR(port));
+		port->icount.tx++;
+		port->x_char = 0;
+		return;
+	}
+	if (info->xmit.head == info->xmit.tail
+	    || info->tty->stopped
+	    || info->tty->hw_stopped) {
+		clps711xuart_stop_tx(info->port, 0);
+		return;
+	}
+
+	count = port->fifosize >> 1;
+	do {
+		clps_writel(info->xmit.buf[info->xmit.tail], UARTDR(port));
+		info->xmit.tail = (info->xmit.tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+		if (info->xmit.head == info->xmit.tail)
+			break;
+	} while (--count > 0);
+
+	if (CIRC_CNT(info->xmit.head,
+		     info->xmit.tail,
+		     UART_XMIT_SIZE) < WAKEUP_CHARS)
+		uart_event(info, EVT_WRITE_WAKEUP);
+
+	if (info->xmit.head == info->xmit.tail)
+		clps711xuart_stop_tx(info->port, 0);
+}
+
+static u_int clps711xuart_tx_empty(struct uart_port *port)
+{
+	u_int status = clps_readl(SYSFLG(port));
+	return status & SYSFLG_UBUSY ? 0 : TIOCSER_TEMT;
+}
+
+static u_int clps711xuart_get_mctrl(struct uart_port *port)
+{
+	unsigned int port_addr;
+	unsigned int result = 0;
+	unsigned int status;
+
+	port_addr = SYSFLG(port);
+	if (port_addr == SYSFLG1) {
+		status = clps_readl(SYSFLG1);
+		if (status & SYSFLG1_DCD)
+			result |= TIOCM_CAR;
+		if (status & SYSFLG1_DSR)
+			result |= TIOCM_DSR;
+		if (status & SYSFLG1_CTS)
+			result |= TIOCM_CTS;
+	}
+
+	return result;
+}
+
+static void clps711xuart_set_mctrl_null(struct uart_port *port, u_int mctrl)
+{
+}
+
+static void clps711xuart_break_ctl(struct uart_port *port, int break_state)
+{
+	unsigned int ubrlcr;
+
+	ubrlcr = clps_readl(UBRLCR(port));
+	if (break_state == -1)
+		ubrlcr |= UBRLCR_BREAK;
+	else
+		ubrlcr &= ~UBRLCR_BREAK;
+	clps_writel(ubrlcr, UBRLCR(port));
+}
+
+static int clps711xuart_startup(struct uart_port *port, struct uart_info *info)
+{
+	u_int syscon;
+	int retval;
+
+	/*
+	 * Allocate the IRQs
+	 */
+	retval = request_irq(TX_IRQ(port), clps711xuart_int_tx, 0,
+			     "clps711xuart_tx", info);
+	if (retval)
+		return retval;
+
+	retval = request_irq(RX_IRQ(port), clps711xuart_int_rx, 0,
+			     "clps711xuart_rx", info);
+	if (retval) {
+		free_irq(TX_IRQ(port), info);
+		return retval;
+	}
+
+	port->ops->set_mctrl(port, info->mctrl);
+
+	/*
+	 * enable the port
+	 */
+	syscon = clps_readl(SYSCON(port));
+	syscon |= SYSCON_UARTEN;
+	clps_writel(syscon, SYSCON(port));
+
+	return 0;
+}
+
+static void clps711xuart_shutdown(struct uart_port *port, struct uart_info *info)
+{
+	u_int ubrlcr, syscon;
+
+	/*
+	 * Free the interrupt
+	 */
+	free_irq(TX_IRQ(port), info);	/* TX interrupt */
+	free_irq(RX_IRQ(port), info);	/* RX interrupt */
+
+	/*
+	 * disable the port
+	 */
+	syscon = clps_readl(SYSCON(port));
+	syscon &= ~SYSCON_UARTEN;
+	clps_writel(syscon, SYSCON(port));
+
+	/*
+	 * disable break condition and fifos
+	 */
+	ubrlcr = clps_readl(UBRLCR(port));
+	ubrlcr &= ~(UBRLCR_FIFOEN | UBRLCR_BREAK);
+	clps_writel(ubrlcr, UBRLCR(port));
+}
+
+static void clps711xuart_change_speed(struct uart_port *port, u_int cflag, u_int iflag, u_int quot)
+{
+	u_int ubrlcr;
+	unsigned long flags;
+
+#if DEBUG
+	printk("clps711xuart_change_speed(cflag=0x%x, iflag=0x%x, quot=%d) called\n",
+		cflag, iflag, quot);
+#endif
+	/* byte size and parity */
+	switch (cflag & CSIZE) {
+	case CS5: ubrlcr = UBRLCR_WRDLEN5; break;
+	case CS6: ubrlcr = UBRLCR_WRDLEN6; break;
+	case CS7: ubrlcr = UBRLCR_WRDLEN7; break;
+	default:  ubrlcr = UBRLCR_WRDLEN8; break; // CS8
+	}
+	if (cflag & CSTOPB)
+		ubrlcr |= UBRLCR_XSTOP;
+	if (cflag & PARENB) {
+		ubrlcr |= UBRLCR_PRTEN;
+		if (!(cflag & PARODD))
+			ubrlcr |= UBRLCR_EVENPRT;
+	}
+	if (port->fifosize > 1)
+		ubrlcr |= UBRLCR_FIFOEN;
+
+	port->read_status_mask = UARTDR_OVERR;
+	if (iflag & INPCK)
+		port->read_status_mask |= UARTDR_PARERR | UARTDR_FRMERR;
+//	if (iflag & (BRKINT | PARMRK))
+//		port->read_status_mask |= AMBA_UARTRSR_BE;
+
+	/*
+	 * Characters to ignore
+	 */
+	port->ignore_status_mask = 0;
+	if (iflag & IGNPAR)
+		port->ignore_status_mask |= UARTDR_FRMERR | UARTDR_PARERR;
+	if (iflag & IGNBRK) {
+//		port->ignore_status_mask |= AMBA_UARTRSR_BE;
+		/*
+		 * If we're ignoring parity and break indicators,
+		 * ignore overruns to (for real raw support).
+		 */
+		if (iflag & IGNPAR)
+			port->ignore_status_mask |= UARTDR_OVERR;
+	}
+
+	quot -= 1;
+
+	/* first, disable everything */
+	save_flags(flags); cli();
+
+	clps_writel(ubrlcr | quot, UBRLCR(port));
+
+	restore_flags(flags);
+}
+
+static const char *clps711xuart_type(struct uart_port *port)
+{
+	return port->type == PORT_CLPS711X ? "CLPS711x" : NULL;
+}
+
+/*
+ * Configure/autoconfigure the port.
+ */
+static void clps711xuart_config_port(struct uart_port *port, int flags)
+{
+	if (flags & UART_CONFIG_TYPE)
+		port->type = PORT_CLPS711X;
+}
+
+static void clps711xuart_release_port(struct uart_port *port)
+{
+}
+
+static int clps711xuart_request_port(struct uart_port *port)
+{
+	return 0;
+}
+
+static struct uart_ops clps711x_pops = {
+	tx_empty:	clps711xuart_tx_empty,
+	set_mctrl:	clps711xuart_set_mctrl_null,
+	get_mctrl:	clps711xuart_get_mctrl,
+	stop_tx:	clps711xuart_stop_tx,
+	start_tx:	clps711xuart_start_tx,
+	stop_rx:	clps711xuart_stop_rx,
+	enable_ms:	clps711xuart_enable_ms,
+	break_ctl:	clps711xuart_break_ctl,
+	startup:	clps711xuart_startup,
+	shutdown:	clps711xuart_shutdown,
+	change_speed:	clps711xuart_change_speed,
+	type:		clps711xuart_type,
+	config_port:	clps711xuart_config_port,
+	release_port:	clps711xuart_release_port,
+	request_port:	clps711xuart_request_port,
+};
+
+static struct uart_port clps711x_ports[UART_NR] = {
+	{
+		iobase:		SYSCON1,
+		irq:		IRQ_UTXINT1, /* IRQ_URXINT1, IRQ_UMSINT */
+		uartclk:	3686400,
+		fifosize:	16,
+		ops:		&clps711x_pops,
+		flags:		ASYNC_BOOT_AUTOCONF,
+	},
+	{
+		iobase:		SYSCON2,
+		irq:		IRQ_UTXINT2, /* IRQ_URXINT2 */
+		uartclk:	3686400,
+		fifosize:	16,
+		ops:		&clps711x_pops,
+		flags:		ASYNC_BOOT_AUTOCONF,
+	}
+};
+
+#ifdef CONFIG_SERIAL_CLPS711X_CONSOLE
+
+#ifdef used_and_not_const_char_pointer
+/*
+ * This code is currently never used; console->read is never called.
+ * Therefore, although we have an implementation, we don't use it.
+ * FIXME: the "const char *s" should be fixed to "char *s" some day.
+ * (when the definition in include/linux/console.h is also fixed)
+ */
+static int clps711xuart_console_read(struct uart_port *port, char *s, u_int count)
+{
+	u_int status;
+	int c;
+#if DEBUG
+	printk("clps711xuart_console_read() called\n");
+#endif
+
+	c = 0;
+	while (c < count) {
+		status = clps_readl(SYSFLG(port));
+		if (status & SYSFLG_URXFE) {
+			// nothing more to get, return
+			return c;
+		} else {
+			*s++ = clps_readl(UARTDR(port));
+			c++;
+		}
+	}
+	// return the count
+	return c;
+}
+#endif
+
+/*
+ *	Print a string to the serial port trying not to disturb
+ *	any possible real use of the port...
+ *
+ *	The console_lock must be held when we get here.
+ *
+ *	Note that this is called with interrupts already disabled
+ */
+static void clps711xuart_console_write(struct console *co, const char *s, u_int count)
+{
+	struct uart_port *port = clps711x_ports + co->index;
+	unsigned int status, syscon;
+	int i;
+
+	/*
+	 *	Ensure that the port is enabled.
+	 */
+	syscon = clps_readl(SYSCON(port));
+	clps_writel(syscon | SYSCON_UARTEN, SYSCON(port));
+
+	/*
+	 *	Now, do each character
+	 */
+	for (i = 0; i < count; i++) {
+		do {
+			status = clps_readl(SYSFLG(port));
+		} while (status & SYSFLG_UTXFF);
+		clps_writel(s[i], UARTDR(port));
+		if (s[i] == '\n') {
+			do {
+				status = clps_readl(SYSFLG(port));
+			} while (status & SYSFLG_UTXFF);
+			clps_writel('\r', UARTDR(port));
+		}
+	}
+
+	/*
+	 *	Finally, wait for transmitter to become empty
+	 *	and restore the uart state.
+	 */
+	do {
+		status = clps_readl(SYSFLG(port));
+	} while (status & SYSFLG_UBUSY);
+
+	clps_writel(syscon, SYSCON(port));
+}
+
+static kdev_t clps711xuart_console_device(struct console *co)
+{
+	return MKDEV(SERIAL_CLPS711X_MAJOR, SERIAL_CLPS711X_MINOR + co->index);
+}
+
+/*
+ *	Receive character from the serial port
+ *	  what about interrupts?
+ */
+static int clps711xuart_console_wait_key(struct console *co)
+{
+	struct uart_port *port = clps711x_ports + co->index;
+	u_int status, syscon, ch;
+
+	/*
+	 *	Ensure that the port is enabled.
+	 */
+	syscon = clps_readl(SYSCON(port));
+	clps_writel(syscon | SYSCON_UARTEN, SYSCON(port));
+
+	do {
+		status = clps_readl(SYSFLG(port));
+	} while (status & SYSFLG_URXFE);
+	ch = clps_readl(UARTDR(port)) & 0xff;
+
+	clps_writel(syscon, SYSCON(port));
+
+	return ch;
+}
+
+static void __init
+clps711xuart_console_get_options(struct uart_port *port, int *baud, int *parity, int *bits)
+{
+	if (clps_readl(SYSCON(port)) & SYSCON_UARTEN) {
+		u_int ubrlcr, quot;
+
+		ubrlcr = clps_readl(UBRLCR(port));
+
+		*parity = 'n';
+		if (ubrlcr & UBRLCR_PRTEN) {
+			if (ubrlcr & UBRLCR_EVENPRT)
+				*parity = 'e';
+			else
+				*parity = 'o';
+		}
+
+		if ((ubrlcr & UBRLCR_WRDLEN_MASK) == UBRLCR_WRDLEN7)
+			*bits = 7;
+		else
+			*bits = 8;
+
+		quot = ubrlcr & UBRLCR_BAUD_MASK;
+		*baud = port->uartclk / (16 * (quot + 1));
+	}
+}
+
+static int __init clps711xuart_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port;
+	int baud = 38400;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	/*
+	 * Check whether an invalid uart number has been specified, and
+	 * if so, search for the first available port that does have
+	 * console support.
+	 */
+	port = uart_get_console(clps711x_ports, UART_NR, co);
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+	else
+		clps711xuart_console_get_options(port, &baud, &parity, &bits);
+
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+static struct console clps711x_console = {
+	name:		SERIAL_CLPS711X_NAME,
+	write:		clps711xuart_console_write,
+#ifdef used_and_not_const_char_pointer
+	read:		clps711xuart_console_read,
+#endif
+	device:		clps711xuart_console_device,
+	wait_key:	clps711xuart_console_wait_key,
+	setup:		clps711xuart_console_setup,
+	flags:		CON_PRINTBUFFER,
+	index:		-1,
+};
+
+void __init clps711xuart_console_init(void)
+{
+	register_console(&clps711x_console);
+}
+
+#define CLPS711X_CONSOLE	&clps711x_console
+#else
+#define CLPS711X_CONSOLE	NULL
+#endif
+
+static struct uart_driver clps711x_reg = {
+#ifdef CONFIG_DEVFS_FS
+	normal_name:		SERIAL_CLPS711X_NAME,
+	callout_name:		CALLOUT_CLPS711X_NAME,
+#else
+	normal_name:		SERIAL_CLPS711X_NAME,
+	callout_name:		CALLOUT_CLPS711X_NAME,
+#endif
+
+	normal_major:		SERIAL_CLPS711X_MAJOR,
+	normal_driver:		&normal,
+	callout_major:		CALLOUT_CLPS711X_MAJOR,
+	callout_driver:		&callout,
+
+	table:			clps711x_table,
+	termios:		clps711x_termios,
+	termios_locked:		clps711x_termios_locked,
+
+	minor:			SERIAL_CLPS711X_MINOR,
+	nr:			UART_NR,
+
+	port:			clps711x_ports,
+	cons:			CLPS711X_CONSOLE,
+};
+
+static int __init clps711xuart_init(void)
+{
+	return uart_register_driver(&clps711x_reg);
+}
+
+static void __exit clps711xuart_exit(void)
+{
+	uart_unregister_driver(&clps711x_reg);
+}
+
+module_init(clps711xuart_init);
+module_exit(clps711xuart_exit);
+
+EXPORT_NO_SYMBOLS;
+
+MODULE_AUTHOR("Deep Blue Solutions Ltd");
+MODULE_DESCRIPTION("CLPS-711x generic serial driver");
+MODULE_LICENSE("GPL");
diff -urN uClinux-dist/linux-2.4.x/drivers/serial/serial_core.c linux-2.4.x/drivers/serial/serial_core.c
--- uClinux-dist/linux-2.4.x/drivers/serial/serial_core.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.4.x/drivers/serial/serial_core.c	2004-03-26 01:24:43.000000000 +0800
@@ -0,0 +1,2253 @@
+/*
+ *  linux/drivers/char/serial_core.c
+ *
+ *  Driver core for serial ports
+ *
+ *  Based on drivers/char/serial.c, by Linus Torvalds, Theodore Ts'o.
+ *
+ *  Copyright 1999 ARM Limited
+ *  Copyright (C) 2000-2001 Deep Blue Solutions Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *  $Id: serial_core.c,v 1.20.2.5 2002/03/13 15:22:26 rmk Exp $
+ *
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/major.h>
+#include <linux/string.h>
+#include <linux/fcntl.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/circ_buf.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/pm.h>
+#include <linux/serial_core.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <asm/bitops.h>
+
+#undef	DEBUG
+
+#ifndef CONFIG_PM
+#define pm_access(pm)		do { } while (0)
+#define pm_unregister(pm)	do { } while (0)
+#endif
+
+/*
+ * tmp_buf is used as a temporary buffer by serial_write.  We need to
+ * lock it in case the copy_from_user blocks while swapping in a page,
+ * and some other program tries to do a serial write at the same time.
+ * Since the lock will only come under contention when the system is
+ * swapping and available memory is low, it makes sense to share one
+ * buffer across all the serial ports, since it significantly saves
+ * memory if large numbers of serial ports are open.
+ */
+static u_char *tmp_buf;
+static DECLARE_MUTEX(tmp_buf_sem);
+
+/*
+ * This is used to lock changes in serial line configuration.
+ */
+static DECLARE_MUTEX(port_sem);
+
+#define HIGH_BITS_OFFSET	((sizeof(long)-sizeof(int))*8)
+
+static void uart_change_speed(struct uart_info *info, struct termios *old_termios);
+static void uart_wait_until_sent(struct tty_struct *tty, int timeout);
+
+/*
+ * This routine is used by the interrupt handler to schedule processing in
+ * the software interrupt portion of the driver.  It is expected that
+ * interrupts will be disabled (and so the tasklet will be prevented
+ * from running (CHECK)).
+ */
+void uart_event(struct uart_info *info, int event)
+{
+	info->event |= 1 << event;
+	tasklet_schedule(&info->tlet);
+}
+
+static void uart_stop(struct tty_struct *tty)
+{
+	struct uart_info *info = tty->driver_data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&info->lock, flags);
+	info->ops->stop_tx(info->port, 1);
+	spin_unlock_irqrestore(&info->lock, flags);
+}
+
+static void __uart_start(struct tty_struct *tty)
+{
+	struct uart_info *info = tty->driver_data;
+	if (info->xmit.head != info->xmit.tail && info->xmit.buf &&
+	    !tty->stopped && !tty->hw_stopped)
+		info->ops->start_tx(info->port, 1, 1);
+}
+
+static void uart_start(struct tty_struct *tty)
+{
+	struct uart_info *info = tty->driver_data;
+	unsigned long flags;
+
+	pm_access(info->state->pm);
+
+	spin_lock_irqsave(&info->lock, flags);
+	__uart_start(tty);
+	spin_unlock_irqrestore(&info->lock, flags);
+}
+
+static void uart_tasklet_action(unsigned long data)
+{
+	struct uart_info *info = (struct uart_info *)data;
+	struct tty_struct *tty;
+
+	tty = info->tty;
+	if (!tty || !test_and_clear_bit(EVT_WRITE_WAKEUP, &info->event))
+		return;
+
+	if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
+	    tty->ldisc.write_wakeup)
+		(tty->ldisc.write_wakeup)(tty);
+	wake_up_interruptible(&tty->write_wait);
+}
+
+static inline void uart_update_altspeed(struct uart_info *info)
+{
+	if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)
+		info->tty->alt_speed = 57600;
+	if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)
+		info->tty->alt_speed = 115200;
+	if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_SHI)
+		info->tty->alt_speed = 230400;
+	if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_WARP)
+		info->tty->alt_speed = 460800;
+}
+
+static int uart_startup(struct uart_info *info)
+{
+	unsigned long flags;
+	unsigned long page;
+	int retval = 0;
+
+	page = get_zeroed_page(GFP_KERNEL);
+	if (!page)
+		return -ENOMEM;
+
+	save_flags(flags); cli();
+
+	if (info->flags & ASYNC_INITIALIZED) {
+		free_page(page);
+		goto errout;
+	}
+
+	if (info->port->type == PORT_UNKNOWN) {
+		if (info->tty)
+			set_bit(TTY_IO_ERROR, &info->tty->flags);
+		free_page(page);
+		goto errout;
+	}
+
+	if (info->xmit.buf)
+		free_page(page);
+	else
+		info->xmit.buf = (unsigned char *) page;
+
+	info->mctrl = 0;
+
+	retval = info->ops->startup(info->port, info);
+	if (retval) {
+		if (capable(CAP_SYS_ADMIN)) {
+			if (info->tty)
+				set_bit(TTY_IO_ERROR, &info->tty->flags);
+			retval = 0;
+		}
+		goto errout;
+	}
+
+	if (info->tty)
+		clear_bit(TTY_IO_ERROR, &info->tty->flags);
+	info->xmit.head = info->xmit.tail = 0;
+
+	/*
+	 * Set up the tty->alt_speed kludge
+	 */
+	if (info->tty)
+		uart_update_altspeed(info);
+
+	/*
+	 * and set the speed of the serial port
+	 */
+	uart_change_speed(info, NULL);
+
+	/*
+	 * Setup the RTS and DTR signals once the port
+	 * is open and ready to respond.
+	 */
+	if (info->tty->termios->c_cflag & CBAUD)
+		info->mctrl |= TIOCM_RTS | TIOCM_DTR;
+	info->ops->set_mctrl(info->port, info->mctrl);
+
+	info->flags |= ASYNC_INITIALIZED;
+	retval = 0;
+
+errout:
+	restore_flags(flags);
+	return retval;
+}
+
+/*
+ * This routine will shutdown a serial port; interrupts are disabled, and
+ * DTR is dropped if the hangup on close termio flag is on.
+ */
+static void uart_shutdown(struct uart_info *info)
+{
+	unsigned long flags;
+
+	if (!(info->flags & ASYNC_INITIALIZED))
+		return;
+
+	save_flags(flags); cli(); /* Disable interrupts */
+
+	/*
+	 * clear delta_msr_wait queue to avoid mem leaks: we may free the irq
+	 * here so the queue might never be woken up
+	 */
+	wake_up_interruptible(&info->delta_msr_wait);
+
+	/*
+	 * Free the IRQ and disable the port
+	 */
+	info->ops->shutdown(info->port, info);
+
+	if (info->xmit.buf) {
+		unsigned long pg = (unsigned long) info->xmit.buf;
+		info->xmit.buf = NULL;
+		free_page(pg);
+	}
+
+	if (!info->tty || (info->tty->termios->c_cflag & HUPCL))
+		info->mctrl &= ~(TIOCM_DTR|TIOCM_RTS);
+	info->ops->set_mctrl(info->port, info->mctrl);
+
+	/* kill off our tasklet */
+	tasklet_kill(&info->tlet);
+	if (info->tty)
+		set_bit(TTY_IO_ERROR, &info->tty->flags);
+
+	info->flags &= ~ASYNC_INITIALIZED;
+	restore_flags(flags);
+}
+
+static inline u_int uart_calculate_quot(struct uart_info *info, u_int baud)
+{
+	u_int quot;
+
+	/* Special case: B0 rate */
+	if (!baud)
+		baud = 9600;
+
+	/* Old HI/VHI/custom speed handling */
+	if (baud == 38400 &&
+	    ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_CUST))
+		quot = info->state->custom_divisor;
+	else
+		quot = info->port->uartclk / (16 * baud);
+
+	return quot;
+}
+
+static void uart_change_speed(struct uart_info *info, struct termios *old_termios)
+{
+	struct uart_port *port = info->port;
+	u_int quot, baud, cflag, bits, try;
+
+	/*
+	 * If we have no tty, termios, or the port does not exist,
+	 * then we can't set the parameters for this port.
+	 */
+	if (!info->tty || !info->tty->termios ||
+	    info->port->type == PORT_UNKNOWN)
+		return;
+
+	cflag = info->tty->termios->c_cflag;
+
+	/* byte size and parity */
+	switch (cflag & CSIZE) {
+	case CS5: bits = 7;  break;
+	case CS6: bits = 8;  break;
+	case CS7: bits = 9;  break;
+	default:  bits = 10; break; // CS8
+	}
+
+	if (cflag & CSTOPB)
+		bits++;
+	if (cflag & PARENB)
+		bits++;
+
+	for (try = 0; try < 2; try ++) {
+		/* Determine divisor based on baud rate */
+		baud = tty_get_baud_rate(info->tty);
+		quot = uart_calculate_quot(info, baud);
+		if (quot)
+			break;
+
+		/*
+		 * Oops, the quotient was zero.  Try again with
+		 * the old baud rate if possible.
+		 */
+		info->tty->termios->c_cflag &= ~CBAUD;
+		if (old_termios) {
+			info->tty->termios->c_cflag |=
+				 (old_termios->c_cflag & CBAUD);
+			old_termios = NULL;
+			continue;
+		}
+
+		/*
+		 * As a last resort, if the quotient is zero,
+		 * default to 9600 bps
+		 */
+		info->tty->termios->c_cflag |= B9600;
+	}
+
+	info->timeout = (port->fifosize * HZ * bits * quot) /
+			 (port->uartclk / 16);
+	info->timeout += HZ/50;		/* Add .02 seconds of slop */
+
+	if (cflag & CRTSCTS)
+		info->flags |= ASYNC_CTS_FLOW;
+	else
+		info->flags &= ~ASYNC_CTS_FLOW;
+	if (cflag & CLOCAL)
+		info->flags &= ~ASYNC_CHECK_CD;
+	else
+		info->flags |= ASYNC_CHECK_CD;
+
+	/*
+	 * Set up parity check flag
+	 */
+#define RELEVENT_IFLAG(iflag)	((iflag) & (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK))
+
+	pm_access(info->state->pm);
+
+	info->ops->change_speed(port, cflag, info->tty->termios->c_iflag, quot);
+}
+
+static void uart_put_char(struct tty_struct *tty, u_char ch)
+{
+	struct uart_info *info = tty->driver_data;
+	unsigned long flags;
+
+	if (!tty || !info->xmit.buf)
+		return;
+
+	spin_lock_irqsave(&info->lock, flags);
+	if (CIRC_SPACE(info->xmit.head, info->xmit.tail, UART_XMIT_SIZE) != 0) {
+		info->xmit.buf[info->xmit.head] = ch;
+		info->xmit.head = (info->xmit.head + 1) & (UART_XMIT_SIZE - 1);
+	}
+	spin_unlock_irqrestore(&info->lock, flags);
+}
+
+static void uart_flush_chars(struct tty_struct *tty)
+{
+	uart_start(tty);
+}
+
+static int uart_write(struct tty_struct *tty, int from_user,
+			  const u_char * buf, int count)
+{
+	struct uart_info *info = tty->driver_data;
+	unsigned long flags;
+	int c, ret = 0;
+
+	if (!tty || !info->xmit.buf || !tmp_buf)
+		return 0;
+
+	if (from_user) {
+		down(&tmp_buf_sem);
+		while (1) {
+			int c1;
+			c = CIRC_SPACE_TO_END(info->xmit.head,
+					      info->xmit.tail,
+					      UART_XMIT_SIZE);
+			if (count < c)
+				c = count;
+			if (c <= 0)
+				break;
+
+			c -= copy_from_user(tmp_buf, buf, c);
+			if (!c) {
+				if (!ret)
+					ret = -EFAULT;
+				break;
+			}
+			spin_lock_irqsave(&info->lock, flags);
+			c1 = CIRC_SPACE_TO_END(info->xmit.head,
+					       info->xmit.tail,
+					       UART_XMIT_SIZE);
+			if (c1 < c)
+				c = c1;
+			memcpy(info->xmit.buf + info->xmit.head, tmp_buf, c);
+			info->xmit.head = (info->xmit.head + c) &
+					  (UART_XMIT_SIZE - 1);
+			spin_unlock_irqrestore(&info->lock, flags);
+			buf += c;
+			count -= c;
+			ret += c;
+		}
+		up(&tmp_buf_sem);
+	} else {
+		spin_lock_irqsave(&info->lock, flags);
+		while (1) {
+			c = CIRC_SPACE_TO_END(info->xmit.head,
+					      info->xmit.tail,
+					      UART_XMIT_SIZE);
+			if (count < c)
+				c = count;
+			if (c <= 0)
+				break;
+			memcpy(info->xmit.buf + info->xmit.head, buf, c);
+			info->xmit.head = (info->xmit.head + c) &
+					  (UART_XMIT_SIZE - 1);
+			buf += c;
+			count -= c;
+			ret += c;
+		}
+		spin_unlock_irqrestore(&info->lock, flags);
+	}
+
+	uart_start(tty);
+	return ret;
+}
+
+static int uart_write_room(struct tty_struct *tty)
+{
+	struct uart_info *info = tty->driver_data;
+
+	return CIRC_SPACE(info->xmit.head, info->xmit.tail, UART_XMIT_SIZE);
+}
+
+static int uart_chars_in_buffer(struct tty_struct *tty)
+{
+	struct uart_info *info = tty->driver_data;
+
+	return CIRC_CNT(info->xmit.head, info->xmit.tail, UART_XMIT_SIZE);
+}
+
+static void uart_flush_buffer(struct tty_struct *tty)
+{
+	struct uart_info *info = tty->driver_data;
+	unsigned long flags;
+
+#ifdef DEBUG
+	printk("uart_flush_buffer(%d) called\n",
+	       MINOR(tty->device) - tty->driver.minor_start);
+#endif
+	spin_lock_irqsave(&info->lock, flags);
+	info->xmit.head = info->xmit.tail = 0;
+	spin_unlock_irqrestore(&info->lock, flags);
+	wake_up_interruptible(&tty->write_wait);
+	if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
+	    tty->ldisc.write_wakeup)
+		(tty->ldisc.write_wakeup)(tty);
+}
+
+/*
+ * This function is used to send a high-priority XON/XOFF character to
+ * the device
+ */
+static void uart_send_xchar(struct tty_struct *tty, char ch)
+{
+	struct uart_info *info = tty->driver_data;
+
+	info->port->x_char = ch;
+	if (ch)
+		info->ops->start_tx(info->port, 1, 0);
+}
+
+static void uart_throttle(struct tty_struct *tty)
+{
+	struct uart_info *info = tty->driver_data;
+	unsigned long flags;
+
+	if (I_IXOFF(tty))
+		uart_send_xchar(tty, STOP_CHAR(tty));
+
+	if (tty->termios->c_cflag & CRTSCTS) {
+		spin_lock_irqsave(&info->lock, flags);
+		info->mctrl &= ~TIOCM_RTS;
+		info->ops->set_mctrl(info->port, info->mctrl);
+		spin_unlock_irqrestore(&info->lock, flags);
+	}
+}
+
+static void uart_unthrottle(struct tty_struct *tty)
+{
+	struct uart_info *info = (struct uart_info *) tty->driver_data;
+	unsigned long flags;
+
+	if (I_IXOFF(tty)) {
+		if (info->port->x_char)
+			info->port->x_char = 0;
+		else
+			uart_send_xchar(tty, START_CHAR(tty));
+	}
+
+	if (tty->termios->c_cflag & CRTSCTS) {
+		spin_lock_irqsave(&info->lock, flags);
+		info->mctrl |= TIOCM_RTS;
+		info->ops->set_mctrl(info->port, info->mctrl);
+		spin_unlock_irqrestore(&info->lock, flags);
+	}
+}
+
+static int uart_get_info(struct uart_info *info, struct serial_struct *retinfo)
+{
+	struct uart_state *state = info->state;
+	struct uart_port *port = info->port;
+	struct serial_struct tmp;
+
+	memset(&tmp, 0, sizeof(tmp));
+	tmp.type	   = port->type;
+	tmp.line	   = port->line;
+	tmp.port	   = port->iobase;
+	if (HIGH_BITS_OFFSET)
+		tmp.port_high = port->iobase >> HIGH_BITS_OFFSET;
+	tmp.irq		   = port->irq;
+	tmp.flags	   = port->flags;
+	tmp.xmit_fifo_size = port->fifosize;
+	tmp.baud_base	   = port->uartclk / 16;
+	tmp.close_delay	   = state->close_delay;
+	tmp.closing_wait   = state->closing_wait;
+	tmp.custom_divisor = state->custom_divisor;
+	tmp.hub6	   = port->hub6;
+	tmp.io_type        = port->iotype;
+	tmp.iomem_reg_shift= port->regshift;
+	tmp.iomem_base     = (void *)port->mapbase;
+
+	if (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))
+		return -EFAULT;
+	return 0;
+}
+
+static int uart_set_info(struct uart_info *info,
+			 struct serial_struct *newinfo)
+{
+	struct serial_struct new_serial;
+	struct uart_state *state = info->state;
+	struct uart_port *port = info->port;
+	unsigned long new_port;
+	unsigned int change_irq, change_port, old_flags;
+	unsigned int old_custom_divisor;
+	int retval = 0;
+
+	if (copy_from_user(&new_serial, newinfo, sizeof(new_serial)))
+		return -EFAULT;
+
+	new_port = new_serial.port;
+	if (HIGH_BITS_OFFSET)
+		new_port += (unsigned long) new_serial.port_high << HIGH_BITS_OFFSET;
+
+	new_serial.irq = irq_cannonicalize(new_serial.irq);
+
+	/*
+	 * This semaphore protects state->count.  It is also
+	 * very useful to prevent opens.  Also, take the
+	 * port configuration semaphore to make sure that a
+	 * module insertion/removal doesn't change anything
+	 * under us.
+	 */
+	down(&port_sem);
+	down(&state->count_sem);
+
+	change_irq  = new_serial.irq != port->irq;
+
+	/*
+	 * Since changing the 'type' of the port changes its resource
+	 * allocations, we should treat type changes the same as
+	 * IO port changes.
+	 */
+	change_port = new_port != port->iobase ||
+		      (unsigned long)new_serial.iomem_base != port->mapbase ||
+		      new_serial.hub6 != port->hub6 ||
+		      new_serial.io_type != port->iotype ||
+		      new_serial.iomem_reg_shift != port->regshift ||
+		      new_serial.type != port->type;
+
+	old_flags = port->flags;
+	old_custom_divisor = state->custom_divisor;
+
+	if (!capable(CAP_SYS_ADMIN)) {
+		retval = -EPERM;
+		if (change_irq || change_port ||
+		    (new_serial.baud_base != port->uartclk / 16) ||
+		    (new_serial.close_delay != state->close_delay) ||
+		    (new_serial.closing_wait != state->closing_wait) ||
+		    (new_serial.xmit_fifo_size != port->fifosize) ||
+		    ((new_serial.flags & ~ASYNC_USR_MASK) !=
+		     (port->flags & ~ASYNC_USR_MASK)))
+			goto exit;
+		port->flags = ((port->flags & ~ASYNC_USR_MASK) |
+			       (new_serial.flags & ASYNC_USR_MASK));
+		info->flags = ((info->flags & ~ASYNC_USR_MASK) |
+			       (new_serial.flags & ASYNC_USR_MASK));
+		state->custom_divisor = new_serial.custom_divisor;
+		goto check_and_exit;
+	}
+
+	/*
+	 * Ask the low level driver to verify the settings.
+	 */
+	if (port->ops->verify_port)
+		retval = port->ops->verify_port(port, &new_serial);
+
+	if ((new_serial.irq >= NR_IRQS) || (new_serial.irq < 0) ||
+	    (new_serial.baud_base < 9600))
+		retval = -EINVAL;
+
+	if (retval)
+		goto exit;
+
+	if (change_port || change_irq) {
+		retval = -EBUSY;
+
+		/*
+		 * Make sure that we are the sole user of this port.
+		 */
+		if (state->count > 1)
+			goto exit;
+
+		/*
+		 * We need to shutdown the serial port at the old
+		 * port/type/irq combination.
+		 */
+		uart_shutdown(info);
+	}
+
+	if (change_port) {
+		unsigned long old_iobase, old_mapbase;
+		unsigned int old_type, old_iotype, old_hub6, old_shift;
+
+		old_iobase = port->iobase;
+		old_mapbase = port->mapbase;
+		old_type = port->type;
+		old_hub6 = port->hub6;
+		old_iotype = port->iotype;
+		old_shift = port->regshift;
+
+		/*
+		 * Free and release old regions
+		 */
+		if (old_type != PORT_UNKNOWN)
+			port->ops->release_port(port);
+
+		port->iobase = new_port;
+		port->type = new_serial.type;
+		port->hub6 = new_serial.hub6;
+		port->iotype = new_serial.io_type;
+		port->regshift = new_serial.iomem_reg_shift;
+		port->mapbase = (unsigned long)new_serial.iomem_base;
+
+		/*
+		 * Claim and map the new regions
+		 */
+		if (port->type != PORT_UNKNOWN)
+			retval = port->ops->request_port(port);
+
+		/*
+		 * If we fail to request resources for the
+		 * new port, try to restore the old settings.
+		 */
+		if (retval && old_type != PORT_UNKNOWN) {
+			port->iobase = old_iobase;
+			port->type = old_type;
+			port->hub6 = old_hub6;
+			port->iotype = old_iotype;
+			port->regshift = old_shift;
+			port->mapbase = old_mapbase;
+			retval = port->ops->request_port(port);
+			/*
+			 * If we failed to restore the old settings,
+			 * we fail like this.
+			 */
+			if (retval)
+				port->type = PORT_UNKNOWN;
+
+			/*
+			 * We failed anyway.
+			 */
+			retval = -EBUSY;
+		}
+	}
+
+	port->irq  = new_serial.irq;
+	port->uartclk = new_serial.baud_base * 16;
+	port->flags = ((port->flags & ~ASYNC_FLAGS) |
+			(new_serial.flags & ASYNC_FLAGS));
+	info->flags = ((port->flags & ~ASYNC_INTERNAL_FLAGS) |
+		       (info->flags & ASYNC_INTERNAL_FLAGS));
+	state->custom_divisor = new_serial.custom_divisor;
+	state->close_delay = new_serial.close_delay * HZ / 100;
+	state->closing_wait = new_serial.closing_wait * HZ / 100;
+	info->tty->low_latency = (info->flags & ASYNC_LOW_LATENCY) ? 1 : 0;
+	port->fifosize = new_serial.xmit_fifo_size;
+
+check_and_exit:
+	retval = 0;
+	if (port->type == PORT_UNKNOWN)
+		goto exit;
+	if (info->flags & ASYNC_INITIALIZED) {
+		if (((old_flags & info->flags) & ASYNC_SPD_MASK) ||
+		    old_custom_divisor != state->custom_divisor) {
+			uart_update_altspeed(info);
+			uart_change_speed(info, NULL);
+		}
+	} else
+		retval = uart_startup(info);
+exit:
+	up(&state->count_sem);
+	up(&port_sem);
+	return retval;
+}
+
+
+/*
+ * uart_get_lsr_info - get line status register info
+ */
+static int uart_get_lsr_info(struct uart_info *info, unsigned int *value)
+{
+	u_int result;
+	unsigned long flags;
+
+	spin_lock_irqsave(&info->lock, flags);
+	result = info->ops->tx_empty(info->port);
+	spin_unlock_irqrestore(&info->lock, flags);
+
+	/*
+	 * If we're about to load something into the transmit
+	 * register, we'll pretend the transmitter isn't empty to
+	 * avoid a race condition (depending on when the transmit
+	 * interrupt happens).
+	 */
+	if (info->port->x_char ||
+	    ((CIRC_CNT(info->xmit.head, info->xmit.tail,
+		       UART_XMIT_SIZE) > 0) &&
+	     !info->tty->stopped && !info->tty->hw_stopped))
+		result &= ~TIOCSER_TEMT;
+	
+	return put_user(result, value);
+}
+
+static int uart_get_modem_info(struct uart_info *info, unsigned int *value)
+{
+	unsigned int result = info->mctrl;
+
+	result |= info->ops->get_mctrl(info->port);
+
+	return put_user(result, value);
+}
+
+static int uart_set_modem_info(struct uart_info *info, unsigned int cmd,
+			  unsigned int *value)
+{
+	unsigned int arg, old;
+	int ret = 0;
+
+	if (get_user(arg, value))
+		return -EFAULT;
+
+	spin_lock_irq(&info->lock);
+	old = info->mctrl;
+	switch (cmd) {
+	case TIOCMBIS:	info->mctrl |= arg;	break;
+	case TIOCMBIC:	info->mctrl &= ~arg;	break;
+	case TIOCMSET:	info->mctrl = arg;	break;
+	default:	ret = -EINVAL;		break;
+	}
+	if (old != info->mctrl)
+		info->ops->set_mctrl(info->port, info->mctrl);
+	spin_unlock_irq(&info->lock);
+	return ret;
+}
+
+static void uart_break_ctl(struct tty_struct *tty, int break_state)
+{
+	struct uart_info *info = tty->driver_data;
+	unsigned long flags;
+
+	if (info->port->type != PORT_UNKNOWN) {
+		spin_lock_irqsave(&info->lock, flags);
+		info->ops->break_ctl(info->port, break_state);
+		spin_unlock_irqrestore(&info->lock, flags);
+	}
+}
+
+static int uart_do_autoconfig(struct uart_info *info)
+{
+	struct uart_port *port = info->port;
+	int flags, ret;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
+	/*
+	 * Take the 'count' lock.  This prevents count
+	 * from incrementing, and hence any extra opens
+	 * of the port while we're auto-configging.
+	 */
+	down(&info->state->count_sem);
+
+	ret = -EBUSY;
+	if (info->state->count == 1) {
+		uart_shutdown(info);
+
+		/*
+		 * If we already have a port type configured,
+		 * we must release its resources.
+		 */
+		if (port->type != PORT_UNKNOWN)
+			port->ops->release_port(port);
+
+		flags = UART_CONFIG_TYPE;
+		if (port->flags & ASYNC_AUTO_IRQ)
+			flags |= UART_CONFIG_IRQ;
+
+		/*
+		 * This will claim the ports resources if
+		 * a port is found.
+		 */
+		port->ops->config_port(port, flags);
+
+		ret = uart_startup(info);
+	}
+	up(&info->state->count_sem);
+	return ret;
+}
+
+/*
+ * Called from userspace.  We can use spin_lock_irq() here.
+ */
+static int uart_ioctl(struct tty_struct *tty, struct file *file,
+			   unsigned int cmd, unsigned long arg)
+{
+	struct uart_info *info = tty->driver_data;
+	struct uart_icount cprev, cnow;
+	struct serial_icounter_struct icount;
+	int ret = -ENOIOCTLCMD;
+
+	if ((cmd != TIOCGSERIAL) && (cmd != TIOCSSERIAL) &&
+	    (cmd != TIOCSERCONFIG) && (cmd != TIOCSERGSTRUCT) &&
+	    (cmd != TIOCMIWAIT) && (cmd != TIOCGICOUNT)) {
+		if (tty->flags & (1 << TTY_IO_ERROR))
+			return -EIO;
+	}
+
+	switch (cmd) {
+		case TIOCMGET:
+			ret = uart_get_modem_info(info, (unsigned int *)arg);
+			break;
+
+		case TIOCMBIS:
+		case TIOCMBIC:
+		case TIOCMSET:
+			ret = uart_set_modem_info(info, cmd,
+						  (unsigned int *)arg);
+			break;
+
+		case TIOCGSERIAL:
+			ret = uart_get_info(info, (struct serial_struct *)arg);
+			break;
+
+		case TIOCSSERIAL:
+			ret = uart_set_info(info, (struct serial_struct *)arg);
+			break;
+
+		case TIOCSERCONFIG:
+			ret = uart_do_autoconfig(info);
+			break;
+
+		case TIOCSERGETLSR: /* Get line status register */
+			ret = uart_get_lsr_info(info, (unsigned int *)arg);
+			break;
+
+		/*
+		 * Wait for any of the 4 modem inputs (DCD,RI,DSR,CTS) to change
+		 * - mask passed in arg for lines of interest
+		 *   (use |'ed TIOCM_RNG/DSR/CD/CTS for masking)
+		 * Caller should use TIOCGICOUNT to see which one it was
+		 */
+		case TIOCMIWAIT:
+			spin_lock_irq(&info->lock);
+			/* note the counters on entry */
+			cprev = info->port->icount;
+			/* Force modem status interrupts on */
+			info->ops->enable_ms(info->port);
+			spin_unlock_irq(&info->lock);
+			while (1) {
+				interruptible_sleep_on(&info->delta_msr_wait);
+				/* see if a signal did it */
+				if (signal_pending(current)) {
+					ret = -ERESTARTSYS;
+					break;
+				}
+				spin_lock_irq(&info->lock);
+				cnow = info->port->icount; /* atomic copy */
+				spin_unlock_irq(&info->lock);
+				if (cnow.rng == cprev.rng && cnow.dsr == cprev.dsr &&
+				    cnow.dcd == cprev.dcd && cnow.cts == cprev.cts) {
+				    	ret = -EIO; /* no change => error */
+				    	break;
+				}
+				if (((arg & TIOCM_RNG) && (cnow.rng != cprev.rng)) ||
+				    ((arg & TIOCM_DSR) && (cnow.dsr != cprev.dsr)) ||
+				    ((arg & TIOCM_CD)  && (cnow.dcd != cprev.dcd)) ||
+				    ((arg & TIOCM_CTS) && (cnow.cts != cprev.cts))) {
+				    	ret = 0;
+				    	break;
+				}
+				cprev = cnow;
+			}
+			break;
+
+		/*
+		 * Get counter of input serial line interrupts (DCD,RI,DSR,CTS)
+		 * Return: write counters to the user passed counter struct
+		 * NB: both 1->0 and 0->1 transitions are counted except for
+		 *     RI where only 0->1 is counted.
+		 */
+		case TIOCGICOUNT:
+			spin_lock_irq(&info->lock);
+			cnow = info->port->icount;
+			spin_unlock_irq(&info->lock);
+
+			icount.cts         = cnow.cts;
+			icount.dsr         = cnow.dsr;
+			icount.rng         = cnow.rng;
+			icount.dcd         = cnow.dcd;
+			icount.rx          = cnow.rx;
+			icount.tx          = cnow.tx;
+			icount.frame       = cnow.frame;
+			icount.overrun     = cnow.overrun;
+			icount.parity      = cnow.parity;
+			icount.brk         = cnow.brk;
+			icount.buf_overrun = cnow.buf_overrun;
+
+			ret = copy_to_user((void *)arg, &icount, sizeof(icount))
+					? -EFAULT : 0;
+			break;
+
+		case TIOCSERGWILD: /* obsolete */
+		case TIOCSERSWILD: /* obsolete */
+			ret = 0;
+			break;
+
+		default:
+			if (info->ops->ioctl)
+				ret = info->ops->ioctl(info->port, cmd, arg);
+			break;
+	}
+	return ret;
+}
+
+static void uart_set_termios(struct tty_struct *tty, struct termios *old_termios)
+{
+	struct uart_info *info = tty->driver_data;
+	unsigned long flags;
+	unsigned int cflag = tty->termios->c_cflag;
+
+	if ((cflag ^ old_termios->c_cflag) == 0 &&
+	    RELEVENT_IFLAG(tty->termios->c_iflag ^ old_termios->c_iflag) == 0)
+		return;
+
+	uart_change_speed(info, old_termios);
+
+	spin_lock_irqsave(&info->lock, flags);
+
+	/* Handle transition to B0 status */
+	if ((old_termios->c_cflag & CBAUD) && !(cflag & CBAUD)) {
+		info->mctrl &= ~(TIOCM_RTS | TIOCM_DTR);
+		info->ops->set_mctrl(info->port, info->mctrl);
+	}
+
+	/* Handle transition away from B0 status */
+	if (!(old_termios->c_cflag & CBAUD) && (cflag & CBAUD)) {
+		info->mctrl |= TIOCM_DTR;
+		if (!(cflag & CRTSCTS) ||
+		    !test_bit(TTY_THROTTLED, &tty->flags))
+			info->mctrl |= TIOCM_RTS;
+		info->ops->set_mctrl(info->port, info->mctrl);
+	}
+
+	/* Handle turning off CRTSCTS */
+	if ((old_termios->c_cflag & CRTSCTS) && !(cflag & CRTSCTS)) {
+		tty->hw_stopped = 0;
+		__uart_start(tty);
+	}
+	spin_unlock_irqrestore(&info->lock, flags);
+
+#if 0
+	/*
+	 * No need to wake up processes in open wait, since they
+	 * sample the CLOCAL flag once, and don't recheck it.
+	 * XXX  It's not clear whether the current behavior is correct
+	 * or not.  Hence, this may change.....
+	 */
+	if (!(old_termios->c_cflag & CLOCAL) &&
+	    (tty->termios->c_cflag & CLOCAL))
+		wake_up_interruptible(&info->open_wait);
+#endif
+}
+
+/*
+ * In 2.4.5, calls to this will be serialized via the BKL in
+ *  linux/drivers/char/tty_io.c:tty_release()
+ *  linux/drivers/char/tty_io.c:do_tty_handup()
+ */
+static void uart_close(struct tty_struct *tty, struct file *filp)
+{
+	struct uart_driver *drv = (struct uart_driver *)tty->driver.driver_state;
+	struct uart_info *info = tty->driver_data;
+	struct uart_state *state;
+	unsigned long flags;
+
+	if (!info)
+		return;
+
+	state = info->state;
+
+#ifdef DEBUG
+	printk("uart_close() called\n");
+#endif
+
+	/*
+	 * This is safe, as long as the BKL exists in
+	 * do_tty_hangup(), and we're protected by the BKL.
+	 */
+	if (tty_hung_up_p(filp))
+		goto done;
+
+	down(&state->count_sem);
+	spin_lock_irqsave(&info->lock, flags);
+	if ((tty->count == 1) && (state->count != 1)) {
+		/*
+		 * Uh, oh.  tty->count is 1, which means that the tty
+		 * structure will be freed.  state->count should always
+		 * be one in these conditions.  If it's greater than
+		 * one, we've got real problems, since it means the
+		 * serial port won't be shutdown.
+		 */
+		printk("uart_close: bad serial port count; tty->count is 1, "
+		       "state->count is %d\n", state->count);
+		state->count = 1;
+	}
+	if (--state->count < 0) {
+		printk("rs_close: bad serial port count for %s%d: %d\n",
+		       tty->driver.name, info->port->line, state->count);
+		state->count = 0;
+	}
+	if (state->count) {
+		spin_unlock_irqrestore(&info->lock, flags);
+		up(&state->count_sem);
+		goto done;
+	}
+	info->flags |= ASYNC_CLOSING;
+	spin_unlock_irqrestore(&info->lock, flags);
+	up(&state->count_sem);
+
+	/*
+	 * Save the termios structure, since this port may have
+	 * separate termios for callout and dialin.
+	 */
+	if (info->flags & ASYNC_NORMAL_ACTIVE)
+		info->state->normal_termios = *tty->termios;
+	if (info->flags & ASYNC_CALLOUT_ACTIVE)
+		info->state->callout_termios = *tty->termios;
+	/*
+	 * Now we wait for the transmit buffer to clear; and we notify
+	 * the line discipline to only process XON/XOFF characters.
+	 */
+	tty->closing = 1;
+	if (info->state->closing_wait != ASYNC_CLOSING_WAIT_NONE)
+		tty_wait_until_sent(tty, info->state->closing_wait);
+	/*
+	 * At this point, we stop accepting input.  To do this, we
+	 * disable the receive line status interrupts.
+	 */
+	if (info->flags & ASYNC_INITIALIZED) {
+		info->ops->stop_rx(info->port);
+		/*
+		 * Before we drop DTR, make sure the UART transmitter
+		 * has completely drained; this is especially
+		 * important if there is a transmit FIFO!
+		 */
+		uart_wait_until_sent(tty, info->timeout);
+	}
+	uart_shutdown(info);
+	if (tty->driver.flush_buffer)
+		tty->driver.flush_buffer(tty);
+	if (tty->ldisc.flush_buffer)
+		tty->ldisc.flush_buffer(tty);
+	tty->closing = 0;
+	info->event = 0;
+	info->tty = NULL;
+	if (info->blocked_open) {
+		if (info->state->close_delay) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(info->state->close_delay);
+			set_current_state(TASK_RUNNING);
+		}
+		wake_up_interruptible(&info->open_wait);
+	} else {
+#ifdef CONFIG_PM
+		/*
+		 * Put device into D3 state.
+		 */
+		pm_send(info->state->pm, PM_SUSPEND, (void *)3);
+#else
+		if (info->ops->pm)
+			info->ops->pm(info->port, 3, 0);
+#endif
+	}
+
+	info->flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CALLOUT_ACTIVE|
+			 ASYNC_CLOSING);
+	wake_up_interruptible(&info->close_wait);
+
+done:
+	if (drv->owner)
+		__MOD_DEC_USE_COUNT(drv->owner);
+}
+
+static void uart_wait_until_sent(struct tty_struct *tty, int timeout)
+{
+	struct uart_info *info = (struct uart_info *) tty->driver_data;
+	unsigned long char_time, expire;
+
+	if (info->port->type == PORT_UNKNOWN ||
+	    info->port->fifosize == 0)
+		return;
+
+	/*
+	 * Set the check interval to be 1/5 of the estimated time to
+	 * send a single character, and make it at least 1.  The check
+	 * interval should also be less than the timeout.
+	 *
+	 * Note: we have to use pretty tight timings here to satisfy
+	 * the NIST-PCTS.
+	 */
+	char_time = (info->timeout - HZ/50) / info->port->fifosize;
+	char_time = char_time / 5;
+	if (char_time == 0)
+		char_time = 1;
+	if (timeout && timeout < char_time)
+		char_time = timeout;
+	/*
+	 * If the transmitter hasn't cleared in twice the approximate
+	 * amount of time to send the entire FIFO, it probably won't
+	 * ever clear.  This assumes the UART isn't doing flow
+	 * control, which is currently the case.  Hence, if it ever
+	 * takes longer than info->timeout, this is probably due to a
+	 * UART bug of some kind.  So, we clamp the timeout parameter at
+	 * 2*info->timeout.
+	 */
+	if (!timeout || timeout > 2 * info->timeout)
+		timeout = 2 * info->timeout;
+
+	expire = jiffies + timeout;
+#ifdef DEBUG
+	printk("uart_wait_until_sent(%d), jiff=%lu, expire=%lu...\n",
+	       MINOR(tty->device) - tty->driver.minor_start, jiffies,
+	       expire);
+#endif
+	while (!info->ops->tx_empty(info->port)) {
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(char_time);
+		if (signal_pending(current))
+			break;
+		if (timeout && time_after(jiffies, expire))
+			break;
+	}
+	set_current_state(TASK_RUNNING); /* might not be needed */
+}
+
+/*
+ * This is called with the BKL in effect
+ *  linux/drivers/char/tty_io.c:do_tty_hangup()
+ */
+static void uart_hangup(struct tty_struct *tty)
+{
+	struct uart_info *info = tty->driver_data;
+	struct uart_state *state = info->state;
+
+	uart_flush_buffer(tty);
+	if (info->flags & ASYNC_CLOSING)
+		return;
+	uart_shutdown(info);
+	info->event = 0;
+	state->count = 0;
+	info->flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CALLOUT_ACTIVE);
+	info->tty = NULL;
+	wake_up_interruptible(&info->open_wait);
+}
+
+static int uart_block_til_ready(struct tty_struct *tty, struct file *filp,
+				struct uart_info *info)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	struct uart_state *state = info->state;
+	unsigned long flags;
+	int do_clocal = 0, extra_count = 0, retval;
+
+	/*
+	 * If the device is in the middle of being closed, then block
+	 * until it's done, and then try again.
+	 */
+	if (tty_hung_up_p(filp) ||
+	    (info->flags & ASYNC_CLOSING)) {
+		if (info->flags & ASYNC_CLOSING)
+			interruptible_sleep_on(&info->close_wait);
+		return (info->flags & ASYNC_HUP_NOTIFY) ?
+			-EAGAIN : -ERESTARTSYS;
+	}
+
+	/*
+	 * If this is a callout device, then just make sure the normal
+	 * device isn't being used.
+	 */
+	if (tty->driver.subtype == SERIAL_TYPE_CALLOUT) {
+		if (info->flags & ASYNC_NORMAL_ACTIVE)
+			return -EBUSY;
+		if ((info->flags & ASYNC_CALLOUT_ACTIVE) &&
+		    (info->flags & ASYNC_SESSION_LOCKOUT) &&
+		    (info->session != current->session))
+			return -EBUSY;
+		if ((info->flags & ASYNC_CALLOUT_ACTIVE) &&
+		    (info->flags & ASYNC_PGRP_LOCKOUT) &&
+		    (info->pgrp != current->pgrp))
+			return -EBUSY;
+		info->flags |= ASYNC_CALLOUT_ACTIVE;
+		return 0;
+	}
+
+	/*
+	 * If non-blocking mode is set, or the port is not enabled,
+	 * then make the check up front and then exit.  Note that
+	 * we have set TTY_IO_ERROR for a non-enabled port.
+	 */
+	if ((filp->f_flags & O_NONBLOCK) ||
+	    (tty->flags & (1 << TTY_IO_ERROR))) {
+		if (info->flags & ASYNC_CALLOUT_ACTIVE)
+			return -EBUSY;
+		info->flags |= ASYNC_NORMAL_ACTIVE;
+		return 0;
+	}
+
+	if (info->flags & ASYNC_CALLOUT_ACTIVE) {
+		if (state->normal_termios.c_cflag & CLOCAL)
+			do_clocal = 1;
+	} else {
+		if (tty->termios->c_cflag & CLOCAL)
+			do_clocal = 1;
+	}
+
+	/*
+	 * Block waiting for the carrier detect and the line to become
+	 * free (i.e., not in use by the callout).  While we are in
+	 * this loop, state->count is dropped by one, so that
+	 * rs_close() knows when to free things.  We restore it upon
+	 * exit, either normal or abnormal.
+	 */
+	retval = 0;
+	add_wait_queue(&info->open_wait, &wait);
+	down(&state->count_sem);
+	spin_lock_irqsave(&info->lock, flags);
+	if (!tty_hung_up_p(filp)) {
+		extra_count = 1;
+		state->count--;
+	}
+	spin_unlock_irqrestore(&info->lock, flags);
+	info->blocked_open++;
+	up(&state->count_sem);
+	while (1) {
+		spin_lock_irqsave(&info->lock, flags);
+		if (!(info->flags & ASYNC_CALLOUT_ACTIVE) &&
+		    (tty->termios->c_cflag & CBAUD)) {
+			info->mctrl |= TIOCM_DTR | TIOCM_RTS;
+			info->ops->set_mctrl(info->port, info->mctrl);
+		}
+		spin_unlock_irqrestore(&info->lock, flags);
+		set_current_state(TASK_INTERRUPTIBLE);
+		if (tty_hung_up_p(filp) ||
+		    !(info->flags & ASYNC_INITIALIZED)) {
+			if (info->flags & ASYNC_HUP_NOTIFY)
+				retval = -EAGAIN;
+			else
+				retval = -ERESTARTSYS;
+			break;
+		}
+		if (!(info->flags & ASYNC_CALLOUT_ACTIVE) &&
+		    !(info->flags & ASYNC_CLOSING) &&
+		    (do_clocal ||
+		     (info->ops->get_mctrl(info->port) & TIOCM_CAR)))
+			break;
+		if (signal_pending(current)) {
+			retval = -ERESTARTSYS;
+			break;
+		}
+		schedule();
+	}
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&info->open_wait, &wait);
+	down(&state->count_sem);
+	if (extra_count)
+		state->count++;
+	info->blocked_open--;
+	up(&state->count_sem);
+	if (retval)
+		return retval;
+	info->flags |= ASYNC_NORMAL_ACTIVE;
+	return 0;
+}
+
+static struct uart_info *uart_get(struct uart_driver *drv, int line)
+{
+	struct uart_state *state = drv->state + line;
+	struct uart_info *info;
+
+	down(&state->count_sem);
+	state->count++;
+	if (state->info)
+		goto out;
+
+	info = kmalloc(sizeof(struct uart_info), GFP_KERNEL);
+	if (info) {
+		memset(info, 0, sizeof(struct uart_info));
+		init_waitqueue_head(&info->open_wait);
+		init_waitqueue_head(&info->close_wait);
+		init_waitqueue_head(&info->delta_msr_wait);
+		info->port  = state->port;
+		info->flags = info->port->flags;
+		info->ops   = info->port->ops;
+		info->state = state;
+		tasklet_init(&info->tlet, uart_tasklet_action,
+			     (unsigned long)info);
+	}
+	if (state->info)
+		kfree(info);
+	else
+		state->info = info;
+out:
+	up(&state->count_sem);
+	return state->info;
+}
+
+/*
+ * Make sure we have the temporary buffer allocated.  Note
+ * that we set retval appropriately above, and we rely on
+ * this.
+ */
+static inline int uart_alloc_tmpbuf(void)
+{
+	if (!tmp_buf) {
+		unsigned long buf = get_zeroed_page(GFP_KERNEL);
+		if (!tmp_buf) {
+			if (buf)
+				tmp_buf = (u_char *)buf;
+			else
+				return -ENOMEM;
+		} else
+			free_page(buf);
+	}
+	return 0;
+}
+
+/*
+ * In 2.4.5, calls to uart_open are serialised by the BKL in
+ *   linux/fs/devices.c:chrdev_open()
+ * Note that if this fails, then uart_close() _will_ be called.
+ */
+static int uart_open(struct tty_struct *tty, struct file *filp)
+{
+	struct uart_driver *drv = (struct uart_driver *)tty->driver.driver_state;
+	struct uart_info *info;
+	int retval, line = MINOR(tty->device) - tty->driver.minor_start;
+
+#ifdef DEBUG
+	printk("uart_open(%d) called\n", line);
+#endif
+
+	retval = -ENODEV;
+	if (line >= tty->driver.num)
+		goto fail;
+
+	if (!try_inc_mod_count(drv->owner))
+		goto fail;
+
+	info = uart_get(drv, line);
+	retval = -ENOMEM;
+	if (!info)
+		goto out;
+
+	/*
+	 * Set the tty driver_data.  If we fail from this point on,
+	 * the generic tty layer will cause uart_close(), which will
+	 * decrement the module use count.
+	 */
+	tty->driver_data = info;
+	info->tty = tty;
+	info->tty->low_latency = (info->flags & ASYNC_LOW_LATENCY) ? 1 : 0;
+
+	if (uart_alloc_tmpbuf())
+		goto fail;
+
+	/*
+	 * If the port is in the middle of closing, bail out now.
+	 */
+	if (tty_hung_up_p(filp) ||
+	    (info->flags & ASYNC_CLOSING)) {
+		if (info->flags & ASYNC_CLOSING)
+			interruptible_sleep_on(&info->close_wait);
+		retval = (info->flags & ASYNC_HUP_NOTIFY) ?
+			-EAGAIN : -ERESTARTSYS;
+		goto fail;
+	}
+
+	/*
+	 * Make sure the device is in D0 state.
+	 */
+	if (info->state->count == 1)
+#ifdef CONFIG_PM
+		pm_send(info->state->pm, PM_RESUME, (void *)0);
+#else
+		if (info->ops->pm)
+			info->ops->pm(info->port, 0, 3);
+#endif
+
+	/*
+	 * Start up the serial port
+	 */
+	retval = uart_startup(info);
+	if (retval)
+		goto fail;
+
+	retval = uart_block_til_ready(tty, filp, info);
+	if (retval)
+		goto fail;
+
+	if (info->state->count == 1) {
+		int changed_termios = 0;
+
+		if (info->flags & ASYNC_SPLIT_TERMIOS) {
+			if (tty->driver.subtype == SERIAL_TYPE_NORMAL)
+				*tty->termios = info->state->normal_termios;
+			else
+				*tty->termios = info->state->callout_termios;
+			changed_termios = 1;
+		}
+
+#ifdef CONFIG_SERIAL_CORE_CONSOLE
+		/*
+		 * Copy across the serial console cflag setting
+		 */
+		{
+			struct console *c = drv->cons;
+			if (c && c->cflag && c->index == line) {
+				tty->termios->c_cflag = c->cflag;
+				c->cflag = 0;
+				changed_termios = 1;
+			}
+		}
+#endif
+		if (changed_termios)
+			uart_change_speed(info, NULL);
+	}
+
+	info->session = current->session;
+	info->pgrp = current->pgrp;
+	return 0;
+
+out:
+	if (drv->owner)
+		__MOD_DEC_USE_COUNT(drv->owner);
+fail:
+	return retval;
+}
+
+#ifdef CONFIG_PROC_FS
+
+static const char *uart_type(struct uart_port *port)
+{
+	const char *str = NULL;
+
+	if (port->ops->type)
+		str = port->ops->type(port);
+
+	if (!str)
+		str = "unknown";
+
+	return str;
+}
+
+static int uart_line_info(char *buf, struct uart_driver *drv, int i)
+{
+	struct uart_state *state = drv->state + i;
+	struct uart_port *port = state->port;
+	char stat_buf[32];
+	u_int status;
+	int ret;
+
+	ret = sprintf(buf, "%d: uart:%s port:%08X irq:%d",
+			port->line, uart_type(port),
+			port->iobase, port->irq);
+
+	if (port->type == PORT_UNKNOWN) {
+		strcat(buf, "\n");
+		return ret + 1;
+	}
+
+	status = port->ops->get_mctrl(port);
+
+	ret += sprintf(buf + ret, " tx:%d rx:%d",
+			port->icount.tx, port->icount.rx);
+	if (port->icount.frame)
+		ret += sprintf(buf + ret, " fe:%d",
+			port->icount.frame);
+	if (port->icount.parity)
+		ret += sprintf(buf + ret, " pe:%d",
+			port->icount.parity);
+	if (port->icount.brk)
+		ret += sprintf(buf + ret, " brk:%d",
+			port->icount.brk);
+	if (port->icount.overrun)
+		ret += sprintf(buf + ret, " oe:%d",
+			port->icount.overrun);
+
+#define INFOBIT(bit,str) \
+	if (state->info && state->info->mctrl & (bit)) \
+		strcat(stat_buf, (str))
+#define STATBIT(bit,str) \
+	if (status & (bit)) \
+		strcat(stat_buf, (str))
+
+	stat_buf[0] = '\0';
+	stat_buf[1] = '\0';
+	INFOBIT(TIOCM_RTS, "|RTS");
+	STATBIT(TIOCM_CTS, "|CTS");
+	INFOBIT(TIOCM_DTR, "|DTR");
+	STATBIT(TIOCM_DSR, "|DSR");
+	STATBIT(TIOCM_CAR, "|CD");
+	STATBIT(TIOCM_RNG, "|RI");
+	if (stat_buf[0])
+		stat_buf[0] = ' ';
+	strcat(stat_buf, "\n");
+
+	ret += sprintf(buf + ret, stat_buf);
+	return ret;
+}
+
+static int uart_read_proc(char *page, char **start, off_t off,
+			  int count, int *eof, void *data)
+{
+	struct tty_driver *ttydrv = data;
+	struct uart_driver *drv = ttydrv->driver_state;
+	int i, len = 0, l;
+	off_t begin = 0;
+
+	len += sprintf(page, "serinfo:1.0 driver%s%s revision:%s\n",
+			"", "", "");
+	for (i = 0; i < drv->nr && len < PAGE_SIZE - 96; i++) {
+		l = uart_line_info(page + len, drv, i);
+		len += l;
+		if (len + begin > off + count)
+			goto done;
+		if (len + begin < off) {
+			begin += len;
+			len = 0;
+		}
+	}
+	*eof = 1;
+done:
+	if (off >= len + begin)
+		return 0;
+	*start = page + (off - begin);
+	return (count < begin + len - off) ? count : (begin + len - off);
+}
+#endif
+
+#ifdef CONFIG_SERIAL_CORE_CONSOLE
+/*
+ *	Check whether an invalid uart number has been specified, and
+ *	if so, search for the first available port that does have
+ *	console support.
+ */
+struct uart_port * __init
+uart_get_console(struct uart_port *ports, int nr, struct console *co)
+{
+	int idx = co->index;
+
+	if (idx < 0 || idx >= nr || (ports[idx].iobase == 0 &&
+				     ports[idx].membase == NULL))
+		for (idx = 0; idx < nr; idx++)
+			if (ports[idx].iobase != 0 ||
+			    ports[idx].membase != NULL)
+				break;
+
+	co->index = idx;
+
+	return ports + idx;
+}
+
+/**
+ *	uart_parse_options - Parse serial port baud/parity/bits/flow contro.
+ *	@options: pointer to option string
+ *	@baud: pointer to an 'int' variable for the baud rate.
+ *	@parity: pointer to an 'int' variable for the parity.
+ *	@bits: pointer to an 'int' variable for the number of data bits.
+ *	@flow: pointer to an 'int' variable for the flow control character.
+ *
+ *	uart_parse_options decodes a string containing the serial console
+ *	options.  The format of the string is <baud><parity><bits><flow>,
+ *	eg: 115200n8r
+ */
+void __init
+uart_parse_options(char *options, int *baud, int *parity, int *bits, int *flow)
+{
+	char *s = options;
+
+	*baud = simple_strtoul(s, NULL, 10);
+	while (*s >= '0' && *s <= '9')
+		s++;
+	if (*s)
+		*parity = *s++;
+	if (*s)
+		*bits = *s++ - '0';
+	if (*s)
+		*flow = *s;
+}
+
+/**
+ *	uart_set_options - setup the serial console parameters
+ *	@port: pointer to the serial ports uart_port structure
+ *	@co: console pointer
+ *	@baud: baud rate
+ *	@parity: parity character - 'n' (none), 'o' (odd), 'e' (even)
+ *	@bits: number of data bits
+ *	@flow: flow control character - 'r' (rts)
+ */
+int __init
+uart_set_options(struct uart_port *port, struct console *co,
+		 int baud, int parity, int bits, int flow)
+{
+	u_int cflag = CREAD | HUPCL | CLOCAL;
+	u_int quot;
+
+	/*
+	 * Construct a cflag setting.
+	 */
+	switch (baud) {
+	case 1200:	cflag |= B1200;			break;
+	case 2400:	cflag |= B2400;			break;
+	case 4800:	cflag |= B4800;			break;
+	case 9600:	cflag |= B9600;			break;
+	case 19200:	cflag |= B19200;		break;
+//	default:	cflag |= B38400;  baud = 38400;	break;
+	default:	cflag |= B115200;  baud = 115200;	break;
+	case 57600:	cflag |= B57600;		break;
+	case 115200:	cflag |= B115200;		break;
+	case 230400:	cflag |= B230400;		break;
+	case 460800:	cflag |= B460800;		break;
+	}
+
+	if (bits == 7)
+		cflag |= CS7;
+	else
+		cflag |= CS8;
+
+	switch (parity) {
+	case 'o': case 'O':
+		cflag |= PARODD;
+		/*fall through*/
+	case 'e': case 'E':
+		cflag |= PARENB;
+		break;
+	}
+
+	co->cflag = cflag;
+	quot = (port->uartclk / (16 * baud));
+	port->ops->change_speed(port, cflag, 0, quot);
+
+	return 0;
+}
+
+extern void ambauart_console_init(void);
+extern void anakin_console_init(void);
+extern void clps711xuart_console_init(void);
+extern void rs285_console_init(void);
+extern void sa1100_rs_console_init(void);
+extern void serial8250_console_init(void);
+extern void s3c44b0x_console_init(void);
+
+/*
+ * Central "initialise all serial consoles" container.  Needs to be killed.
+ */
+void __init uart_console_init(void)
+{
+#ifdef CONFIG_SERIAL_AMBA_CONSOLE
+	ambauart_console_init();
+#endif
+#ifdef CONFIG_SERIAL_ANAKIN_CONSOLE
+	anakin_console_init();
+#endif
+#ifdef CONFIG_SERIAL_CLPS711X_CONSOLE
+	clps711xuart_console_init();
+#endif
+#ifdef CONFIG_SERIAL_21285_CONSOLE
+	rs285_console_init();
+#endif
+#ifdef CONFIG_SERIAL_SA1100_CONSOLE
+	sa1100_rs_console_init();
+#endif
+#ifdef CONFIG_SERIAL_8250_CONSOLE
+	serial8250_console_init();
+#endif
+#ifdef CONFIG_SERIAL_UART00_CONSOLE
+	uart00_console_init();
+#endif
+#ifdef CONFIG_SERIAL_S3C44B0X_CONSOLE
+	s3c44b0x_console_init();
+#endif
+}
+#endif /* CONFIG_SERIAL_CORE_CONSOLE */
+
+#ifdef CONFIG_PM
+/*
+ *  Serial port power management.
+ *
+ * This is pretty coarse at the moment - either all on or all off.  We
+ * should probably some day do finer power management here some day.
+ *
+ * We don't actually save any state; the serial driver has enough
+ * state held internally to re-setup the port when we come out of D3.
+ */
+static int uart_pm_set_state(struct uart_state *state, int pm_state, int oldstate)
+{
+	struct uart_port *port = state->port;
+	struct uart_ops *ops = port->ops;
+	int running = state->info &&
+		      state->info->flags & ASYNC_INITIALIZED;
+
+	if (port->type == PORT_UNKNOWN)
+		return 0;
+
+//printk("pm: %08x: %d -> %d, %srunning\n", port->iobase, dev->state, pm_state, running ? "" : "not ");
+	if (pm_state == 0) {
+		if (ops->pm)
+			ops->pm(port, pm_state, oldstate);
+		if (running) {
+			ops->set_mctrl(port, 0);
+			ops->startup(port, state->info);
+			uart_change_speed(state->info, NULL);
+			ops->set_mctrl(port, state->info->mctrl);
+			ops->start_tx(port, 1, 0);
+		}
+
+		/*
+		 * Re-enable the console device after suspending.
+		 */
+		if (state->cons && state->cons->index == port->line)
+			state->cons->flags |= CON_ENABLED;
+	} else if (pm_state == 1) {
+		if (ops->pm)
+			ops->pm(port, pm_state, oldstate);
+	} else {
+		/*
+		 * Disable the console device before suspending.
+		 */
+		if (state->cons && state->cons->index == port->line)
+			state->cons->flags &= ~CON_ENABLED;
+
+		if (running) {
+			ops->stop_tx(port, 0);
+			ops->set_mctrl(port, 0);
+			ops->stop_rx(port);
+			ops->shutdown(port, state->info);
+		}
+		if (ops->pm)
+			ops->pm(port, pm_state, oldstate);
+	}
+	return 0;
+}
+
+/*
+ *  Wakeup support.
+ */
+static int uart_pm_set_wakeup(struct uart_state *state, int data)
+{
+	int err = 0;
+
+	if (state->port->ops->set_wake)
+		err = state->port->ops->set_wake(state->port, data);
+
+	return err;
+}
+
+static int uart_pm(struct pm_dev *dev, pm_request_t rqst, void *data)
+{
+	struct uart_state *state = dev->data;
+	int err = 0;
+
+	switch (rqst) {
+	case PM_SUSPEND:
+	case PM_RESUME:
+		err = uart_pm_set_state(state, (int)data, dev->state);
+		break;
+
+	case PM_SET_WAKEUP:
+		err = uart_pm_set_wakeup(state, (int)data);
+		break;
+	}
+	return err;
+}
+#endif
+
+static inline void
+uart_report_port(struct uart_driver *drv, struct uart_port *port)
+{
+	printk("%s%d at ", drv->normal_name, port->line);
+	switch (port->iotype) {
+	case SERIAL_IO_PORT:
+		printk("I/O 0x%x", port->iobase);
+		break;
+	case SERIAL_IO_HUB6:
+		printk("I/O 0x%x offset 0x%x", port->iobase, port->hub6);
+		break;
+	case SERIAL_IO_MEM:
+		printk("MEM 0x%lx", port->mapbase);
+		break;
+	}
+	printk(" (irq = %d) is a %s\n", port->irq, uart_type(port));
+}
+
+static void
+uart_setup_port(struct uart_driver *drv, struct uart_state *state)
+{
+	struct uart_port *port = state->port;
+	int flags = UART_CONFIG_TYPE;
+
+	init_MUTEX(&state->count_sem);
+
+	state->close_delay	= 5 * HZ / 10;
+	state->closing_wait	= 30 * HZ;
+
+	port->type = PORT_UNKNOWN;
+
+#ifdef CONFIG_PM
+	state->cons = drv->cons;
+	state->pm = pm_register(PM_SYS_DEV, PM_SYS_COM, uart_pm);
+	if (state->pm)
+		state->pm->data = state;
+#endif
+
+	/*
+	 * If there isn't a port here, don't do anything further.
+	 */
+	if (!port->iobase && !port->mapbase)
+		return;
+
+	/*
+	 * Now do the auto configuration stuff.  Note that config_port
+	 * is expected to claim the resources and map the port for us.
+	 */
+	if (port->flags & ASYNC_AUTO_IRQ)
+		flags |= UART_CONFIG_IRQ;
+	if (port->flags & ASYNC_BOOT_AUTOCONF)
+		port->ops->config_port(port, flags);
+
+	/*
+	 * Only register this port if it is detected.
+	 */
+	if (port->type != PORT_UNKNOWN) {
+		tty_register_devfs(drv->normal_driver, 0, drv->minor +
+					state->port->line);
+		tty_register_devfs(drv->callout_driver, 0, drv->minor +
+					state->port->line);
+		uart_report_port(drv, port);
+	}
+
+#ifdef CONFIG_PM
+	/*
+	 * Power down all ports by default, except the console if we have one.
+	 */
+	if (state->pm && (!drv->cons || port->line != drv->cons->index))
+		pm_send(state->pm, PM_SUSPEND, (void *)3);
+#endif
+}
+
+/*
+ * Register a set of ports with the core driver.  Note that we don't
+ * printk any information about the ports; that is up to the low level
+ * driver to do if they so wish.
+ */
+int uart_register_driver(struct uart_driver *drv)
+{
+	struct tty_driver *normal, *callout;
+	int i, retval;
+
+	if (drv->state)
+		panic("drv->state already allocated\n");
+
+	/*
+	 * Maybe we should be using a slab cache for this, especially if
+	 * we have a large number of ports to handle.  Note that we also
+	 * allocate space for an integer for reference counting.
+	 */
+	drv->state = kmalloc(sizeof(struct uart_state) * drv->nr +
+			     sizeof(int), GFP_KERNEL);
+	retval = -ENOMEM;
+	if (!drv->state)
+		goto out;
+
+	memset(drv->state, 0, sizeof(struct uart_state) * drv->nr +
+			sizeof(int));
+
+	normal  = drv->normal_driver;
+	callout = drv->callout_driver;
+
+	normal->magic		= TTY_DRIVER_MAGIC;
+	normal->driver_name	= drv->normal_name;
+	normal->name		= drv->normal_name;
+	normal->major		= drv->normal_major;
+	normal->minor_start	= drv->minor;
+	normal->num		= drv->nr;
+	normal->type		= TTY_DRIVER_TYPE_SERIAL;
+	normal->subtype		= SERIAL_TYPE_NORMAL;
+	normal->init_termios	= tty_std_termios;
+	normal->init_termios.c_cflag = B115200 | CS8 | CREAD | HUPCL | CLOCAL;
+//	normal->init_termios.c_cflag = B38400 | CS8 | CREAD | HUPCL | CLOCAL;
+	normal->flags		= TTY_DRIVER_REAL_RAW | TTY_DRIVER_NO_DEVFS;
+	normal->refcount	= (int *)(drv->state + drv->nr);
+	normal->table		= drv->table;
+	normal->termios		= drv->termios;
+	normal->termios_locked	= drv->termios_locked;
+	normal->driver_state    = drv;
+
+	normal->open		= uart_open;
+	normal->close		= uart_close;
+	normal->write		= uart_write;
+	normal->put_char	= uart_put_char;
+	normal->flush_chars	= uart_flush_chars;
+	normal->write_room	= uart_write_room;
+	normal->chars_in_buffer	= uart_chars_in_buffer;
+	normal->flush_buffer	= uart_flush_buffer;
+	normal->ioctl		= uart_ioctl;
+	normal->throttle	= uart_throttle;
+	normal->unthrottle	= uart_unthrottle;
+	normal->send_xchar	= uart_send_xchar;
+	normal->set_termios	= uart_set_termios;
+	normal->stop		= uart_stop;
+	normal->start		= uart_start;
+	normal->hangup		= uart_hangup;
+	normal->break_ctl	= uart_break_ctl;
+	normal->wait_until_sent	= uart_wait_until_sent;
+#ifdef CONFIG_PROC_FS
+	normal->read_proc	= uart_read_proc;
+#endif
+
+	/*
+	 * The callout device is just like the normal device except for
+	 * the major number and the subtype code.
+	 */
+	*callout		= *normal;
+	callout->name		= drv->callout_name;
+	callout->major		= drv->callout_major;
+	callout->subtype	= SERIAL_TYPE_CALLOUT;
+	callout->read_proc	= NULL;
+	callout->proc_entry	= NULL;
+
+	for (i = 0; i < drv->nr; i++) {
+		struct uart_state *state = drv->state + i;
+
+		state->callout_termios	= callout->init_termios;
+		state->normal_termios	= normal->init_termios;
+		state->port		= drv->port + i;
+		state->port->line	= i;
+
+		uart_setup_port(drv, state);
+	}
+
+	retval = tty_register_driver(normal);
+	if (retval)
+		goto out;
+
+	retval = tty_register_driver(callout);
+	if (retval)
+		tty_unregister_driver(normal);
+
+out:
+	if (retval && drv->state)
+		kfree(drv->state);
+	return retval;
+}
+
+void uart_unregister_driver(struct uart_driver *drv)
+{
+	int i;
+
+	for (i = 0; i < drv->nr; i++) {
+		struct uart_state *state = drv->state + i;
+
+		if (state->info && state->info->tty)
+			tty_hangup(state->info->tty);
+
+		pm_unregister(state->pm);
+
+		if (state->port->type != PORT_UNKNOWN)
+			state->port->ops->release_port(state->port);
+		if (state->info) {
+			tasklet_kill(&state->info->tlet);
+			kfree(state->info);
+		}
+	}
+
+	tty_unregister_driver(drv->normal_driver);
+	tty_unregister_driver(drv->callout_driver);
+
+	kfree(drv->state);
+}
+
+static int uart_match_port(struct uart_port *port1, struct uart_port *port2)
+{
+	if (port1->iotype != port2->iotype)
+		return 0;
+	switch (port1->iotype) {
+	case SERIAL_IO_PORT:	return (port1->iobase == port2->iobase);
+	case SERIAL_IO_MEM:	return (port1->membase == port2->membase);
+	}
+	return 0;
+}
+
+/**
+ *	uart_register_port: register a port with the generic uart driver
+ *	@reg: pointer to the uart low level driver structure for this port
+ *	@port: uart port structure describing the port
+ *
+ *	Register a UART with the specified low level driver.  Detect the
+ *	type of the port if ASYNC_BOOT_AUTOCONF is set, and detect the IRQ
+ *	if ASYNC_AUTO_IRQ is set.
+ *
+ *	Returns negative error, or positive line number.
+ */
+int uart_register_port(struct uart_driver *drv, struct uart_port *port)
+{
+	struct uart_state *state = NULL;
+	int i, flags = UART_CONFIG_TYPE;
+
+	/*
+	 * First, find a port entry which matches.  Note: if we do
+	 * find a matching entry, and it has a non-zero use count,
+	 * then we can't register the port.
+	 */
+	down(&port_sem);
+	for (i = 0; i < drv->nr; i++) {
+		if (uart_match_port(drv->state[i].port, port)) {
+			down(&drv->state[i].count_sem);
+			state = &drv->state[i];
+			break;
+		}
+	}
+
+	/*
+	 * If we didn't find a matching entry, look for the first
+	 * free entry.  We look for one which hasn't been previously
+	 * used (indicated by zero iobase).
+	 */
+	if (!state) {
+		for (i = 0; i < drv->nr; i++) {
+			if (drv->state[i].port->type == PORT_UNKNOWN &&
+			    drv->state[i].port->iobase == 0) {
+				down(&drv->state[i].count_sem);
+				if (drv->state[i].count == 0) {
+					state = &drv->state[i];
+					break;
+				}
+			}
+		}
+	}
+
+	/*
+	 * Ok, that also failed.  Find the first unused entry, which
+	 * may be previously in use.
+	 */
+	if (!state) {
+		for (i = 0; i < drv->nr; i++) {
+			if (drv->state[i].port->type == PORT_UNKNOWN) {
+				down(&drv->state[i].count_sem);
+				if (drv->state[i].count == 0) {
+					state = &drv->state[i];
+					break;
+				}
+			}
+		}
+	}
+
+	up(&port_sem);
+
+	if (!state)
+		return -ENOSPC;
+
+	/*
+	 * If we find a port that matches this one, and it appears to
+	 * be in-use (even if it doesn't have a type) we shouldn't alter
+	 * it underneath itself - the port may be open and trying to do
+	 * useful work.
+	 */
+	if (state->count != 0 ||
+	    (state->info && state->info->blocked_open != 0)) {
+		up(&state->count_sem);
+		return -EBUSY;
+	}
+
+	/*
+	 * We're holding the lock for this port.  Copy the relevant data
+	 * into the port structure.
+	 */
+	state->port->iobase   = port->iobase;
+	state->port->membase  = port->membase;
+	state->port->irq      = port->irq;
+	state->port->uartclk  = port->uartclk;
+	state->port->fifosize = port->fifosize;
+	state->port->regshift = port->regshift;
+	state->port->iotype   = port->iotype;
+	state->port->flags    = port->flags;
+
+#if 0 //def CONFIG_PM
+	/* we have already registered the power management handlers */
+	state->pm = pm_register(PM_SYS_DEV, PM_SYS_COM, uart_pm);
+	if (state->pm) {
+		state->pm->data = state;
+
+		/*
+		 * Power down all ports by default, except
+		 * the console if we have one.
+		 */
+		if (!drv->cons || state->port->line != drv->cons->index)
+			pm_send(state->pm, PM_SUSPEND, (void *)3);
+	}
+#endif
+
+	if (state->port->flags & ASYNC_AUTO_IRQ)
+		flags |= UART_CONFIG_IRQ;
+	if (state->port->flags & ASYNC_BOOT_AUTOCONF)
+		state->port->ops->config_port(state->port, flags);
+
+	tty_register_devfs(drv->normal_driver, 0, drv->minor +
+					state->port->line);
+	tty_register_devfs(drv->callout_driver, 0, drv->minor +
+					state->port->line);
+
+	uart_report_port(drv, state->port);
+
+	up(&state->count_sem);
+	return i;
+}
+
+/*
+ * Unregister the specified port index on the specified driver.
+ */
+void uart_unregister_port(struct uart_driver *drv, int line)
+{
+	struct uart_state *state;
+
+	if (line < 0 || line >= drv->nr) {
+		printk(KERN_ERR "Attempt to unregister %s%d\n",
+			drv->normal_name, line);
+		return;
+	}
+
+	state = drv->state + line;
+
+	down(&state->count_sem);
+	/*
+	 * The port has already gone.  We have to hang up the line
+	 * to kill all usage of this port.
+	 */
+	if (state->info && state->info->tty)
+		tty_hangup(state->info->tty);
+
+	/*
+	 * Free the ports resources, if any.
+	 */
+	state->port->ops->release_port(state->port);
+
+	/*
+	 * Indicate that there isn't a port here anymore.
+	 */
+	state->port->type = PORT_UNKNOWN;
+
+#if 0 // not yet
+	/*
+	 * No point in doing power management for hardware that
+	 * isn't present.
+	 */
+	pm_unregister(state->pm);
+#endif
+
+	/*
+	 * Remove the devices from devfs
+	 */
+	tty_unregister_devfs(drv->normal_driver, drv->minor + line);
+	tty_unregister_devfs(drv->callout_driver, drv->minor + line);
+	up(&state->count_sem);
+}
+
+EXPORT_SYMBOL(uart_event);
+EXPORT_SYMBOL(uart_register_driver);
+EXPORT_SYMBOL(uart_unregister_driver);
+EXPORT_SYMBOL(uart_register_port);
+EXPORT_SYMBOL(uart_unregister_port);
+
+static int __init uart_init(void)
+{
+	return 0;
+}
+
+static void __exit uart_exit(void)
+{
+	free_page((unsigned long)tmp_buf);
+	tmp_buf = NULL;
+}
+
+module_init(uart_init);
+module_exit(uart_exit);
+
+MODULE_DESCRIPTION("Serial driver core");
+MODULE_LICENSE("GPL");
diff -urN uClinux-dist/linux-2.4.x/drivers/serial/serial_s3c44b0x.c linux-2.4.x/drivers/serial/serial_s3c44b0x.c
--- uClinux-dist/linux-2.4.x/drivers/serial/serial_s3c44b0x.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.4.x/drivers/serial/serial_s3c44b0x.c	2004-04-11 15:41:55.000000000 +0800
@@ -0,0 +1,638 @@
+/*
+ *  linux/drivers/char/serial_s3c44b0.c
+ *
+ *  Driver for S3C44B0 serial ports
+ *
+ *  Based on drivers/char/serial.c, by Linus Torvalds, Theodore Ts'o.
+ *
+ *  Copyright 1999 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *  $Id: s3c44b0.c,v 1.9.2.1 2001/11/27 17:35:39 rmk Exp $
+ *
+ * This is a generic driver for ARM S3C44B0-type serial ports.  They
+ * have a lot of 16550-like features, but are not register compatable.
+ * Note that although they do have CTS, DCD and DSR inputs, they do
+ * not have an RI input, nor do they have DTR or RTS outputs.  If
+ * required, these have to be supplied via some other means (eg, GPIO)
+ * and hooked into this driver.
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/major.h>
+#include <linux/string.h>
+#include <linux/fcntl.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/circ_buf.h>
+#include <linux/serial.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <asm/bitops.h>
+
+#if defined(CONFIG_SERIAL_S3C44B0X_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
+#include <linux/serial_core.h>
+#include "hardware.h" //<asm/hardware.h>
+
+#define UART_NR		2
+
+#define SERIAL_S3C44B0_MAJOR	4
+#define SERIAL_S3C44B0_MINOR	64
+#define SERIAL_S3C44B0_NR	UART_NR
+
+#define CALLOUT_S3C44B0_NAME	"cua"
+#define CALLOUT_S3C44B0_MAJOR	5
+#define CALLOUT_S3C44B0_MINOR	64
+#define CALLOUT_S3C44B0_NR	UART_NR
+
+static struct tty_driver normal, callout;
+static struct tty_struct *s3c44b0_table[UART_NR];
+static struct termios *s3c44b0_termios[UART_NR], *s3c44b0_termios_locked[UART_NR];
+#ifdef SUPPORT_SYSRQ
+static struct console s3c44b0_console;
+#endif
+
+
+/*
+ * Access macros for the S3C44B0 UARTs
+ */
+#define UFSTAT		((port)->iobase + (void *)&UFSTAT0 - (void *)&ULCON0)
+#define UERSTAT		((port)->iobase + (void *)&UERSTAT0 - (void *)&ULCON0)
+#define UMSTAT		((port)->iobase + (void *)&UMSTAT0 - (void *)&ULCON0)
+#define URXH		((port)->iobase + (void *)&URXH0 - (void *)&ULCON0)
+#define UTXH		((port)->iobase + (void *)&UTXH0 - (void *)&ULCON0)
+#define UMCON		((port)->iobase + (void *)&UMCON0 - (void *)&ULCON0)
+#define UCON		((port)->iobase + (void *)&UCON0 - (void *)&ULCON0)
+#define ULCON		((port)->iobase + (void *)&ULCON0 - (void *)&ULCON0)
+#define UFCON		((port)->iobase + (void *)&UFCON0 - (void *)&ULCON0)
+#define UBRDIV		((port)->iobase + (void *)&UBRDIV0 - (void *)&ULCON0)
+
+#define RFCNT_MASK	0x0f
+#define TFCNT_MASK	0xf0
+#define TFULL		0x200
+
+#define UART_OE		1
+#define UART_PE		2
+#define UART_FE		3
+#define UART_BE		4
+#define UART_ANY_ERR	(UART_OE|UART_PE|UART_FE)
+
+#define UART_RTS	1
+#define UART_CTS	1
+#define UCON_BRK	0x10
+
+#define ULCON_CS5	0
+#define ULCON_CS6	1
+#define ULCON_CS7	2
+#define ULCON_CS8	3
+#define ULCON_STOPB	4
+#define ULCON_PARITY	0x20
+#define ULCON_PEVEN	0x08
+
+
+static void s3c44b0uart_stop_tx(struct uart_port *port, u_int from_tty)
+{
+	outl(0x85, UCON);
+	INT_DISABLE(port->irq);
+}
+
+static void s3c44b0uart_start_tx(struct uart_port *port, u_int nonempty, u_int from_tty)
+{
+	if(nonempty){
+		outl(0x285, UCON);
+		INT_ENABLE(port->irq);
+	}
+}
+
+static void s3c44b0uart_stop_rx(struct uart_port *port)
+{
+	INT_DISABLE(port->irq+4);
+}
+
+static void s3c44b0uart_enable_ms(struct uart_port *port)
+{
+}
+
+static void
+s3c44b0uart_rx_int(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct uart_info *info = dev_id;
+	struct tty_struct *tty = info->tty;
+	unsigned int status, uer, ch, flg, ignored = 0;
+	struct uart_port *port = info->port;
+	
+	status = inl(UFSTAT);
+	while(status&RFCNT_MASK){
+		uer = inl(UERSTAT);
+		ch = inb(URXH);
+
+		if(tty->flip.count >= TTY_FLIPBUF_SIZE)
+			goto ignore_char;
+		port->icount.rx++;
+
+		flg = TTY_NORMAL;
+
+		if(uer&UART_ANY_ERR)
+			goto handle_error;
+		if(uart_handle_sysrq_char(info, ch, regs))
+			goto ignore_char;
+
+	error_return:
+		*tty->flip.flag_buf_ptr++ = flg;
+		*tty->flip.char_buf_ptr++ = ch;
+		tty->flip.count++;
+	ignore_char:
+		status = inl(UFSTAT);
+	}
+out:
+	tty_flip_buffer_push(tty);
+	return;
+
+handle_error:
+	if(uer&UART_PE)
+		port->icount.parity++;
+	else if(uer&UART_FE)
+		port->icount.frame++;
+	if(uer&UART_OE)
+		port->icount.overrun++;
+
+	if(uer&port->ignore_status_mask){
+		if( ++ignored > 100)
+			goto out;
+		goto ignore_char;
+	}
+	uer &= port->read_status_mask;
+
+	if(uer&UART_PE)
+		flg = TTY_PARITY;
+	else if(uer&UART_FE)
+		flg = TTY_FRAME;
+
+        if (uer&UART_OE) {
+		/*
+		 * CHECK: does overrun affect the current character?
+		 * ASSUMPTION: it does not.
+		 */
+                *tty->flip.flag_buf_ptr++ = flg;
+                *tty->flip.char_buf_ptr++ = ch;
+                tty->flip.count++;
+                if (tty->flip.count >= TTY_FLIPBUF_SIZE)
+                        goto ignore_char;
+                ch = 0;
+                flg = TTY_OVERRUN;
+        }
+#ifdef SUPPORT_SYSRQ
+        info->sysrq = 0;
+#endif
+        goto error_return;
+
+}
+
+static void s3c44b0uart_tx_int(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct uart_info *info = dev_id;
+	struct uart_port *port = info->port;
+
+	if (port->x_char) {
+		outb(port->x_char, UTXH);
+		port->icount.tx++;
+		port->x_char = 0;
+		return;
+	}
+	if (info->xmit.head == info->xmit.tail
+	    || info->tty->stopped
+	    || info->tty->hw_stopped) {
+		s3c44b0uart_stop_tx(port, 0);
+		return;
+	}
+
+	while(!(inl(UFSTAT)&TFULL)){
+		outb(info->xmit.buf[info->xmit.tail], UTXH);
+		info->xmit.tail = (info->xmit.tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+		if (info->xmit.head == info->xmit.tail)
+			break;
+	};
+
+	if (CIRC_CNT(info->xmit.head,
+		     info->xmit.tail,
+		     UART_XMIT_SIZE) < WAKEUP_CHARS)
+		uart_event(info, EVT_WRITE_WAKEUP);
+
+	if (info->xmit.head == info->xmit.tail)
+		s3c44b0uart_stop_tx(info->port, 0);
+
+}
+
+static u_int s3c44b0uart_tx_empty(struct uart_port *port)
+{
+	return (inl(UFSTAT)&TFCNT_MASK) ? 0 : TIOCSER_TEMT; 
+}
+
+static u_int s3c44b0uart_get_mctrl(struct uart_port *port)
+{
+	return (inl(UMSTAT)&UART_CTS) ? TIOCM_CTS : 0;
+}
+
+static void s3c44b0uart_set_mctrl(struct uart_port *port, u_int mctrl)
+{
+	unsigned int status;
+
+	status = inl(UMCON);
+
+	if(mctrl & TIOCM_RTS)
+		status |= UART_RTS;
+	else
+		status &= ~UART_RTS;
+
+	outl(status, UMCON);
+}
+
+static void s3c44b0uart_break_ctl(struct uart_port *port, int break_state)
+{
+	int status;
+
+	status = inl(UCON);
+	if(break_state)
+		status |= UCON_BRK;
+	else
+		status &= ~UCON_BRK;
+	outl(status, UCON);
+}
+
+static int s3c44b0uart_startup(struct uart_port *port, struct uart_info *info)
+{
+	int retv;
+
+	retv = request_irq(port->irq, s3c44b0uart_tx_int, 0,
+		"s3c44b0_uart_tx", info);
+	if(retv)
+		return retv;
+	retv = request_irq(port->irq+4, s3c44b0uart_rx_int, 0,
+		"s3c44b0_uart_rx", info);
+	if(retv){
+		free_irq(port->irq, info);
+		return retv;
+	}
+
+	outl(0x17, UFCON);
+	outl(0x85, UCON);
+	INT_ENABLE(port->irq+4);
+
+	return 0;
+}
+
+static void s3c44b0uart_shutdown(struct uart_port *port, struct uart_info *info)
+{
+	free_irq(port->irq, info);
+	free_irq(port->irq+4, info);
+	outl(0x00, UCON);
+}
+
+static void s3c44b0uart_change_speed(struct uart_port *port, u_int cflag, u_int iflag, u_int quot)
+{
+	unsigned int flags;
+	unsigned int ulcon = 0;
+
+	switch(cflag&CSIZE){
+	case CS5: ulcon = ULCON_CS5; break;
+	case CS6: ulcon = ULCON_CS6; break;
+	case CS7: ulcon = ULCON_CS7; break;
+	default:  ulcon = ULCON_CS8; break;
+	}
+	if(cflag&CSTOPB)
+		ulcon |= ULCON_STOPB;
+	if(cflag&PARENB){
+		ulcon |= ULCON_PARITY;
+		if(!(cflag&PARODD))
+			ulcon |= ULCON_PEVEN;
+	}
+
+	port->read_status_mask = UART_OE;
+	if(iflag&INPCK)
+		port->read_status_mask |= UART_PE|UART_FE;
+
+	port->ignore_status_mask = 0;
+	if(iflag&IGNPAR)
+		port->ignore_status_mask |= UART_PE|UART_FE;
+	if(iflag&IGNBRK){
+		port->ignore_status_mask |= UART_BE;
+		if(iflag&IGNPAR)
+			port->ignore_status_mask |= UART_OE;
+	}
+
+	save_flags_cli(flags);
+	outl(ulcon, ULCON);
+	outl(quot-1, UBRDIV);
+	restore_flags(flags);
+
+}
+
+static const char *s3c44b0uart_type(struct uart_port *port)
+{
+	return port->type == PORT_S3C44B0 ? "S3C44B0" : NULL;
+}
+
+/*
+ * Release the memory region(s) being used by 'port'
+ */
+static void s3c44b0uart_release_port(struct uart_port *port)
+{
+}
+
+/*
+ * Request the memory region(s) being used by 'port'
+ */
+static int s3c44b0uart_request_port(struct uart_port *port)
+{
+	return 0;
+}
+
+/*
+ * Configure/autoconfigure the port.
+ */
+static void s3c44b0uart_config_port(struct uart_port *port, int flags)
+{
+	if(flags & UART_CONFIG_TYPE)
+		port->type = PORT_S3C44B0;
+}
+
+/*
+ * verify the new serial_struct (for TIOCSSERIAL).
+ */
+static int s3c44b0uart_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	return 0;
+}
+
+static struct uart_ops s3c44b0_pops = {
+	tx_empty:	s3c44b0uart_tx_empty,
+	set_mctrl:	s3c44b0uart_set_mctrl,
+	get_mctrl:	s3c44b0uart_get_mctrl,
+	stop_tx:	s3c44b0uart_stop_tx,
+	start_tx:	s3c44b0uart_start_tx,
+	stop_rx:	s3c44b0uart_stop_rx,
+	enable_ms:	s3c44b0uart_enable_ms,
+	break_ctl:	s3c44b0uart_break_ctl,
+	startup:	s3c44b0uart_startup,
+	shutdown:	s3c44b0uart_shutdown,
+	change_speed:	s3c44b0uart_change_speed,
+	type:		s3c44b0uart_type,
+	release_port:	s3c44b0uart_release_port,
+	request_port:	s3c44b0uart_request_port,
+	config_port:	s3c44b0uart_config_port,
+	verify_port:	s3c44b0uart_verify_port,
+};
+
+static struct uart_port s3c44b0_ports[UART_NR] = {
+	{
+		iobase:		(void *)&ULCON0,
+		irq:		INT_UTXD0,
+		uartclk:	CONFIG_ARM_CLK,//60000000,
+		fifosize:	16,
+		ops:		&s3c44b0_pops,
+		flags:		ASYNC_BOOT_AUTOCONF,
+	},
+	{
+		iobase:		(void *)&ULCON1,
+		irq:		INT_UTXD1,
+		uartclk:	CONFIG_ARM_CLK,//60000000,
+		fifosize:	16,
+		ops:		&s3c44b0_pops,
+		flags:		ASYNC_BOOT_AUTOCONF,
+	}
+};
+
+#ifdef CONFIG_SERIAL_S3C44B0X_CONSOLE
+static void s3c44b0uart_console_write(struct console *co, const char *s, u_int count)
+{
+	struct uart_port *port = s3c44b0_ports + co->index;
+	unsigned int status, intmask;
+	int i;
+
+	intmask = INTMSK;
+	INT_DISABLE(port->irq);
+	INT_DISABLE(port->irq+4);
+
+	for (i = 0; i < count; i++) {
+		do {
+			status = inl(UFSTAT);
+		} while (status&TFULL);
+		outb(s[i], UTXH);
+		if (s[i] == '\n') {
+			do {
+				status = inl(UFSTAT);
+			} while (status&TFULL);
+			outb('\r', UTXH);
+		}
+	}
+
+	do {
+		status = inl(UFSTAT);
+	} while (status&TFCNT_MASK);
+	INTMSK = intmask;
+}
+
+static kdev_t s3c44b0uart_console_device(struct console *co)
+{
+	return MKDEV(SERIAL_S3C44B0_MAJOR, SERIAL_S3C44B0_MINOR+co->index);
+}
+
+static int s3c44b0uart_console_wait_key(struct console *co)
+{
+	struct uart_port *port = s3c44b0_ports + co->index;
+	unsigned int status, ch;
+
+	do{
+		status = inl(UFSTAT);
+	}while(!(status&RFCNT_MASK));
+	ch = inb(URXH);
+
+	return ch;
+}
+
+static void __init
+s3c44b0uart_console_get_options(struct uart_port *port, int *baud, int *parity, int *bits)
+{
+	unsigned int status, quot;
+
+	status = inl(UCON);
+	if(!status)
+		return;
+
+	status = inl(ULCON);
+	*bits = (status&3)+5;
+
+	*parity = 'n';
+	if(status&ULCON_PARITY){
+		if(status&ULCON_PEVEN)
+			*parity = 'e';
+		else
+			*parity = 'o';
+	}
+
+	quot = inl(UBRDIV);
+	*baud = port->uartclk/(16*(quot+1));
+
+	if(*baud>100000 && *baud<130000){
+		*baud = 115200;
+		return;
+	}
+	if(*baud>200000 && *baud<250000){
+		*baud = 230400;
+		return;
+	}
+	if(*baud>51000 && *baud<66000){
+		*baud = 57600;
+		return;
+	}
+	if(*baud>34000 && *baud<42000){
+		*baud = 38400;
+		return;
+	}
+	if(*baud>17000 && *baud<22000){
+		*baud = 19200;
+		return;
+	}
+	if(*baud>8400 && *baud<11000){
+		*baud = 9600;
+		return;
+	}
+	if(*baud>4300 && *baud<5300){
+		*baud = 4800;
+		return;
+	}
+	if(*baud>2100 && *baud<2700){
+		*baud = 2400;
+		return;
+	}
+	if(*baud>1000 && *baud<1300){
+		*baud = 1200;
+		return;
+	}
+}
+
+static int __init s3c44b0uart_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port;
+	int baud = CONFIG_S3C44B0_DEFAULT_BAUDRATE;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	/*
+	 * Check whether an invalid uart number has been specified, and
+	 * if so, search for the first available port that does have
+	 * console support.
+	*/
+	port = uart_get_console(s3c44b0_ports, UART_NR, co);
+
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+	else
+		s3c44b0uart_console_get_options(port, &baud, &parity, &bits);
+
+	outl(0x97, UFCON);
+	outl(0x05, UCON);
+	return uart_set_options(port, co, baud, parity, bits, flow);
+/*
+	outl(0x97, UFCON);
+	outl(0x03, ULCON);
+	outl(0x20, UBRDIV);
+	outl(0x05, UCON);
+*/
+        return 0;
+}
+
+static struct console s3c44b0_console = {
+	name:		"ttyS",
+	write:		s3c44b0uart_console_write,
+	device:		s3c44b0uart_console_device,
+//	wait_key:	s3c44b0uart_console_wait_key,
+	setup:		s3c44b0uart_console_setup,
+	flags:		CON_PRINTBUFFER,
+	index:		-1,
+};
+
+void __init s3c44b0x_console_init(void)
+{
+	register_console(&s3c44b0_console);
+}
+
+#define S3C44B0_CONSOLE	&s3c44b0_console
+#else
+#define S3C44B0_CONSOLE	NULL
+#endif
+
+static struct uart_driver s3c44b0_reg = {
+	owner:			THIS_MODULE,
+	normal_major:		SERIAL_S3C44B0_MAJOR,
+#ifdef CONFIG_DEVFS_FS
+	normal_name:		"ttyS%d",
+	callout_name:		"cua%d",
+#else
+	normal_name:		"ttyS",
+	callout_name:		"cua",
+#endif
+	normal_driver:		&normal,
+	callout_major:		CALLOUT_S3C44B0_MAJOR,
+	callout_driver:		&callout,
+	table:			s3c44b0_table,
+	termios:		s3c44b0_termios,
+	termios_locked:		s3c44b0_termios_locked,
+	minor:			SERIAL_S3C44B0_MINOR,
+	nr:			UART_NR,
+	port:			s3c44b0_ports,
+	cons:			S3C44B0_CONSOLE,
+};
+
+static int __init s3c44b0uart_init(void)
+{
+	return uart_register_driver(&s3c44b0_reg);
+}
+
+static void __exit s3c44b0uart_exit(void)
+{
+	uart_unregister_driver(&s3c44b0_reg);
+}
+
+module_init(s3c44b0uart_init);
+module_exit(s3c44b0uart_exit);
+
+EXPORT_NO_SYMBOLS;
+
+MODULE_AUTHOR("TPU");
+MODULE_DESCRIPTION("ARM S3C44B0 serial port driver");
+MODULE_LICENSE("GPL");
diff -urN uClinux-dist/linux-2.4.x/drivers/serial/serial_sa1100.c linux-2.4.x/drivers/serial/serial_sa1100.c
--- uClinux-dist/linux-2.4.x/drivers/serial/serial_sa1100.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.4.x/drivers/serial/serial_sa1100.c	2004-03-25 23:16:49.000000000 +0800
@@ -0,0 +1,818 @@
+/*
+ *  linux/drivers/char/serial_sa1100.c
+ *
+ *  Driver for SA11x0 serial ports
+ *
+ *  Based on drivers/char/serial.c, by Linus Torvalds, Theodore Ts'o.
+ *
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *  $Id: serial_sa1100.c,v 1.14.2.3 2001/11/27 17:35:39 rmk Exp $
+ *
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/major.h>
+#include <linux/string.h>
+#include <linux/fcntl.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/circ_buf.h>
+#include <linux/serial.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <asm/bitops.h>
+#include <asm/hardware.h>
+#include <asm/mach/serial_sa1100.h>
+
+#if defined(CONFIG_SERIAL_SA1100_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
+#include <linux/serial_core.h>
+
+/* We've been assigned a range on the "Low-density serial ports" major */
+#define SERIAL_SA1100_MAJOR	204
+#define CALLOUT_SA1100_MAJOR	205
+#define MINOR_START		5
+
+#define NR_PORTS		3
+
+#define SA1100_ISR_PASS_LIMIT	256
+
+/*
+ * Convert from ignore_status_mask or read_status_mask to UTSR[01]
+ */
+#define SM_TO_UTSR0(x)	((x) & 0xff)
+#define SM_TO_UTSR1(x)	((x) >> 8)
+#define UTSR0_TO_SM(x)	((x))
+#define UTSR1_TO_SM(x)	((x) << 8)
+
+#define UART_GET_UTCR0(port)		__raw_readl((port)->membase + UTCR0)
+#define UART_GET_UTCR1(port)		__raw_readl((port)->membase + UTCR1)
+#define UART_GET_UTCR2(port)		__raw_readl((port)->membase + UTCR2)
+#define UART_GET_UTCR3(port)		__raw_readl((port)->membase + UTCR3)
+#define UART_GET_UTSR0(port)		__raw_readl((port)->membase + UTSR0)
+#define UART_GET_UTSR1(port)		__raw_readl((port)->membase + UTSR1)
+#define UART_GET_CHAR(port)		__raw_readl((port)->membase + UTDR)
+
+#define UART_PUT_UTCR0(port,v)		__raw_writel((v),(port)->membase + UTCR0)
+#define UART_PUT_UTCR1(port,v)		__raw_writel((v),(port)->membase + UTCR1)
+#define UART_PUT_UTCR2(port,v)		__raw_writel((v),(port)->membase + UTCR2)
+#define UART_PUT_UTCR3(port,v)		__raw_writel((v),(port)->membase + UTCR3)
+#define UART_PUT_UTSR0(port,v)		__raw_writel((v),(port)->membase + UTSR0)
+#define UART_PUT_UTSR1(port,v)		__raw_writel((v),(port)->membase + UTSR1)
+#define UART_PUT_CHAR(port,v)		__raw_writel((v),(port)->membase + UTDR)
+
+/*
+ * This is the size of our serial port register set.
+ */
+#define UART_PORT_SIZE	0x24
+
+static struct tty_driver normal, callout;
+static struct tty_struct *sa1100_table[NR_PORTS];
+static struct termios *sa1100_termios[NR_PORTS], *sa1100_termios_locked[NR_PORTS];
+static int (*sa1100_open)(struct uart_port *, struct uart_info *);
+static void (*sa1100_close)(struct uart_port *, struct uart_info *);
+#ifdef SUPPORT_SYSRQ
+static struct console sa1100_console;
+#endif
+
+/*
+ * interrupts disabled on entry
+ */
+static void sa1100_stop_tx(struct uart_port *port, u_int from_tty)
+{
+	u32 utcr3 = UART_GET_UTCR3(port);
+	UART_PUT_UTCR3(port, utcr3 & ~UTCR3_TIE);
+	port->read_status_mask &= ~UTSR0_TO_SM(UTSR0_TFS);
+}
+
+/*
+ * interrupts may not be disabled on entry
+ */
+static void sa1100_start_tx(struct uart_port *port, u_int nonempty, u_int from_tty)
+{
+	if (nonempty) {
+		unsigned long flags;
+		u32 utcr3;
+
+		local_irq_save(flags);
+		utcr3 = UART_GET_UTCR3(port);
+		port->read_status_mask |= UTSR0_TO_SM(UTSR0_TFS);
+		UART_PUT_UTCR3(port, utcr3 | UTCR3_TIE);
+		local_irq_restore(flags);
+	}
+}
+
+/*
+ * Interrupts enabled
+ */
+static void sa1100_stop_rx(struct uart_port *port)
+{
+	u32 utcr3 = UART_GET_UTCR3(port);
+	UART_PUT_UTCR3(port, utcr3 & ~UTCR3_RIE);
+}
+
+/*
+ * No modem control lines
+ */
+static void sa1100_enable_ms(struct uart_port *port)
+{
+}
+
+static void
+sa1100_rx_chars(struct uart_info *info, struct pt_regs *regs)
+{
+	struct tty_struct *tty = info->tty;
+	unsigned int status, ch, flg, ignored = 0;
+	struct uart_port *port = info->port;
+
+	status = UTSR1_TO_SM(UART_GET_UTSR1(port)) | UTSR0_TO_SM(UART_GET_UTSR0(port));
+	while (status & UTSR1_TO_SM(UTSR1_RNE)) {
+		ch = UART_GET_CHAR(port);
+
+		if (tty->flip.count >= TTY_FLIPBUF_SIZE)
+			goto ignore_char;
+		port->icount.rx++;
+
+		flg = TTY_NORMAL;
+
+		/*
+		 * note that the error handling code is
+		 * out of the main execution path
+		 */
+		if (status & UTSR1_TO_SM(UTSR1_PRE | UTSR1_FRE | UTSR1_ROR))
+			goto handle_error;
+
+		if (uart_handle_sysrq_char(info, ch, regs))
+			goto ignore_char;
+
+	error_return:
+		*tty->flip.flag_buf_ptr++ = flg;
+		*tty->flip.char_buf_ptr++ = ch;
+		tty->flip.count++;
+	ignore_char:
+		status = UTSR1_TO_SM(UART_GET_UTSR1(port)) | UTSR0_TO_SM(UART_GET_UTSR0(port));
+	}
+out:
+	tty_flip_buffer_push(tty);
+	return;
+
+handle_error:
+	if (status & UTSR1_TO_SM(UTSR1_PRE))
+		port->icount.parity++;
+	else if (status & UTSR1_TO_SM(UTSR1_FRE))
+		port->icount.frame++;
+	if (status & UTSR1_TO_SM(UTSR1_ROR))
+		port->icount.overrun++;
+
+	if (status & port->ignore_status_mask) {
+		if (++ignored > 100)
+			goto out;
+		goto ignore_char;
+	}
+
+	status &= port->read_status_mask;
+
+	if (status & UTSR1_TO_SM(UTSR1_PRE))
+		flg = TTY_PARITY;
+	else if (status & UTSR1_TO_SM(UTSR1_FRE))
+		flg = TTY_FRAME;
+
+	if (status & UTSR1_TO_SM(UTSR1_ROR)) {
+		/*
+		 * overrun does *not* affect the character
+		 * we read from the FIFO
+		 */
+		*tty->flip.flag_buf_ptr++ = flg;
+		*tty->flip.char_buf_ptr++ = ch;
+		tty->flip.count++;
+		if (tty->flip.count >= TTY_FLIPBUF_SIZE)
+			goto ignore_char;
+		ch = 0;
+		flg = TTY_OVERRUN;
+	}
+#ifdef SUPPORT_SYSRQ
+	info->sysrq = 0;
+#endif
+	goto error_return;
+}
+
+static void sa1100_tx_chars(struct uart_info *info)
+{
+	struct uart_port *port = info->port;
+
+	if (port->x_char) {
+		UART_PUT_CHAR(port, port->x_char);
+		port->icount.tx++;
+		port->x_char = 0;
+		return;
+	}
+	if (info->xmit.head == info->xmit.tail
+	    || info->tty->stopped
+	    || info->tty->hw_stopped) {
+		sa1100_stop_tx(info->port, 0);
+		return;
+	}
+
+	/*
+	 * Tried using FIFO (not checking TNF) for fifo fill:
+	 * still had the '4 bytes repeated' problem.
+	 */
+	while (UART_GET_UTSR1(port) & UTSR1_TNF) {
+		UART_PUT_CHAR(port, info->xmit.buf[info->xmit.tail]);
+		info->xmit.tail = (info->xmit.tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+		if (info->xmit.head == info->xmit.tail)
+			break;
+	}
+
+	if (CIRC_CNT(info->xmit.head, info->xmit.tail, UART_XMIT_SIZE) <
+			WAKEUP_CHARS)
+		uart_event(info, EVT_WRITE_WAKEUP);
+
+	if (info->xmit.head == info->xmit.tail)
+		sa1100_stop_tx(info->port, 0);
+}
+
+static void sa1100_int(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct uart_info *info = dev_id;
+	struct uart_port *port = info->port;
+	unsigned int status, pass_counter = 0;
+
+	status = UART_GET_UTSR0(port);
+	status &= (SM_TO_UTSR0(port->read_status_mask) | ~UTSR0_TFS);
+	do {
+		if (status & (UTSR0_RFS | UTSR0_RID)) {
+			/* Clear the receiver idle bit, if set */
+			if (status & UTSR0_RID)
+				UART_PUT_UTSR0(port, UTSR0_RID);
+			sa1100_rx_chars(info, regs);
+		}
+
+		/* Clear the relevent break bits */
+		if (status & (UTSR0_RBB | UTSR0_REB))
+			UART_PUT_UTSR0(port, status & (UTSR0_RBB | UTSR0_REB));
+
+		if (status & UTSR0_RBB)
+			port->icount.brk++;
+
+		if (status & UTSR0_REB) {
+#ifdef SUPPORT_SYSRQ
+			if (port->line == sa1100_console.index &&
+			    !info->sysrq) {
+				info->sysrq = jiffies + HZ*5;
+			}
+#endif
+		}
+		if (status & UTSR0_TFS)
+			sa1100_tx_chars(info);
+		if (pass_counter++ > SA1100_ISR_PASS_LIMIT)
+			break;
+		status = UART_GET_UTSR0(port);
+		status &= (SM_TO_UTSR0(port->read_status_mask) | ~UTSR0_TFS);
+	} while (status & (UTSR0_TFS | UTSR0_RFS | UTSR0_RID));
+}
+
+/*
+ * Return TIOCSER_TEMT when transmitter is not busy.
+ */
+static u_int sa1100_tx_empty(struct uart_port *port)
+{
+	return UART_GET_UTSR1(port) & UTSR1_TBY ? 0 : TIOCSER_TEMT;
+}
+
+static u_int sa1100_get_mctrl(struct uart_port *port)
+{
+	return TIOCM_CTS | TIOCM_DSR | TIOCM_CAR;
+}
+
+static void sa1100_set_mctrl(struct uart_port *port, u_int mctrl)
+{
+}
+
+/*
+ * Interrupts always disabled.
+ */
+static void sa1100_break_ctl(struct uart_port *port, int break_state)
+{
+	u_int utcr3;
+
+	utcr3 = UART_GET_UTCR3(port);
+	if (break_state == -1)
+		utcr3 |= UTCR3_BRK;
+	else
+		utcr3 &= ~UTCR3_BRK;
+	UART_PUT_UTCR3(port, utcr3);
+}
+
+static int sa1100_startup(struct uart_port *port, struct uart_info *info)
+{
+	int retval;
+
+	/*
+	 * Allocate the IRQ
+	 */
+	retval = request_irq(port->irq, sa1100_int, 0, "serial_sa1100", info);
+	if (retval)
+		return retval;
+
+	/*
+	 * If there is a specific "open" function (to register
+	 * control line interrupts)
+	 */
+	if (sa1100_open) {
+		retval = sa1100_open(port, info);
+		if (retval) {
+			free_irq(port->irq, info);
+			return retval;
+		}
+	}
+
+	/*
+	 * Finally, clear and enable interrupts
+	 */
+	UART_PUT_UTSR0(port, -1);
+	UART_PUT_UTCR3(port, UTCR3_RXE | UTCR3_TXE | UTCR3_RIE);
+
+	return 0;
+}
+
+static void sa1100_shutdown(struct uart_port *port, struct uart_info *info)
+{
+	/*
+	 * Free the interrupt
+	 */
+	free_irq(port->irq, info);
+
+	/*
+	 * If there is a specific "close" function (to unregister
+	 * control line interrupts)
+	 */
+	if (sa1100_close)
+		sa1100_close(port, info);
+
+	/*
+	 * Disable all interrupts, port and break condition.
+	 */
+	UART_PUT_UTCR3(port, 0);
+}
+
+static void sa1100_change_speed(struct uart_port *port, u_int cflag, u_int iflag, u_int quot)
+{
+	unsigned long flags;
+	u_int utcr0, old_utcr3;
+
+	/* byte size and parity */
+	switch (cflag & CSIZE) {
+	case CS7:	utcr0 = 0;		break;
+	default:	utcr0 = UTCR0_DSS;	break;
+	}
+	if (cflag & CSTOPB)
+		utcr0 |= UTCR0_SBS;
+	if (cflag & PARENB) {
+		utcr0 |= UTCR0_PE;
+		if (!(cflag & PARODD))
+			utcr0 |= UTCR0_OES;
+	}
+
+	port->read_status_mask &= UTSR0_TO_SM(UTSR0_TFS);
+	port->read_status_mask |= UTSR1_TO_SM(UTSR1_ROR);
+	if (iflag & INPCK)
+		port->read_status_mask |= UTSR1_TO_SM(UTSR1_FRE | UTSR1_PRE);
+	if (iflag & (BRKINT | PARMRK))
+		port->read_status_mask |= UTSR0_TO_SM(UTSR0_RBB | UTSR0_REB);
+
+	/*
+	 * Characters to ignore
+	 */
+	port->ignore_status_mask = 0;
+	if (iflag & IGNPAR)
+		port->ignore_status_mask |= UTSR1_TO_SM(UTSR1_FRE | UTSR1_PRE);
+	if (iflag & IGNBRK) {
+		port->ignore_status_mask |= UTSR0_TO_SM(UTSR0_RBB | UTSR0_REB);
+		/*
+		 * If we're ignoring parity and break indicators,
+		 * ignore overruns too (for real raw support).
+		 */
+		if (iflag & IGNPAR)
+			port->ignore_status_mask |= UTSR1_TO_SM(UTSR1_ROR);
+	}
+
+	/* first, disable interrupts and drain transmitter */
+	local_irq_save(flags);
+	old_utcr3 = UART_GET_UTCR3(port);
+	UART_PUT_UTCR3(port, old_utcr3 & ~(UTCR3_RIE | UTCR3_TIE));
+	local_irq_restore(flags);
+	while (UART_GET_UTSR1(port) & UTSR1_TBY);
+
+	/* then, disable everything */
+	UART_PUT_UTCR3(port, 0);
+
+	/* set the parity, stop bits and data size */
+	UART_PUT_UTCR0(port, utcr0);
+
+	/* set the baud rate */
+	quot -= 1;
+	UART_PUT_UTCR1(port, ((quot & 0xf00) >> 8));
+	UART_PUT_UTCR2(port, (quot & 0xff));
+
+	UART_PUT_UTSR0(port, -1);
+
+	UART_PUT_UTCR3(port, old_utcr3);
+}
+
+static const char *sa1100_type(struct uart_port *port)
+{
+	return port->type == PORT_SA1100 ? "SA1100" : NULL;
+}
+
+/*
+ * Release the memory region(s) being used by 'port'.
+ */
+static void sa1100_release_port(struct uart_port *port)
+{
+	release_mem_region(port->mapbase, UART_PORT_SIZE);
+}
+
+/*
+ * Request the memory region(s) being used by 'port'.
+ */
+static int sa1100_request_port(struct uart_port *port)
+{
+	return request_mem_region(port->mapbase, UART_PORT_SIZE,
+			"serial_sa1100") != NULL ? 0 : -EBUSY;
+}
+
+/*
+ * Configure/autoconfigure the port.
+ */
+static void sa1100_config_port(struct uart_port *port, int flags)
+{
+	if (flags & UART_CONFIG_TYPE && sa1100_request_port(port) == 0)
+		port->type = PORT_SA1100;
+}
+
+/*
+ * Verify the new serial_struct (for TIOCSSERIAL).
+ * The only change we allow are to the flags and type, and
+ * even then only between PORT_SA1100 and PORT_UNKNOWN
+ */
+static int sa1100_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	int ret = 0;
+	if (ser->type != PORT_UNKNOWN && ser->type != PORT_SA1100)
+		ret = -EINVAL;
+	if (port->irq != ser->irq)
+		ret = -EINVAL;
+	if (ser->io_type != SERIAL_IO_MEM)
+		ret = -EINVAL;
+	if (port->uartclk / 16 != ser->baud_base)
+		ret = -EINVAL;
+	if ((void *)port->mapbase != ser->iomem_base)
+		ret = -EINVAL;
+	if (port->iobase != ser->port)
+		ret = -EINVAL;
+	if (ser->hub6 != 0)
+		ret = -EINVAL;
+	return ret;
+}
+
+static struct uart_ops sa1100_pops = {
+	tx_empty:	sa1100_tx_empty,
+	set_mctrl:	sa1100_set_mctrl,
+	get_mctrl:	sa1100_get_mctrl,
+	stop_tx:	sa1100_stop_tx,
+	start_tx:	sa1100_start_tx,
+	stop_rx:	sa1100_stop_rx,
+	enable_ms:	sa1100_enable_ms,
+	break_ctl:	sa1100_break_ctl,
+	startup:	sa1100_startup,
+	shutdown:	sa1100_shutdown,
+	change_speed:	sa1100_change_speed,
+	type:		sa1100_type,
+	release_port:	sa1100_release_port,
+	request_port:	sa1100_request_port,
+	config_port:	sa1100_config_port,
+	verify_port:	sa1100_verify_port,
+};
+
+static struct uart_port sa1100_ports[NR_PORTS];
+
+/*
+ * Setup the SA1100 serial ports.  Note that we don't include the IrDA
+ * port here since we have our own SIR/FIR driver (see drivers/net/irda)
+ *
+ * Note also that we support "console=ttySAx" where "x" is either 0 or 1.
+ * Which serial port this ends up being depends on the machine you're
+ * running this kernel on.  I'm not convinced that this is a good idea,
+ * but that's the way it traditionally works.
+ *
+ * Note that NanoEngine UART3 becomes UART2, and UART2 is no longer
+ * used here.
+ */
+static void sa1100_init_ports(void)
+{
+	static int first = 1;
+	int i;
+
+	if (!first)
+		return;
+	first = 0;
+
+	for (i = 0; i < NR_PORTS; i++) {
+		sa1100_ports[i].uartclk  = 3686400;
+		sa1100_ports[i].ops      = &sa1100_pops;
+		sa1100_ports[i].fifosize = 8;
+	}
+
+	/*
+	 * make transmit lines outputs, so that when the port
+	 * is closed, the output is in the MARK state.
+	 */
+	PPDR |= PPC_TXD1 | PPC_TXD3;
+	PPSR |= PPC_TXD1 | PPC_TXD3;
+}
+
+void __init sa1100_register_uart_fns(struct sa1100_port_fns *fns)
+{
+	if (fns->enable_ms)
+		sa1100_pops.enable_ms = fns->enable_ms;
+	if (fns->get_mctrl)
+		sa1100_pops.get_mctrl = fns->get_mctrl;
+	if (fns->set_mctrl)
+		sa1100_pops.set_mctrl = fns->set_mctrl;
+	sa1100_open          = fns->open;
+	sa1100_close         = fns->close;
+	sa1100_pops.pm       = fns->pm;
+	sa1100_pops.set_wake = fns->set_wake;
+}
+
+void __init sa1100_register_uart(int idx, int port)
+{
+	if (idx >= NR_PORTS) {
+		printk(KERN_ERR __FUNCTION__ ": bad index number %d\n", idx);
+		return;
+	}
+
+	switch (port) {
+	case 1:
+		sa1100_ports[idx].membase = (void *)&Ser1UTCR0;
+		sa1100_ports[idx].mapbase = _Ser1UTCR0;
+		sa1100_ports[idx].irq     = IRQ_Ser1UART;
+		sa1100_ports[idx].iotype  = SERIAL_IO_MEM;
+		sa1100_ports[idx].flags   = ASYNC_BOOT_AUTOCONF;
+		break;
+
+	case 2:
+		sa1100_ports[idx].membase = (void *)&Ser2UTCR0;
+		sa1100_ports[idx].mapbase = _Ser2UTCR0;
+		sa1100_ports[idx].irq     = IRQ_Ser2ICP;
+		sa1100_ports[idx].iotype  = SERIAL_IO_MEM;
+		sa1100_ports[idx].flags   = ASYNC_BOOT_AUTOCONF;
+		break;
+
+	case 3:
+		sa1100_ports[idx].membase = (void *)&Ser3UTCR0;
+		sa1100_ports[idx].mapbase = _Ser3UTCR0;
+		sa1100_ports[idx].irq     = IRQ_Ser3UART;
+		sa1100_ports[idx].iotype  = SERIAL_IO_MEM;
+		sa1100_ports[idx].flags   = ASYNC_BOOT_AUTOCONF;
+		break;
+
+	default:
+		printk(KERN_ERR __FUNCTION__ ": bad port number %d\n", port);
+	}
+}
+
+
+#ifdef CONFIG_SERIAL_SA1100_CONSOLE
+
+/*
+ * Interrupts are disabled on entering
+ */
+static void sa1100_console_write(struct console *co, const char *s, u_int count)
+{
+	struct uart_port *port = sa1100_ports + co->index;
+	u_int old_utcr3, status, i;
+
+	/*
+	 *	First, save UTCR3 and then disable interrupts
+	 */
+	old_utcr3 = UART_GET_UTCR3(port);
+	UART_PUT_UTCR3(port, (old_utcr3 & ~(UTCR3_RIE | UTCR3_TIE)) | UTCR3_TXE);
+
+	/*
+	 *	Now, do each character
+	 */
+	for (i = 0; i < count; i++) {
+		do {
+			status = UART_GET_UTSR1(port);
+		} while (!(status & UTSR1_TNF));
+		UART_PUT_CHAR(port, s[i]);
+		if (s[i] == '\n') {
+			do {
+				status = UART_GET_UTSR1(port);
+			} while (!(status & UTSR1_TNF));
+			UART_PUT_CHAR(port, '\r');
+		}
+	}
+
+	/*
+	 *	Finally, wait for transmitter to become empty
+	 *	and restore UTCR3
+	 */
+	do {
+		status = UART_GET_UTSR1(port);
+	} while (status & UTSR1_TBY);
+	UART_PUT_UTCR3(port, old_utcr3);
+}
+
+static kdev_t sa1100_console_device(struct console *co)
+{
+	return MKDEV(SERIAL_SA1100_MAJOR, MINOR_START + co->index);
+}
+
+static int sa1100_console_wait_key(struct console *co)
+{
+	struct uart_port *port = sa1100_ports + co->index;
+	unsigned long flags;
+	u_int old_utcr3, status, ch;
+
+	/*
+	 * Save UTCR3 and disable interrupts
+	 */
+	save_flags(flags);
+	cli();
+	old_utcr3 = UART_GET_UTCR3(port);
+	UART_PUT_UTCR3(port, old_utcr3 & ~(UTCR3_RIE | UTCR3_TIE));
+	restore_flags(flags);
+
+	/*
+	 * Wait for a character
+	 */
+	do {
+		status = UART_GET_UTSR1(port);
+	} while (!(status & UTSR1_RNE));
+	ch = UART_GET_CHAR(port);
+
+	/*
+	 * Restore UTCR3
+	 */
+	UART_PUT_UTCR3(port, old_utcr3);
+
+	return ch;
+}
+
+/*
+ * If the port was already initialised (eg, by a boot loader), try to determine
+ * the current setup.
+ */
+static void __init
+sa1100_console_get_options(struct uart_port *port, int *baud, int *parity, int *bits)
+{
+	u_int utcr3;
+
+	utcr3 = UART_GET_UTCR3(port) & (UTCR3_RXE | UTCR3_TXE);
+	if (utcr3 == (UTCR3_RXE | UTCR3_TXE)) {
+		/* ok, the port was enabled */
+		u_int utcr0, quot;
+
+		utcr0 = UART_GET_UTCR0(port);
+
+		*parity = 'n';
+		if (utcr0 & UTCR0_PE) {
+			if (utcr0 & UTCR0_OES)
+				*parity = 'e';
+			else
+				*parity = 'o';
+		}
+
+		if (utcr0 & UTCR0_DSS)
+			*bits = 8;
+		else
+			*bits = 7;
+
+		quot = UART_GET_UTCR2(port) | UART_GET_UTCR1(port) << 8;
+		quot &= 0xfff;
+		*baud = port->uartclk / (16 * (quot + 1));
+	}
+}
+
+static int __init
+sa1100_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port;
+	int baud = CONFIG_SA1100_DEFAULT_BAUDRATE;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	/*
+	 * Check whether an invalid uart number has been specified, and
+	 * if so, search for the first available port that does have
+	 * console support.
+	 */
+	port = uart_get_console(sa1100_ports, NR_PORTS, co);
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+	else
+		sa1100_console_get_options(port, &baud, &parity, &bits);
+
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+static struct console sa1100_console = {
+	name:		"ttySA",
+	write:		sa1100_console_write,
+	device:		sa1100_console_device,
+	wait_key:	sa1100_console_wait_key,
+	setup:		sa1100_console_setup,
+	flags:		CON_PRINTBUFFER,
+	index:		-1,
+};
+
+void __init sa1100_rs_console_init(void)
+{
+	sa1100_init_ports();
+	register_console(&sa1100_console);
+}
+
+#define SA1100_CONSOLE	&sa1100_console
+#else
+#define SA1100_CONSOLE	NULL
+#endif
+
+static struct uart_driver sa1100_reg = {
+	owner:			THIS_MODULE,
+	normal_major:		SERIAL_SA1100_MAJOR,
+#ifdef CONFIG_DEVFS_FS
+	normal_name:		"ttySA%d",
+	callout_name:		"cusa%d",
+#else
+	normal_name:		"ttySA",
+	callout_name:		"cusa",
+#endif
+	normal_driver:		&normal,
+	callout_major:		CALLOUT_SA1100_MAJOR,
+	callout_driver:		&callout,
+	table:			sa1100_table,
+	termios:		sa1100_termios,
+	termios_locked:		sa1100_termios_locked,
+	minor:			MINOR_START,
+	nr:			NR_PORTS,
+	port:			sa1100_ports,
+	cons:			SA1100_CONSOLE,
+};
+
+static int __init sa1100_serial_init(void)
+{
+	sa1100_init_ports();
+	return uart_register_driver(&sa1100_reg);
+}
+
+static void __exit sa1100_serial_exit(void)
+{
+	uart_unregister_driver(&sa1100_reg);
+}
+
+module_init(sa1100_serial_init);
+module_exit(sa1100_serial_exit);
+
+EXPORT_NO_SYMBOLS;
+
+MODULE_AUTHOR("Deep Blue Solutions Ltd");
+MODULE_DESCRIPTION("SA1100 generic serial port driver");
+MODULE_LICENSE("GPL");
+
diff -urN uClinux-dist/linux-2.4.x/drivers/serial/serial_uart00.c linux-2.4.x/drivers/serial/serial_uart00.c
--- uClinux-dist/linux-2.4.x/drivers/serial/serial_uart00.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.4.x/drivers/serial/serial_uart00.c	2004-03-25 23:16:49.000000000 +0800
@@ -0,0 +1,809 @@
+/*
+ *  linux/drivers/char/serial_uart00.c
+ *
+ *  Driver for UART00 serial ports
+ *
+ *  Based on drivers/char/serial_amba.c, by ARM Limited & 
+ *                                          Deep Blue Solutions Ltd.
+ *  Copyright 2001 Altera Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *  $Id: serial_uart00.c,v 1.3.2.4 2002/03/27 23:32:40 rmk Exp $
+ *
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+
+#include <linux/errno.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/major.h>
+#include <linux/string.h>
+#include <linux/fcntl.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/circ_buf.h>
+#include <linux/serial.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <asm/bitops.h>
+#include <asm/sizes.h>
+
+#if defined(CONFIG_SERIAL_UART00_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
+#include <linux/serial_core.h>
+#include <asm/arch/excalibur.h>
+#define UART00_TYPE (volatile unsigned int*)
+#include <asm/arch/uart00.h>
+#include <asm/arch/int_ctrl00.h>
+
+#undef DEBUG
+#define UART_NR		2
+
+#define SERIAL_UART00_NAME	"ttyUA"
+#define SERIAL_UART00_MAJOR	204
+#define SERIAL_UART00_MINOR	16      /* Temporary - will change in future */
+#define SERIAL_UART00_NR	UART_NR
+#define UART_PORT_SIZE 0x50
+
+#define CALLOUT_UART00_NAME	"cuaua"
+#define CALLOUT_UART00_MAJOR	205
+#define CALLOUT_UART00_MINOR	16      /* Temporary - will change in future */
+#define CALLOUT_UART00_NR	UART_NR
+
+
+
+static struct tty_driver normal, callout;
+static struct tty_struct *uart00_table[UART_NR];
+static struct termios *uart00_termios[UART_NR], *uart00_termios_locked[UART_NR];
+//static struct uart_state uart00_state[UART_NR];
+static struct console uart00_console;
+
+#define UART00_ISR_PASS_LIMIT	256
+
+/*
+ * Access macros for the UART00 UARTs
+ */
+#define UART_GET_INT_STATUS(p)	inl(UART_ISR((p)->membase))
+#define UART_PUT_IES(p, c)      outl(c,UART_IES((p)->membase))
+#define UART_GET_IES(p)         inl(UART_IES((p)->membase))
+#define UART_PUT_IEC(p, c)      outl(c,UART_IEC((p)->membase))
+#define UART_GET_IEC(p)         inl(UART_IEC((p)->membase))
+#define UART_PUT_CHAR(p, c)     outl(c,UART_TD((p)->membase))
+#define UART_GET_CHAR(p)        inl(UART_RD((p)->membase))
+#define UART_GET_RSR(p)         inl(UART_RSR((p)->membase))
+#define UART_GET_RDS(p)         inl(UART_RDS((p)->membase))
+#define UART_GET_MSR(p)         inl(UART_MSR((p)->membase))
+#define UART_GET_MCR(p)         inl(UART_MCR((p)->membase))
+#define UART_PUT_MCR(p, c)      outl(c,UART_MCR((p)->membase))
+#define UART_GET_MC(p)          inl(UART_MC((p)->membase))
+#define UART_PUT_MC(p, c)       outl(c,UART_MC((p)->membase))
+#define UART_GET_TSR(p)         inl(UART_TSR((p)->membase))
+#define UART_GET_DIV_HI(p)	inl(UART_DIV_HI((p)->membase))
+#define UART_PUT_DIV_HI(p,c)	outl(c,UART_DIV_HI((p)->membase))
+#define UART_GET_DIV_LO(p)	inl(UART_DIV_LO((p)->membase))
+#define UART_PUT_DIV_LO(p,c)	outl(c,UART_DIV_LO((p)->membase))
+#define UART_RX_DATA(s)		((s) & UART_RSR_RX_LEVEL_MSK)
+#define UART_TX_READY(s)	(((s) & UART_TSR_TX_LEVEL_MSK) < 15)
+//#define UART_TX_EMPTY(p)	((UART_GET_FR(p) & UART00_UARTFR_TMSK) == 0)
+
+static void uart00_stop_tx(struct uart_port *port, u_int from_tty)
+{
+
+	UART_PUT_IEC(port, UART_IEC_TIE_MSK);
+}
+
+static void uart00_stop_rx(struct uart_port *port)
+{
+
+	UART_PUT_IEC(port, UART_IEC_RE_MSK);
+}
+
+static void uart00_enable_ms(struct uart_port *port)
+{
+
+	UART_PUT_IES(port, UART_IES_ME_MSK);
+}
+
+static void
+uart00_rx_chars(struct uart_info *info, struct pt_regs *regs)
+{
+	struct tty_struct *tty = info->tty;
+	unsigned int status, ch, rds, flg, ignored = 0;
+	struct uart_port *port = info->port;
+	
+
+	status = UART_GET_RSR(port);
+	while (UART_RX_DATA(status)) {
+
+		/* 
+		 * We need to read rds before reading the 
+		 * character from the fifo
+		 */
+		rds = UART_GET_RDS(port);
+		ch = UART_GET_CHAR(port);
+		port->icount.rx++;
+
+		if (tty->flip.count >= TTY_FLIPBUF_SIZE)
+			goto ignore_char;
+
+		flg = TTY_NORMAL;
+
+		/*
+		 * Note that the error handling code is
+		 * out of the main execution path
+		 */
+		if (rds & (UART_RDS_BI_MSK |UART_RDS_FE_MSK|
+			   UART_RDS_PE_MSK |UART_RDS_PE_MSK))
+			goto handle_error;
+		if (uart_handle_sysrq_char(info, ch, regs))
+			goto ignore_char;
+
+	error_return:
+		*tty->flip.flag_buf_ptr++ = flg;
+		*tty->flip.char_buf_ptr++ = ch;
+		tty->flip.count++;
+	ignore_char:
+		status = UART_GET_RSR(port);
+	}
+out:
+	tty_flip_buffer_push(tty);
+	return;
+
+handle_error:
+	if (rds & UART_RDS_BI_MSK) {
+		status &= ~(UART_RDS_FE_MSK | UART_RDS_PE_MSK);
+		port->icount.brk++;
+
+#ifdef SUPPORT_SYSRQ
+		if (uart_handle_break(info, &uart00_console))
+			goto ignore_char;
+#endif
+	} else if (rds & UART_RDS_PE_MSK)
+		port->icount.parity++;
+	else if (rds & UART_RDS_PE_MSK)
+		port->icount.frame++;
+	if (rds & UART_RDS_OE_MSK)
+		port->icount.overrun++;
+
+	if (rds & port->ignore_status_mask) {
+		if (++ignored > 100)
+			goto out;
+		goto ignore_char;
+	}
+	rds &= port->read_status_mask;
+
+	if (rds & UART_RDS_BI_MSK)
+		flg = TTY_BREAK;
+	else if (rds & UART_RDS_PE_MSK)
+		flg = TTY_PARITY;
+	else if (rds & UART_RDS_FE_MSK)
+		flg = TTY_FRAME;
+
+	if (status & UART_RDS_OE_MSK) {
+		/*
+		 * CHECK: does overrun affect the current character?
+		 * ASSUMPTION: it does not.
+		 */
+		*tty->flip.flag_buf_ptr++ = flg;
+		*tty->flip.char_buf_ptr++ = ch;
+		tty->flip.count++;
+		if (tty->flip.count >= TTY_FLIPBUF_SIZE)
+			goto ignore_char;
+		ch = 0;
+		flg = TTY_OVERRUN;
+	}
+#ifdef SUPPORT_SYSRQ
+	info->sysrq = 0;
+#endif
+	goto error_return;
+}
+
+static void uart00_tx_chars(struct uart_info *info)
+{
+	int count;
+	struct uart_port *port=info->port;
+
+	if (port->x_char) {
+		while((UART_GET_TSR(port)& UART_TSR_TX_LEVEL_MSK)==15);
+		UART_PUT_CHAR(port, port->x_char);
+		port->icount.tx++;
+		port->x_char = 0;
+		
+		return;
+	}
+	if (info->xmit.head == info->xmit.tail
+	    || info->tty->stopped
+	    || info->tty->hw_stopped) {
+		uart00_stop_tx(info->port, 0);
+		return;
+	}
+
+	count = port->fifosize >> 1;
+	do {
+		while((UART_GET_TSR(port)& UART_TSR_TX_LEVEL_MSK)==15);
+		UART_PUT_CHAR(port, info->xmit.buf[info->xmit.tail]);
+		info->xmit.tail = (info->xmit.tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+		if (info->xmit.head == info->xmit.tail)
+			break;
+	} while (--count > 0);
+
+	if (CIRC_CNT(info->xmit.head,
+		     info->xmit.tail,
+		     UART_XMIT_SIZE) < WAKEUP_CHARS)
+		uart_event(info, EVT_WRITE_WAKEUP);
+
+	if (info->xmit.head == info->xmit.tail)
+		uart00_stop_tx(info->port, 0);
+}
+
+static void uart00_start_tx(struct uart_port *port, u_int nonempty, u_int from_tty)
+{
+	struct uart_info *info=(struct uart_info*)(port->iobase);
+
+	UART_PUT_IES(port,UART_IES_TIE_MSK );		
+	uart00_tx_chars(info);
+}
+
+static void uart00_modem_status(struct uart_info *info)
+{
+	unsigned int status;
+	struct uart_icount *icount = &info->port->icount;
+
+
+	status = UART_GET_MSR(info->port);
+
+	if (!status & (UART_MSR_DCTS_MSK | UART_MSR_DDSR_MSK | 
+		       UART_MSR_TERI_MSK | UART_MSR_DDCD_MSK))
+		return;
+
+	if (status & UART_MSR_DDCD_MSK) {
+		icount->dcd++;
+#ifdef CONFIG_HARD_PPS
+		if ((info->flags & ASYNC_HARDPPS_CD) &&
+		    (status & UART_MSR_DCD_MSK))
+			hardpps();
+#endif
+		if (info->flags & ASYNC_CHECK_CD) {
+			if (status & UART_MSR_DCD_MSK)
+				wake_up_interruptible(&info->open_wait);
+			else if (!((info->flags & ASYNC_CALLOUT_ACTIVE) &&
+				   (info->flags & ASYNC_CALLOUT_NOHUP))) {
+				if (info->tty)
+					tty_hangup(info->tty);
+			}
+		}
+	}
+
+	if (status & UART_MSR_DDSR_MSK)
+		icount->dsr++;
+
+	if (status & UART_MSR_DCTS_MSK) {
+		icount->cts++;
+
+		if (info->flags & ASYNC_CTS_FLOW) {
+			status &= UART_MSR_CTS_MSK;
+
+			if (info->tty->hw_stopped) {
+				if (status) {
+					info->tty->hw_stopped = 0;
+					info->ops->start_tx(info->port, 1, 0);
+					uart_event(info, EVT_WRITE_WAKEUP);
+				}
+			} else {
+				if (!status) {
+					info->tty->hw_stopped = 1;
+					info->ops->stop_tx(info->port, 0);
+				}
+			}
+		}
+	}
+	wake_up_interruptible(&info->delta_msr_wait);
+
+}
+
+static void uart00_int(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct uart_info *info = dev_id;
+	unsigned int status, pass_counter = 0;
+
+	status = UART_GET_INT_STATUS(info->port);
+	do {
+
+		if (status & UART_ISR_RI_MSK)
+			uart00_rx_chars(info, regs);
+		if (status & (UART_ISR_TI_MSK | UART_ISR_TII_MSK))
+			uart00_tx_chars(info);
+		if (status & UART_ISR_MI_MSK)
+			uart00_modem_status(info);
+		if (pass_counter++ > UART00_ISR_PASS_LIMIT)
+			break;
+
+		status = UART_GET_INT_STATUS(info->port);
+	} while (status);
+}
+
+static u_int uart00_tx_empty(struct uart_port *port)
+{
+	return UART_GET_TSR(port) & UART_TSR_TX_LEVEL_MSK? 0 : TIOCSER_TEMT;
+}
+
+static u_int uart00_get_mctrl(struct uart_port *port)
+{
+	unsigned int result = 0;
+	unsigned int status;
+
+	status = UART_GET_MSR(port);
+	if (status & UART_MSR_DCD_MSK)
+		result |= TIOCM_CAR;
+	if (status & UART_MSR_DSR_MSK)
+		result |= TIOCM_DSR;
+	if (status & UART_MSR_CTS_MSK)
+		result |= TIOCM_CTS;
+	if (status & UART_MSR_RI_MSK)
+		result |= TIOCM_RI;
+
+	return result;
+}
+
+static void uart00_set_mctrl_null(struct uart_port *port, u_int mctrl)
+{
+}
+
+static void uart00_break_ctl(struct uart_port *port, int break_state)
+{
+	unsigned int mcr;
+
+	mcr = UART_GET_MCR(port);
+	if (break_state == -1)
+		mcr |= UART_MCR_BR_MSK;
+	else
+		mcr &= ~UART_MCR_BR_MSK;
+	UART_PUT_MCR(port, mcr);
+}
+
+static inline u_int uart_calculate_quot(struct uart_info *info, u_int baud)
+{
+	u_int quot;
+
+	/* Special case: B0 rate */
+	if (!baud)
+		baud = 9600;
+
+	quot = (info->port->uartclk / (16 * baud)-1)  ;
+
+	return quot;
+}
+static void uart00_change_speed(struct uart_port *port, u_int cflag, u_int iflag, u_int quot)
+{
+	u_int uart_mc=0, old_ies;
+	unsigned long flags;
+
+#ifdef DEBUG
+	printk("uart00_set_cflag(0x%x) called\n", cflag);
+#endif
+	/* byte size and parity */
+	switch (cflag & CSIZE) {
+	case CS5: uart_mc = UART_MC_CLS_CHARLEN_5; break;
+	case CS6: uart_mc = UART_MC_CLS_CHARLEN_6; break;
+	case CS7: uart_mc = UART_MC_CLS_CHARLEN_7; break;
+	default:  uart_mc = UART_MC_CLS_CHARLEN_8; break; // CS8
+	}
+	if (cflag & CSTOPB)
+		uart_mc|= UART_MC_ST_TWO;
+	if (cflag & PARENB) {
+		uart_mc |= UART_MC_PE_MSK;
+		if (!(cflag & PARODD))
+			uart_mc |= UART_MC_EP_MSK;
+	}
+
+	port->read_status_mask = UART_RDS_OE_MSK;
+	if (iflag & INPCK)
+		port->read_status_mask |= UART_RDS_FE_MSK | UART_RDS_PE_MSK;
+	if (iflag & (BRKINT | PARMRK))
+		port->read_status_mask |= UART_RDS_BI_MSK;
+
+	/*
+	 * Characters to ignore
+	 */
+	port->ignore_status_mask = 0;
+	if (iflag & IGNPAR)
+		port->ignore_status_mask |= UART_RDS_FE_MSK | UART_RDS_PE_MSK;
+	if (iflag & IGNBRK) {
+		port->ignore_status_mask |= UART_RDS_BI_MSK;
+		/*
+		 * If we're ignoring parity and break indicators,
+		 * ignore overruns to (for real raw support).
+		 */
+		if (iflag & IGNPAR)
+			port->ignore_status_mask |= UART_RDS_OE_MSK;
+	}
+
+	/* first, disable everything */
+	save_flags(flags); cli();
+	old_ies = UART_GET_IES(port); 
+
+	if ((port->flags & ASYNC_HARDPPS_CD) ||
+	    (cflag & CRTSCTS) || !(cflag & CLOCAL))
+		old_ies |= UART_IES_ME_MSK;
+
+
+	/* Set baud rate */
+	UART_PUT_DIV_LO(port, (quot & 0xff));
+	UART_PUT_DIV_HI(port, ((quot & 0xf00) >> 8));
+   
+
+	UART_PUT_MC(port, uart_mc);
+	UART_PUT_IES(port, old_ies);
+
+	restore_flags(flags);
+}
+
+static int uart00_startup(struct uart_port *port, struct uart_info *info)
+{
+	int retval;
+
+	/* 
+	 * Use iobase to store a pointer to info. We need this to start a 
+	 * transmission as the tranmittr interrupt is only generated on
+	 * the transition to the idle state 
+	 */
+
+	port->iobase=(u_int)info;
+	
+	/*
+	 * Allocate the IRQ
+	 */
+	retval = request_irq(port->irq, uart00_int, 0, "uart00", info);
+	if (retval)
+		return retval;
+
+	/*
+	 * Finally, enable interrupts. Use the TII interrupt to minimise 
+	 * the number of interrupts generated. If higher performance is 
+	 * needed, consider using the TI interrupt with a suitable FIFO
+	 * threshold
+	 */
+	UART_PUT_IES(port, UART_IES_RE_MSK | UART_IES_TIE_MSK);
+
+	return 0;
+}
+
+static void uart00_shutdown(struct uart_port *port, struct uart_info *info)
+{
+	/*
+	 * disable all interrupts, disable the port
+	 */
+	UART_PUT_IEC(port, 0xff);
+
+	/* disable break condition and fifos */
+	UART_PUT_MCR(port, UART_GET_MCR(port) &~UART_MCR_BR_MSK);
+
+	/*
+	 * Free the interrupt
+	 */
+	free_irq(port->irq, info);
+}
+
+static const char *uart00_type(struct uart_port *port)
+{
+	return port->type == PORT_UART00 ? "UART00" : NULL;
+}
+
+/*
+ * Release the memory region(s) being used by 'port'
+ */
+static void uart00_release_port(struct uart_port *port)
+{
+	release_mem_region(port->mapbase, UART_PORT_SIZE);
+
+#ifdef CONFIG_ARCH_CAMELOT
+	if(port->membase!=(void*)IO_ADDRESS(EXC_UART00_BASE)){
+		iounmap(port->membase);
+	}
+#endif
+}
+
+/*
+ * Request the memory region(s) being used by 'port'
+ */
+static int uart00_request_port(struct uart_port *port)
+{
+	int result;
+
+	result = request_mem_region(port->mapbase, UART_PORT_SIZE,
+				    "serial_uart00") != NULL ? 0 : -EBUSY;
+	if (result)
+		return result;
+
+	port->membase = ioremap(port->mapbase, SZ_4K);
+	if (!port->membase) {
+		printk(KERN_ERR "serial00: cannot map io memory\n");
+		release_mem_region(port->mapbase, UART_PORT_SIZE);
+	}
+
+	return port->membase ? 0 : -ENOMEM;
+}
+
+/*
+ * Configure/autoconfigure the port.
+ */
+static void uart00_config_port(struct uart_port *port, int flags)
+{
+	if (flags & UART_CONFIG_TYPE) {
+		if (uart00_request_port(port) == 0)
+			port->type = PORT_UART00;
+	}
+}
+
+/*
+ * verify the new serial_struct (for TIOCSSERIAL).
+ */
+static int uart00_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	int ret = 0;
+	if (ser->type != PORT_UNKNOWN && ser->type != PORT_UART00)
+		ret = -EINVAL;
+	if (ser->irq < 0 || ser->irq >= NR_IRQS)
+		ret = -EINVAL;
+	if (ser->baud_base < 9600)
+		ret = -EINVAL;
+	return ret;
+}
+
+static struct uart_ops uart00_pops = {
+	tx_empty:	uart00_tx_empty,
+	set_mctrl:	uart00_set_mctrl_null,
+	get_mctrl:	uart00_get_mctrl,
+	stop_tx:	uart00_stop_tx,
+	start_tx:	uart00_start_tx,
+	stop_rx:	uart00_stop_rx,
+	enable_ms:	uart00_enable_ms,
+	break_ctl:	uart00_break_ctl,
+	startup:	uart00_startup,
+	shutdown:	uart00_shutdown,
+	change_speed:	uart00_change_speed,
+	type:		uart00_type,
+	release_port:	uart00_release_port,
+	request_port:	uart00_request_port,
+	config_port:	uart00_config_port,
+	verify_port:	uart00_verify_port,
+};
+
+#ifdef CONFIG_ARCH_CAMELOT
+static struct uart_port epxa10db_port = {
+	membase:	(void*)IO_ADDRESS(EXC_UART00_BASE),
+	mapbase:        EXC_UART00_BASE,
+	iotype:		SERIAL_IO_MEM,
+	irq:		IRQ_UART,
+	uartclk:	EXC_AHB2_CLK_FREQUENCY,
+	fifosize:	16,
+	ops:		&uart00_pops,
+	flags:          ASYNC_BOOT_AUTOCONF,
+};
+#endif
+
+#ifdef CONFIG_SERIAL_UART00_CONSOLE
+#ifdef used_and_not_const_char_pointer
+static int uart00_console_read(struct uart_port *port, char *s, u_int count)
+{
+	unsigned int status;
+	int c;
+#ifdef DEBUG
+	printk("uart00_console_read() called\n");
+#endif
+
+	c = 0;
+	while (c < count) {
+		status = UART_GET_RSR(port);
+ 		if (UART_RX_DATA(status)) {
+			*s++ = UART_GET_CHAR(port);
+			c++;
+		} else {
+			// nothing more to get, return
+			return c;
+		}
+	}
+	// return the count
+	return c;
+}
+#endif
+static void uart00_console_write(struct console *co, const char *s, unsigned count)
+{
+#ifdef CONFIG_ARCH_CAMELOT
+	struct uart_port *port = &epxa10db_port;
+	unsigned int status, old_ies;
+	int i;
+
+	/*
+	 *	First save the CR then disable the interrupts
+	 */
+	old_ies = UART_GET_IES(port);
+	UART_PUT_IEC(port,0xff);
+
+	/*
+	 *	Now, do each character
+	 */
+	for (i = 0; i < count; i++) {
+		do {
+			status = UART_GET_TSR(port);
+		} while (!UART_TX_READY(status));
+		UART_PUT_CHAR(port, s[i]);
+		if (s[i] == '\n') {
+			do {
+				status = UART_GET_TSR(port);
+			} while (!UART_TX_READY(status));
+			UART_PUT_CHAR(port, '\r');
+		}
+	}
+
+	/*
+	 *	Finally, wait for transmitter to become empty
+	 *	and restore the IES
+	 */
+	do {
+		status = UART_GET_TSR(port);
+	} while (status & UART_TSR_TX_LEVEL_MSK);
+	UART_PUT_IES(port, old_ies);
+#endif
+}
+
+static kdev_t uart00_console_device(struct console *co)
+{
+	return MKDEV(SERIAL_UART00_MAJOR, SERIAL_UART00_MINOR + co->index);
+}
+
+static int uart00_console_wait_key(struct console *co)
+{
+#ifdef CONFIG_ARCH_CAMELOT
+	struct uart_port *port = &epxa10db_port;
+	unsigned int status;
+
+	do {
+		status = UART_GET_RSR(port);
+	} while (!UART_RX_DATA(status));
+	return UART_GET_CHAR(port);
+#else
+	return 0;
+#endif
+}
+
+static void /*__init*/ uart00_console_get_options(struct uart_port *port, int *baud, int *parity, int *bits)
+{
+	u_int uart_mc, quot;
+	uart_mc= UART_GET_MC(port);
+
+	*parity = 'n';
+	if (uart_mc & UART_MC_PE_MSK) {
+		if (uart_mc & UART_MC_EP_MSK)
+			*parity = 'e';
+		else
+			*parity = 'o';
+	}
+
+	switch (uart_mc & UART_MC_CLS_MSK){
+
+	case UART_MC_CLS_CHARLEN_5:
+		*bits = 5;
+		break;
+	case UART_MC_CLS_CHARLEN_6:
+		*bits = 6;
+		break;
+	case UART_MC_CLS_CHARLEN_7:
+		*bits = 7;
+		break;
+	case UART_MC_CLS_CHARLEN_8:
+		*bits = 8;
+		break;
+	}
+	quot = UART_GET_DIV_LO(port) | (UART_GET_DIV_HI(port) << 8);
+	*baud = port->uartclk / (16 *quot );
+}
+
+static int __init uart00_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port;
+	int baud = 38400;
+	int bits = 8;
+	int parity = 'n';
+	int flow= 'n';
+
+#ifdef CONFIG_ARCH_CAMELOT
+	/*
+	 * Check whether an invalid uart number has been specified, and
+	 * if so, search for the first available port that does have
+	 * console support.
+	 */
+	port = &epxa10db_port;
+	co->index = 0;
+#else
+	return -ENODEV;
+#endif
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+	else
+		uart00_console_get_options(port, &baud, &parity, &bits);
+
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+static struct console uart00_console = {
+	name:           SERIAL_UART00_NAME,
+	write:		uart00_console_write,
+#ifdef used_and_not_const_char_pointer
+	read:		uart00_console_read,
+#endif
+	device:		uart00_console_device,
+	wait_key:	uart00_console_wait_key,
+	setup:		uart00_console_setup,
+	flags:		CON_PRINTBUFFER,
+	index:		0,
+};
+
+void __init uart00_console_init(void)
+{
+	register_console(&uart00_console);
+}
+
+#define UART00_CONSOLE	&uart00_console
+#else
+#define UART00_CONSOLE	NULL
+#endif
+
+static struct uart_driver uart00_reg = {
+	owner:                  NULL,
+	normal_major:		SERIAL_UART00_MAJOR,
+	normal_name:		SERIAL_UART00_NAME,
+	normal_driver:		&normal,
+	callout_major:		CALLOUT_UART00_MAJOR,
+	callout_name:		CALLOUT_UART00_NAME,
+	callout_driver:		&callout,
+	table:			uart00_table,
+	termios:		uart00_termios,
+	termios_locked:		uart00_termios_locked,
+	minor:			SERIAL_UART00_MINOR,
+	nr:			UART_NR,
+#ifdef CONFIG_ARCH_CAMELOT
+	port:			&epxa10db_port,
+#endif
+	state:			NULL,
+	cons:			UART00_CONSOLE,
+};
+
+static int __init uart00_init(void)
+{
+	printk(KERN_WARNING "serial_uart00:Using temporary major/minor pairs - these WILL change in the future\n");
+
+	return uart_register_driver(&uart00_reg);
+}
+
+
+__initcall(uart00_init);
diff -urN uClinux-dist/linux-2.4.x/drivers/video/fbcon-cfb4.c linux-2.4.x/drivers/video/fbcon-cfb4.c
--- uClinux-dist/linux-2.4.x/drivers/video/fbcon-cfb4.c	2004-02-17 20:53:38.000000000 +0800
+++ linux-2.4.x/drivers/video/fbcon-cfb4.c	2004-03-29 22:15:53.000000000 +0800
@@ -38,10 +38,17 @@
     0xf000,0xf00f,0xf0f0,0xf0ff,
     0xff00,0xff0f,0xfff0,0xffff
 #elif defined(__LITTLE_ENDIAN)
+  #if defined(CONFIG_BOARD_MBA44)
+    0x0000,0x0f00,0xf000,0xff00,
+    0x000f,0x0f0f,0xf00f,0xff0f,
+    0x00f0,0x0ff0,0xf0f0,0xfff0,
+    0x00ff,0x0fff,0xf0ff,0xffff
+  #else
     0x0000,0xf000,0x0f00,0xff00,
     0x00f0,0xf0f0,0x0ff0,0xfff0,
     0x000f,0xf00f,0x0f0f,0xff0f,
     0x00ff,0xf0ff,0x0fff,0xffff
+  #endif
 #else
 #error FIXME: No endianness??
 #endif
diff -urN uClinux-dist/linux-2.4.x/drivers/video/fbmem.c linux-2.4.x/drivers/video/fbmem.c
--- uClinux-dist/linux-2.4.x/drivers/video/fbmem.c	2004-02-17 20:53:38.000000000 +0800
+++ linux-2.4.x/drivers/video/fbmem.c	2004-03-28 21:17:56.000000000 +0800
@@ -849,7 +849,7 @@
 
 	if (first) {
 		first = 0;
-#ifdef CONFIG_CONSOLE
+#ifdef CONFIG_VT_CONSOLE
 		take_over_console(&fb_con, first_fb_vc, last_fb_vc, fbcon_is_default);
 #endif
 	}
diff -urN uClinux-dist/linux-2.4.x/drivers/video/Makefile linux-2.4.x/drivers/video/Makefile
--- uClinux-dist/linux-2.4.x/drivers/video/Makefile	2004-02-17 20:53:38.000000000 +0800
+++ linux-2.4.x/drivers/video/Makefile	2004-03-28 20:23:45.000000000 +0800
@@ -87,7 +87,7 @@
 obj-$(CONFIG_FB_MAXINE)           += maxinefb.o
 obj-$(CONFIG_FB_TX3912)           += tx3912fb.o
 obj-$(CONFIG_FB_AU1100)		  += au1100fb.o fbgen.o
-obj-$(CONFIG_FB_S3C44B0X)	  += s3c44b0xfb.o fbgen.o
+obj-$(CONFIG_FB_S3C44B0X)	  += s3c44b0xfb.o #fbgen.o
 
 subdir-$(CONFIG_STI_CONSOLE)      += sti
 ifeq ($(CONFIG_STI_CONSOLE),y)
diff -urN uClinux-dist/linux-2.4.x/drivers/video/s3c44b0xfb.c linux-2.4.x/drivers/video/s3c44b0xfb.c
--- uClinux-dist/linux-2.4.x/drivers/video/s3c44b0xfb.c	2004-02-17 20:53:42.000000000 +0800
+++ linux-2.4.x/drivers/video/s3c44b0xfb.c	2004-03-29 01:27:44.000000000 +0800
@@ -1,761 +1,452 @@
 /*
- * linux/drivers/video/s3c44b0xfb.c 
+ *  linux/drivers/video/s3c44b0fb.c
  *
- * Copyright (C) 2003 Stefan Macher <macher@sympat.de>
- *                    Alexander Assel <assel@sympat.de>
+ *  tpu.
  *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file COPYING in the main directory of this archive
- * for more details.
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *  Framebuffer driver for the S3C44B0X processors.
  */
-
-/* TODO (roughly in order of priority):
- * color gray / (monochrom) 2 bpp (8 bpp color)
- * configuration via modul parameters and i/o control 
-*/
+#define	LCD_GRAY_16
 
 #include <linux/module.h>
 #include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/string.h>
-#include <linux/mm.h>
-#include <linux/tty.h>
 #include <linux/slab.h>
-#include <linux/delay.h>
 #include <linux/fb.h>
 #include <linux/init.h>
-#include "linux/config.h"
 
 #include <video/fbcon.h>
-
-#include "s3c44b0xfb.h"
-#include "asm-armnommu/arch-S3C44B0X/s3c44b0x.h"
-
-/*---------------------------------*/
-/* global parameters               */
-/*---------------------------------*/
-static int s3c44b0x_lcd_index; /*!< index within panels; will be set according to panel_name */
-#if MODULE /* in case of module the panel name is set as module parameter */
-static u8 panel_valid = 0;
-static unsigned char *panel_name = NULL;
-#else /* FIXME this should be similar to module but as linux boot line parameter */
-static u8 panel_valid = 1;
-static unsigned char *panel_name = "LCDBA7T11M4_320x240x8";
+#ifdef	LCD_GRAY_16
+#include <video/fbcon-cfb4.h>
+#else
+#include <video/fbcon-cfb8.h>
 #endif
-static u8 bootloader = 0; /* use bootloader settings for LCD controller setup */
-static struct fb_ops s3c44b0xfb_ops;
-struct fbgen_hwswitch s3c44b0xfb_switch;
-
-
-/*---------------------------------*/
-/* parameter decleration           */
-/*---------------------------------*/
-
-#if MODULE
-MODULE_PARM(panel_name, "s");
-MODULE_PARM_DESC(panel_name, "Name of the connected panel\nknown panels are: LCDBA7T11M4_320x240x8");
-MODULE_PARM(bootloader, "b");
-MODULE_PARM_DESC(bootloader, "Set it to 1 if you want the device driver to use the parameters that has the bootloader configured\n");
-MODULE_AUTHOR("Alexander Assel  <asselv@sympat.de> Stefan Macher <macher@sympat.de>");
-MODULE_DESCRIPTION("S3C44B0X LCD framebuffer device driver");
-#endif
-/*--------------------------------*/
-
-
-
-/**************************************
- * definition of the known displays
- **************************************/
-/* if you add some new panels in the struct bellow change also the
-   module description on the end of this file
-*/
-struct known_lcd_panels panels[] = { {
-	/* holds the lcd panel name */
-	"LCDBA7T11M4_320x240x8",
-	/* clkval */
-	15, /* FIXME this is based on a cpu clock of 60,75 MHz */
-	/* Determine the VLINE pulses high level width [clocks] valid values 4, 8, 12 and 16 */
-	16,
-	/* Determine the delay between VLINE and VCLOCK [clocks] valid values 4, 8, 12 and 16 */
-	16,
-	/* Determine toggle rate of VM 0 -> each frame 1 -> defined by MVAL */
-	0,
-	/* display mode is 8 bit single scan */
-	2,
-       /* controls the poloarity of VCLOCK active edge 0 -> falling edge 1 -> rising edge */
-	0,
-	/* indicate the line pulse polarity 0 -> normal 1 -> inverted */
-	0,
-	/* indicate the frame pulse polarity 0 -> normal 1 -> inverted */
-	0,
-	/* indicates the video data polarity 0 -> normal 1 -> inverted */
-	0,
-	/* indicates the blank time in one horizontal line duration */
-	10,
-	/* LCD self refrash mode enable */
-	0,
-	/* byte swap control */
-#ifdef CONFIG_CPU_BIG_ENDIAN
-	0,
-#else	
-	1,
-#endif
-  /* defines the rate at which the vm signal will toggle */
-	0x0D, 
-  /* display width in pixels */
-	320,
-  /* display height in pixels */
-	240,
-  /* bits per pixel valid is 1 (mono), 2 (gray), 4 (gray) and 8 (color) */
-	8,
-	119, /* hozval */
-	239, /* lineval */
-	S3C44B0X_PDATC, /* port register for enabling the display */
-	(1<<8), /* mask port c pin 8 */
-	(1<<8), /* set port c pin 8 to high */
-	S3C44B0X_PCONC, /* port control register for setting PORTC.8 to output */
-	(3<<16), /* mask port c pin8 control */
-	(1<<16) /* set port c pin 8 control to output */
-}
-};
- 
-
-static struct s3c44b0xfb_info fb_info;
-static struct s3c44b0xfb_par current_par;
-static int current_par_valid = 0;
-
-int s3c44b0xfb_init(void);
-int s3c44b0xfb_setup(char*);
 
-/* ------------------- chipset specific functions -------------------------- */
+#include <asm/hardware.h>
+#include <asm/mach-types.h>
+#include <asm/uaccess.h>
+
+static struct s3c44b0fb_info {
+	struct fb_info		fb;
+	int			currcon;
+} *cfb;
 
+#define CMAP_SIZE	256
 
-static void s3c44b0xfb_detect(void)
+/*
+ *    Set a single color register. Return != 0 for invalid regno.
+ */
+static int
+s3c44b0fb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,
+		     u_int transp, struct fb_info *info)
 {
-        /*
-	 * Yeh, well, we're not going to change any settings so we're
-	 * always stuck with the default ...
-	 */
+	//TODO
+	return 0;
 }
-
-static int s3c44b0xfb_encode_fix(struct fb_fix_screeninfo *fix, const void *_par,
-			       struct fb_info_gen *_info)
+		    
+/*
+ * Set the colormap
+ */
+static int
+s3c44b0fb_set_cmap(struct fb_cmap *cmap, int kspc, int con,
+		    struct fb_info *info)
 {
-    /*
-     *  This function should fill in the 'fix' structure based on the values
-     *  in the `par' structure.
-     */
-	struct s3c44b0xfb_info *info = (struct s3c44b0xfb_info *) _info;
-        struct s3c44b0xfb_par *par = (struct s3c44b0xfb_par *) _par;
-	struct fb_var_screeninfo *var = &par->var;
-
-	memset(fix, 0, sizeof(struct fb_fix_screeninfo));
-
-	fix->smem_start = info->fb_phys;
-	fix->smem_len = info->fb_size;
-	fix->type = FB_TYPE_PACKED_PIXELS;
-	fix->type_aux = 0;
-        fix->visual = (var->bits_per_pixel == 1) ?
-	       	FB_VISUAL_MONO01 : FB_VISUAL_TRUECOLOR;
-	fix->ywrapstep = 0;
-	fix->xpanstep = 0;
-	fix->ypanstep = 0;
-	fix->line_length = current_par.line_length;
-	return 0;
+	struct s3c44b0fb_info *cfb = (struct s3c44b0fb_info *)info;
+	struct fb_cmap *dcmap = &fb_display[con].cmap;
+	int err = 0;
 
-}
+	/* no colormap allocated? */
+	if (!dcmap->len)
+		err = fb_alloc_cmap(dcmap, CMAP_SIZE, 0);
 
-static int s3c44b0xfb_decode_var(const struct fb_var_screeninfo *var, void *par,
-			       struct fb_info_gen *info)
-{
-    /*
-     *  Get the video params out of 'var'. If a value doesn't fit, round it up,
-     *  if it's too big, return -EINVAL.
-     *
-     *  Suggestion: Round up in the following order: bits_per_pixel, xres,
-     *  yres, xres_virtual, yres_virtual, xoffset, yoffset, grayscale,
-     *  bitfields, horizontal timing, vertical timing.
-     */
-	struct known_lcd_panels *p_lcd = &panels[s3c44b0x_lcd_index];
-	if (var->xres != p_lcd->width ||
-	    var->yres != p_lcd->height)
-	{
-		return -EINVAL;
+	if (!err && con == cfb->currcon) {
+		err = fb_set_cmap(cmap, kspc, s3c44b0fb_setcolreg, &cfb->fb);
+		dcmap = &cfb->fb.cmap;
 	}
 
-	if(var->bits_per_pixel != p_lcd->bpp) 
-	{
-		return -EINVAL;
-	}
-	return 0;
+	if (!err)
+		fb_copy_cmap(cmap, dcmap, kspc ? 0 : 1);
 
+	return err;
 }
 
-static int s3c44b0xfb_encode_var(struct fb_var_screeninfo *var, const void *_par,
-			       struct fb_info_gen *info)
-{
-    /*
-     *  Fill the 'var' structure based on the values in 'par' and maybe other
-     *  values read out of the hardware.
-     */
-	struct s3c44b0xfb_par *par = (struct s3c44b0xfb_par*)_par;
+/*
+ *    Set the User Defined Part of the Display
+ */
+static int
+s3c44b0fb_set_var(struct fb_var_screeninfo *var, int con,
+		   struct fb_info *info)
+{
+	struct display *display;
+	unsigned int lcdcon, syscon;
+	int chgvar = 0;
 
-	memcpy(var, &par->var, sizeof(struct fb_var_screeninfo));
-   
-	return 0;
-}
+	if (var->activate & FB_ACTIVATE_TEST)
+		return 0;
 
-static void s3c44b0xfb_get_par(void *_par, struct fb_info_gen *info)
-{
-	/*
-	 *  Fill the hardware's 'par' structure.
-	 */
-	
-	struct s3c44b0xfb_par *par = (struct s3c44b0xfb_par*)_par;
-	if (current_par_valid)
-		memcpy(par, &current_par, sizeof(struct s3c44b0xfb_par));
-}
-
-static void s3c44b0xfb_set_par(const void *par, struct fb_info_gen *info)
-{
-    /*
-     *  Set the hardware according to 'par'.
-     */
-    /* nothing to do: we don't change any settings */
-  
-}
-
-static int s3c44b0xfb_getcolreg(unsigned regno, unsigned *red, unsigned *green,
-			 unsigned *blue, unsigned *transp,
-			 struct fb_info *_info)
-{
-    /*
-     *  Read a single color register and split it into colors/transparent.
-     *  The return values must have a 16 bit magnitude.
-     *  Return != 0 for invalid regno.
-     */
-	struct s3c44b0xfb_info *info = (struct s3c44b0xfb_info *) _info;
-	u32 blueval, redval, greenval;
-	u8 helpvalue;
-	blueval = inw(S3C44B0X_BLUELUT);
-	redval = inw(S3C44B0X_REDLUT);
-	greenval = inw(S3C44B0X_GREENLUT);
-	switch(info->gen.info.var.bits_per_pixel)
-	{
-	case 1:
-		if(regno > 1)
-			return 1; /* error */
-		if(regno == 0)
-			*red = *green = *blue = 0;
-		else
-			*red = *green = *blue = 0xFFFF;
-		break;
-	case 2:
-		if(regno > 4)
-			return 1; /* error */
-	
-		blueval = (blueval >> (regno<<2)) & 0xF;
-		*red = *green = *blue = 0x1111 * blueval; /* 0xFFFF / 0xF = 0x1111 */
-		break;
-	case 4:
-		if(regno > 16)
-			return 1; /* error */
-		*red = *green = *blue = 0x1111 * regno; /* 0xFFFF / 0xF = 0x1111 */
-		break;
-	case 8:
-		if(regno > 256)
-			return 1;
-		helpvalue = regno >> 5;
-		redval = (redval >> (helpvalue<<2)) & 0xF;
-		*red = redval * 0x1111;
-		helpvalue = (regno >> 2) & 0x7;
-		greenval = (greenval >> (helpvalue<<2)) & 0xF;
-		*green = greenval * 0x1111;
-		helpvalue = regno & 0x03;
-		blueval = (blueval >> (helpvalue<<2)) & 0xF;
-		*blue = blueval * 0x1111;
-		break;
-	default:
-		return 1; 
-	}
-	return 0;
-}
+	if ((var->activate & FB_ACTIVATE_MASK) != FB_ACTIVATE_NOW)
+		return -EINVAL;
 
-static int s3c44b0xfb_setcolreg(unsigned regno, unsigned red, unsigned green,
-			      unsigned blue, unsigned transp,
-			      struct fb_info *_info)
-{
-    /*
-     *  Set a single color register. The values supplied have a 16 bit
-     *  magnitude.
-     *  Return != 0 for invalid regno.
-     */
-	struct s3c44b0xfb_info *info = (struct s3c44b0xfb_info *) _info;
-	unsigned int helpvalue;
-	u32 blueval, redval, greenval;
-	blueval = inw(S3C44B0X_BLUELUT);
-	redval = inw(S3C44B0X_REDLUT);
-	greenval = inw(S3C44B0X_GREENLUT);
-	switch(info->gen.info.var.bits_per_pixel)
-	{
+	if (cfb->fb.var.xres != var->xres)
+		chgvar = 1;
+	if (cfb->fb.var.yres != var->yres)
+		chgvar = 1;
+	if (cfb->fb.var.xres_virtual != var->xres_virtual)
+		chgvar = 1;
+	if (cfb->fb.var.yres_virtual != var->yres_virtual)
+		chgvar = 1;
+	if (cfb->fb.var.bits_per_pixel != var->bits_per_pixel)
+		chgvar = 1;
+
+	if (con < 0) {
+		display = cfb->fb.disp;
+		chgvar = 0;
+	} else {
+		display = fb_display + con;
+	}
+
+	var->transp.msb_right	= 0;
+	var->transp.offset	= 0;
+	var->transp.length	= 0;
+	var->red.msb_right	= 0;
+	var->red.offset		= 5;
+	var->red.length		= 3;
+	var->green.msb_right	= 0;
+	var->green.offset	= 2;
+	var->green.length	= 3;
+	var->blue.msb_right	= 0;
+	var->blue.offset	= 0;
+	var->blue.length	= 2;
+
+	switch (var->bits_per_pixel) {
+#ifdef FBCON_HAS_MFB
 	case 1:
-		return -EINVAL;
+		cfb->fb.fix.visual	= FB_VISUAL_MONO01;
+		display->dispsw		= &fbcon_mfb;
+		display->dispsw_data	= NULL;
 		break;
+#endif
+#ifdef FBCON_HAS_CFB2
 	case 2:
-		if((regno > 4) || (red != green) || (red != blue)) /* FIXME: maybe wrong */
-			return 1;
-		helpvalue = (unsigned int)(blue / 0x1111) & 0xF;
-		blueval &= ~(0xF << (regno<<2));
-		blueval |= (helpvalue << (regno<<2));
-		outl(blueval, S3C44B0X_BLUELUT);
+		cfb->fb.fix.visual	= FB_VISUAL_PSEUDOCOLOR;
+		display->dispsw		= &fbcon_cfb2;
+		display->dispsw_data	= NULL;
 		break;
+#endif
+#ifdef FBCON_HAS_CFB4
 	case 4:
-		return -EINVAL;
+		cfb->fb.fix.visual	= FB_VISUAL_PSEUDOCOLOR;
+		display->dispsw		= &fbcon_cfb4;
+		display->dispsw_data	= NULL;
 		break;
+#endif
+#ifdef FBCON_HAS_CFB8
 	case 8:
-		if(regno > 256)
-			return 1;
-		helpvalue = (unsigned int)(blue / 0x1111) & 0xF;
-		blueval &= ~(0xF << ((regno&0x03)<<2));
-		blueval |= (helpvalue << ((regno&0x03)<<2));
-		outl(blueval, S3C44B0X_BLUELUT);
-		helpvalue = (unsigned int)(red / 0x1111) & 0xF;
-		redval &= ~(0xF << (((regno>>5)&0x7)<<2));
-		redval |= (helpvalue << (((regno>>5)&0x7)<<2));
-		outl(redval, S3C44B0X_BLUELUT);
-		helpvalue = (unsigned int)(green / 0x1111) & 0xF;
-		greenval &= ~(0xF << (((regno>>2)&0x7)<<2));
-		greenval |= (helpvalue << (((regno>>2)&0x7)<<2));
-		outl(greenval, S3C44B0X_BLUELUT);
+		cfb->fb.fix.visual	= FB_VISUAL_TRUECOLOR;
+		display->dispsw		= &fbcon_cfb8;
+		display->dispsw_data	= NULL;
 		break;
+#endif
 	default:
-		return 1;
+		return -EINVAL;
 	}
-		
-		
-    return 0;
-}
 
-static int s3c44b0xfb_pan_display(const struct fb_var_screeninfo *var,
-				struct fb_info_gen *info)
-{
-    /*
-     *  Pan (or wrap, depending on the `vmode' field) the display using the
-     *  `xoffset' and `yoffset' fields of the `var' structure.
-     *  If the values don't fit, return -EINVAL.
-     */
-	return -EINVAL;
+	display->next_line	= var->xres_virtual * var->bits_per_pixel / 8;
 
-}
+	cfb->fb.fix.line_length = display->next_line;
 
-static int s3c44b0xfb_blank(int blank_mode, struct fb_info_gen *info)
-{
-    /*
-     *  Blank the screen if blank_mode != 0, else unblank. If blank == NULL
-     *  then the caller blanks by setting the CLUT (Color Look Up Table) to all
-     *  black. Return 0 if blanking succeeded, != 0 if un-/blanking failed due
-     *  to e.g. a video mode which doesn't support it. Implements VESA suspend
-     *  and powerdown modes on hardware that supports disabling hsync/vsync:
-     *    blank_mode == 2: suspend vsync
-     *    blank_mode == 3: suspend hsync
-     *    blank_mode == 4: powerdown
-     */
-	u32 helpvalue;
-	switch(blank_mode)
-	{
-	case 2:
-		return -EINVAL;
-	case 3:
-		return -EINVAL;
-	case 4:
-		helpvalue = inw(S3C44B0X_LCDCON1);
-		outl(helpvalue&~S3C44B0X_LCDCON1_ENVID, S3C44B0X_LCDCON1); /* disable video output */
-		break;
-	default:
-		return -EINVAL;
-	}
+	display->screen_base	= cfb->fb.screen_base;
+	display->line_length	= cfb->fb.fix.line_length;
+	display->visual		= cfb->fb.fix.visual;
+	display->type		= cfb->fb.fix.type;
+	display->type_aux	= cfb->fb.fix.type_aux;
+	display->ypanstep	= cfb->fb.fix.ypanstep;
+	display->ywrapstep	= cfb->fb.fix.ywrapstep;
+	display->can_soft_blank = 1;
+	display->inverse	= 0;
+
+	cfb->fb.var		= *var;
+	cfb->fb.var.activate	&= ~FB_ACTIVATE_ALL;
+
+	/*
+	 * Update the old var.  The fbcon drivers still use this.
+	 * Once they are using cfb->fb.var, this can be dropped.
+	 *                                      --rmk
+	 */
+	display->var		= cfb->fb.var;
+
+	/*
+	 * If we are setting all the virtual consoles, also set the
+	 * defaults used to create new consoles.
+	 */
+	if (var->activate & FB_ACTIVATE_ALL)
+		cfb->fb.disp->var = cfb->fb.var;
 
-    /* ... */
-    return 0;
+	if (chgvar && info && cfb->fb.changevar)
+		cfb->fb.changevar(con);
+
+
+	fb_set_cmap(&cfb->fb.cmap, 1, s3c44b0fb_setcolreg, &cfb->fb);
+
+	return 0;
 }
 
-static void s3c44b0xfb_gen_blank(int blank_mode, struct fb_info *info)
+/*
+ * Get the currently displayed virtual consoles colormap.
+ */
+static int
+gen_get_cmap(struct fb_cmap *cmap, int kspc, int con, struct fb_info *info)
 {
-	s3c44b0xfb_blank(blank_mode, &fb_info.gen);
-	return;
+	fb_copy_cmap(&info->cmap, cmap, kspc ? 0 : 2);
+	return 0;
 }
 
-#if 0
-static void s3c44b0xfb_set_disp(const void *par, struct display *disp,
-			      struct fb_info_gen *info)
-{
-    /*
-     *  Fill in a pointer with the virtual address of the mapped frame buffer.
-     *  Fill in a pointer to appropriate low level text console operations (and
-     *  optionally a pointer to help data) for the video mode `par' of your
-     *  video hardware. These can be generic software routines, or hardware
-     *  accelerated routines specifically tailored for your hardware.
-     *  If you don't have any appropriate operations, you must fill in a
-     *  pointer to dummy operations, and there will be no text output.
-     */
-	return;
+/*
+ * Get the currently displayed virtual consoles fixed part of the display.
+ */
+static int
+gen_get_fix(struct fb_fix_screeninfo *fix, int con, struct fb_info *info)
+{
+	*fix = info->fix;
+	return 0;
 }
-#endif
 
-static void s3c44b0xfb_init_lcd_controller( struct known_lcd_panels *p_lcd)
+/*
+ * Get the current user defined part of the display.
+ */
+static int
+gen_get_var(struct fb_var_screeninfo *var, int con, struct fb_info *info)
 {
-	u32 helpvalue = 0, pagewidth=0, offsize = 0;
-	u16 hozval = 0;
-	u8 modesel = 0;
-	/*---------------------------------*/
-	/* set LCDSADDR1 to zero to disable the LCD controller */
-	/*---------------------------------*/
-	outl(helpvalue, S3C44B0X_LCDCON1);
-
-	/*---------------------------------*/
-	/* set LCDSADDR1                   */
-	/*---------------------------------*/
-	helpvalue = 0;
-	switch(p_lcd->bpp)
-	{
-	case 1:
-		modesel = 0;
-		break;
-	case 2:
-		modesel = 1;
-		break;
-	case 4:
-		modesel = 2;
-		break;
-	case 8:
-		modesel = 3;
-		break;
-	default:
-		modesel = 0;
-	}
-	helpvalue |=  (modesel & 0x03)<<27; /* MODESEL value */
-	helpvalue |= ((fb_info.fb_phys & 0x0FC00000) >> 1); /* LCDBANK addr. */
-	helpvalue |= ((fb_info.gen.info.var.xoffset + 
-		       (fb_info.gen.info.var.yoffset*fb_info.gen.info.var.xres_virtual)) & 0xFFFFF) >> 1;
-	outl(helpvalue, S3C44B0X_LCDSADDR1);
-	/*---------------------------------*/
-	/* set LCDSADDR2                   */
-	/*---------------------------------*/
-	helpvalue = 0;
-	helpvalue |= (p_lcd->bswp &0x1) << 29; /* BSWP */
-	helpvalue |= (p_lcd->mval) << 21; /* MVAL */
-	pagewidth = (p_lcd->width * p_lcd->bpp) >> 4;
-	offsize = ((fb_info.gen.info.var.xres_virtual * p_lcd->bpp) >> 4) - pagewidth;
-	helpvalue |= (((((fb_info.gen.info.var.xoffset + 
-		       (fb_info.gen.info.var.yoffset*fb_info.gen.info.var.xres_virtual)) & 0xFFFFF) >> 1) +
-		       (pagewidth + offsize) * (p_lcd->lineval +1)) & 0xFFFFF); /* LCDBASEL */
-	outl(helpvalue, S3C44B0X_LCDSADDR2);
-	/*---------------------------------*/
-	/* set LCDSADDR3                   */
-	/*---------------------------------*/
-	helpvalue = 0;
-	helpvalue |= (pagewidth & 0x1FF);
-	helpvalue |= (offsize & 0x7FF) << 9;
-	outl(helpvalue, S3C44B0X_LCDSADDR3);
-
-	/*---------------------------------*/
-	/* set LCDCON2                     */
-	/*---------------------------------*/
-	helpvalue = 0;
-	helpvalue |= (p_lcd->lineblank & 0x3FF) << 21;
-	helpvalue |= (p_lcd->hozval & 0x3FF) << 10;
-	helpvalue |= (p_lcd->lineval & 0x3FF);
-	outl(helpvalue, S3C44B0X_LCDCON2);
-	/*---------------------------------*/
-	/* set LCDCON3                     */
-	/*---------------------------------*/
-	outb((p_lcd->selfref & 0x1), S3C44B0X_LCDCON3);
-       
-	/*---------------------------------*/
-	/* set REDLUT                      */
-	/*---------------------------------*/
-	outl(0xECA86420, S3C44B0X_REDLUT);
-       /*---------------------------------*/
-	/* set GREENLUT                    */
-	/*---------------------------------*/
-	outl(0xECA86420, S3C44B0X_GREENLUT);
-	/*---------------------------------*/
-	/* set BLUELUT                     */
-	/*---------------------------------*/
-	outl(0x0000F840, S3C44B0X_BLUELUT);
-
-	/*---------------------------------*/
-	/* set LCDCON1 (also enables the LCD controller) */
-	/*---------------------------------*/
-	helpvalue = ((p_lcd->clkval&0x3FF) << 12);
-	helpvalue |= ((((p_lcd->wlh >> 2)-1) & 0x03) << 10); /* map the  wlh value and shift 10 left */
-	helpvalue |= ((((p_lcd->wdly >> 2)-1) & 0x03) << 8); /* map the wdly value and shift 8 left */
-	helpvalue |= ((p_lcd->mmode & 0x01) << 7);
-	helpvalue |= (p_lcd->dismode << 5); /* DISMODE */
-	helpvalue |= ((p_lcd->invclk&0x01) << 4);
-	helpvalue |= ((p_lcd->invline&0x01) << 3);
-	helpvalue |= ((p_lcd->invframe&0x01) << 2);
-	helpvalue |= ((p_lcd->invvd&0x01) << 1);
-	helpvalue |= 1; /* enables the display */
-	outl(helpvalue, S3C44B0X_LCDCON1);
-
-	/* switch display on by setting special port */
-	if(p_lcd->disp_on_ctrl_reg) {
-		helpvalue = inl(p_lcd->disp_on_ctrl_reg);
-		helpvalue &= ~p_lcd->disp_on_ctrl_reg_mask;
-		helpvalue |= p_lcd->disp_on_ctrl_reg_value;
-		outl(helpvalue, p_lcd->disp_on_ctrl_reg); /* set disp_on port to enable */
-	}
-	if(p_lcd->disp_on_port) {
-		helpvalue = inl(p_lcd->disp_on_port);
-		helpvalue &= ~p_lcd->disp_on_mask;
-		helpvalue |= p_lcd->disp_on_val;
-		outl(helpvalue, p_lcd->disp_on_port); /* enable display */
-	}
+	*var = info->var;
+	return 0;
 }
 
-
-/* ------------ Interfaces to hardware functions ------------ */
-
-
-struct fbgen_hwswitch s3c44b0xfb_switch = {
-	s3c44b0xfb_detect, 
-	s3c44b0xfb_encode_fix, 
-	s3c44b0xfb_decode_var, 
-	s3c44b0xfb_encode_var, 
-	s3c44b0xfb_get_par,
-	s3c44b0xfb_set_par, 
-	s3c44b0xfb_getcolreg, 
-	s3c44b0xfb_setcolreg,
-	s3c44b0xfb_pan_display,
-	s3c44b0xfb_blank,
-	NULL
+static struct fb_ops s3c44b0fb_ops = {
+	owner:		THIS_MODULE,
+	fb_set_var:	s3c44b0fb_set_var,
+	fb_set_cmap:	s3c44b0fb_set_cmap,
+	fb_get_fix:	gen_get_fix,
+	fb_get_var:	gen_get_var,
+	fb_get_cmap:	gen_get_cmap,
 };
 
-
-
-/* ------------ Hardware Independent Functions ------------ */
-
-
-    /*
-     *  Initialization
-     */
-
-int __init s3c44b0xfb_init(void)
+static int s3c44b0fb_updatevar(int con, struct fb_info *info)
 {
-	struct known_lcd_panels *p_lcd;
-	int num_panels; /* number of known LCD panels */
-	int i;
-
-	printk("S3C44B0X framebuffer init\n");
+	return -EINVAL;
+}
 
-	if( (bootloader == 0) && (panel_name == NULL) )
-	{
-		printk("S3C44B0X framebuffer driver error: No panel name specified and bootloader settings shall not be used\n");
-		return -EINVAL;
+static void s3c44b0fb_blank(int blank, struct fb_info *info)
+{
+	//TODO
+    	if (blank) {
+	} else {
 	}
+}
 
-	if(bootloader)
+/********************************************************************************/
+#define	U8	__u8
+#define	U16	__u16	 
+#define	U32	__u32
+#define	MAX749_CTRL	0x80
+#define	MAX749_ADJ	0x40
+#define	Max749AdjHi()	outl(inl(S3C44B0X_PDATC)|MAX749_ADJ, S3C44B0X_PDATC)
+#define	Max749AdjLo()	outl(inl(S3C44B0X_PDATC)&~MAX749_ADJ, S3C44B0X_PDATC)
+#define	Max749CtrlHi()	outl(inl(S3C44B0X_PDATC)|MAX749_CTRL, S3C44B0X_PDATC)
+#define	Max749CtrlLo()	outl(inl(S3C44B0X_PDATC)&~MAX749_CTRL, S3C44B0X_PDATC)
+
+static void Max749Rst(void)
+{
+	unsigned char i;
+	Max749AdjHi();
+	Max749CtrlLo();
+	i = 100;
+	while(i--);	
+	Max749CtrlHi(); 
+}
+
+static void Max749Up(U16 cnt)
+{	
+	unsigned char i;
+	
+	Max749Rst();
+	for(; cnt; cnt--)
 	{
-		printk("S3C44B0X framebuffer driver error: Using of bootloader settings not yet implemented\n");
-		return 0; /* FIXME read out the parms from the controller and store them into the structs */
+		Max749AdjLo();
+		i = 10;
+		while(i--);
+		Max749AdjHi();
+		i = 10;
+		while(i--);
 	}
+}
 
-	num_panels = sizeof(panels)/sizeof(struct known_lcd_panels);
-	/* Get the panel name, everything else is fixed */
-	for (i=0; i<num_panels; i++) 
-	{
-		if (!strcmp(panel_name, panels[i].lcd_panel_name)) 
-		{
-			s3c44b0x_lcd_index = i;
-			panel_valid = 1;
-			break;
-		}
-	}
+#define	SCR_XSIZE	240//320
+#define	SCR_YSIZE	320//240
+#define	LCD_XSIZE	240//320
+#define	LCD_YSIZE	320//240
+
+#ifdef	LCD_GRAY_16
+#define	LCD_DEPTH	4
+#define	LCD_BUF_SIZE	((SCR_XSIZE*SCR_YSIZE)>>1)
+#else
+#define	LCD_DEPTH	8
+#define	LCD_BUF_SIZE	((SCR_XSIZE*SCR_YSIZE))
+#endif
 
-	if(!panel_valid)
-	{
-		printk("S3C44B0X framebuffer driver error: Invalid panel name selected\n");
-		return -EINVAL;
-	}
+/////////////////////	LCDCON1
+#define	CLKVAL		(5<<12)		//VCLK = MCLK/(2*CLKVAL)
+#define	WLH		(3<<10)		//16 clock
+#define	WDLY		(3<<8)		//16 clock
+#define	MMODE		(0<<7)		//VM = ecah frame, not use MVAL
+#define	DISMODE		(1<<5)		//4bit single scan
+#define	INVCLK		(0<<4)		//falling edge fetch data
+#define	INVLINE		(0<<3)		//normal, non inverse
+#define	INVFRAME	(0<<2)		//normal
+#define	INVVD		(0<<1)		//normal
+#define	ENVID		1
+#define	DSVID		0
+
+#define	LCD_MODE_DS	(CLKVAL|WLH|WDLY|MMODE|DISMODE|INVCLK|INVLINE|INVFRAME|INVVD|DSVID)
+#define	LCD_MODE_EN	(CLKVAL|WLH|WDLY|MMODE|DISMODE|INVCLK|INVLINE|INVFRAME|INVVD|ENVID)
+/////////////////////	LCDCON2
+#define	LINEBLINK	10
+/////////////////////	LCDCON3
+#define	SELFREF_EN	1
+#define	SELFREF_DS	0
+/////////////////////	LCDSADDR1
+#define	MONO_MODE	0
+#define	G4_MODE		1
+#define	G16_MODE	2
+#define	C8_MODE		3
+#define	BankOfDisMem(addr)	(((U32)(addr)>>22)<<21)
+#define	BaseOfDisMem(addr)	(((U32)(addr)>>1)&0x1fffff)
+/////////////////////	LCDSADDR2
+#define	BSWP_EN		1
+#define	BSWP_DS		0
+#define	MVAL		1
+/////////////////////	LCDSADDR3
+#define	MONO_VS_SIZE	(LCD_XSIZE/16)|(((SCR_XSIZE-LCD_XSIZE)/16)<<9)
+#define	G4_VS_SIZE		(LCD_XSIZE/8)|(((SCR_XSIZE-LCD_XSIZE)/8)<<9)
+#define	G16_VS_SIZE		(LCD_XSIZE/4)|(((SCR_XSIZE-LCD_XSIZE)/4)<<9)
+#define	C8_VS_SIZE		(LCD_XSIZE/2)|(((SCR_XSIZE-LCD_XSIZE)/2)<<9)
 
-	p_lcd = &panels[s3c44b0x_lcd_index];
+int __init s3c44b0xfb_init(void)
+{
+	int err = -ENOMEM;
+	char *fbuf;
 
-	memset(&fb_info.gen, 0, sizeof(fb_info.gen));
-	fb_info.gen.fbhw = &s3c44b0xfb_switch;
-	sprintf(fb_info.gen.info.modename, "%dx%dx%d",p_lcd->width,p_lcd->height,p_lcd->bpp);
-	fb_info.gen.parsize = sizeof(struct s3c44b0xfb_par);
-	fb_info.gen.info.changevar = NULL;
-	fb_info.gen.info.node = -1;
-	fb_info.gen.info.fbops = &s3c44b0xfb_ops;
-	fb_info.gen.info.disp = NULL; /* not needed ?? */
-	fb_info.gen.info.switch_con = NULL;
-	fb_info.gen.info.updatevar = NULL;
-	fb_info.gen.info.blank = &s3c44b0xfb_gen_blank;
-	fb_info.gen.info.flags = FBINFO_FLAG_DEFAULT;
-	/* This should give a reasonable default video mode */
-	/* fbgen_get_var(&disp.var, -1, &fb_info.gen.info); */
-	/* fbgen_do_set_var(&disp.var, 1, &fb_info.gen); */
-	/* fbgen_set_disp(-1, &fb_info.gen); */
-	/* fbgen_install_cmap(0, &fb_info.gen); */
-
-	/**********************************************
-	 * file the var struct inside the current_par struct
-	 **********************************************/
-	memset(&current_par.var, 0, sizeof(current_par.var));
-	current_par.var.xres = p_lcd->width;
-	current_par.var.yres = p_lcd->height;
-	current_par.var.xres_virtual = p_lcd->width;
-	current_par.var.yres_virtual = p_lcd->height;
-	current_par.var.bits_per_pixel = p_lcd->bpp;
-	current_par.var.grayscale = (p_lcd->bpp == 8)? 0 : 1;
-	if(p_lcd->bpp == 1)
-	{
-		current_par.var.blue.length = 1;
-	}
-	else if(p_lcd->bpp == 2)
-	{
-		current_par.var.blue.length = 2;
-	}
-	else if(p_lcd->bpp == 4)
-	{
-		current_par.var.blue.length = 4;
-	}
-	else if(p_lcd->bpp == 8)
-	{
-		current_par.var.red.offset = 5;
-		current_par.var.red.length = 3;
-		current_par.var.green.offset = 2;
-		current_par.var.green.length = 3;
-		current_par.var.blue.length = 2;
-	}
+	cfb = kmalloc(sizeof(*cfb) + sizeof(struct display), GFP_KERNEL);
+	if (!cfb)
+		goto out;
+	memset(cfb, 0, sizeof(*cfb) + sizeof(struct display));
+	
+	fbuf = kmalloc(LCD_BUF_SIZE, GFP_KERNEL);
+	if(!fbuf){
+		kfree(cfb);
+		goto out;
+	}
+	memset(fbuf, 0, LCD_BUF_SIZE);
+
+	cfb->currcon		= -1;
+
+	strcpy(cfb->fb.fix.id, "s3c44b0");
+	cfb->fb.screen_base	= fbuf;
+	cfb->fb.fix.smem_start	= fbuf;
+	cfb->fb.fix.smem_len	= LCD_BUF_SIZE;
+	cfb->fb.fix.type	= FB_TYPE_PACKED_PIXELS;
+
+	cfb->fb.var.xres	   = LCD_XSIZE;
+	cfb->fb.var.xres_virtual   = SCR_XSIZE;
+	cfb->fb.var.yres	   = LCD_YSIZE;
+	cfb->fb.var.yres_virtual   = SCR_YSIZE;
+	cfb->fb.var.bits_per_pixel = LCD_DEPTH;
+	cfb->fb.var.grayscale   = 1;
+	cfb->fb.var.activate	= FB_ACTIVATE_NOW;
+	cfb->fb.var.height	= -1;
+	cfb->fb.var.width	= -1;
+
+	cfb->fb.fbops		= &s3c44b0fb_ops;
+	cfb->fb.changevar	= NULL;
+//	cfb->fb.switch_con	= s3c44b0fb_switch;
+	cfb->fb.updatevar	= s3c44b0fb_updatevar;
+	cfb->fb.blank		= s3c44b0fb_blank;
+	cfb->fb.flags		= FBINFO_FLAG_DEFAULT;
+	cfb->fb.disp		= (struct display *)(cfb + 1);
 
-	current_par_valid = 1;
+	fb_alloc_cmap(&cfb->fb.cmap, CMAP_SIZE, 0);
 
 	/*
-	 * Allocate LCD framebuffer from system memory
+	 * Power up the LCD
 	 */
-	fb_info.fb_size = (p_lcd->width * p_lcd->height * p_lcd->bpp) >> 3;
-	/* FIXME align it to 4 MB */
-	fb_info.fb_phys = S3C44B0X_FB_ADDRESS;
-	fb_info.fb_virt_start = fb_info.fb_phys;
-	current_par.line_length = (p_lcd->width * p_lcd->bpp) >> 3;
-
-	/* fill the var element of fb_info.gen.info */
-	memcpy(&fb_info.gen.info.var, &current_par.var, sizeof(struct fb_var_screeninfo));
-
-	/* fill the fix element of fb_info.gen.info */
-	s3c44b0xfb_encode_fix(&fb_info.gen.info.fix, &current_par, &fb_info.gen);
-
-	if (register_framebuffer(&fb_info.gen.info) < 0)
-		return -EINVAL;
-	printk(KERN_INFO "fb%d: %s frame buffer device\n", GET_FB_IDX(fb_info.gen.info.node),
-	       fb_info.gen.info.modename);
-
-	/*********************************************
-         *  set framebuffer memory to zero
-	 *********************************************/
-	memset((void*)fb_info.fb_phys, 0, fb_info.fb_size);
-
-
-	/*********************************************
-	 * init the lcd controller
-	 *********************************************/
-	
-	s3c44b0xfb_init_lcd_controller(p_lcd);
+#ifdef	LCD_GRAY_16
+	Max749Up(23);
+	outl(0xaaaa, S3C44B0X_PCOND);		//VFRAME,VM,VLINE,VCLK,VD3-VD0 enable
+	outl(LCD_MODE_DS, S3C44B0X_LCDCON1);
+	outl((LINEBLINK<<21)|(((LCD_XSIZE>>2)-1)<<10)|(LCD_YSIZE-1), S3C44B0X_LCDCON2);
+	outl((G16_MODE<<27)|BankOfDisMem(fbuf)|BaseOfDisMem(fbuf), S3C44B0X_LCDSADDR1);
+	outl((BSWP_EN<<29)|(MVAL<<21)|BaseOfDisMem((U32)fbuf+SCR_XSIZE*LCD_YSIZE/2), S3C44B0X_LCDSADDR2);
+	outl(G16_VS_SIZE, S3C44B0X_LCDSADDR3);
 	
+	outl(inl(S3C44B0X_PDATC)&~0x100, S3C44B0X_PDATC);	// set GPC8 low
+#else
+/*	Max749Up(23);
+	PCOND     = 0xaaaa;	//VFRAME,VM,VLINE,VCLK,VD3-VD0 enable
+	LCDCON1   = LCD_MODE_DS;		
+	LCDCON2   = (LINEBLINK<<21)|((LCD_XSIZE/4-1)<<10)|(LCD_YSIZE-1);
+	LCDSADDR1 = (G16_MODE<<27)|BankOfDisMem(fbuf)|BaseOfDisMem(fbuf);		
+	LCDSADDR2 = (BSWP_EN<<29)|(MVAL<<21)|BaseOfDisMem((U32)fbuf+SCR_XSIZE*LCD_YSIZE/2);
+	LCDSADDR3 = G16_VS_SIZE;*/
+
+	outl(inl(S3C44B0X_PCONC)&~0xff00, S3C44B0X_PCONC);
+	outl(inl(S3C44B0X_PCONC)|0xff00, S3C44B0X_PCONC);	//GPC4-GPC7 as VD7-VD4
+	outl(0xaaaa, S3C44B0X_PCOND);				//VFRAME,VM,VLINE,VCLK,VD3-VD0
+	outl(inl(S3C44B0X_PDATC)&~0x100, S3C44B0X_PDATC);	// set GPC8 low
 	
+	outl(0x4f40, S3C44B0X_LCDCON1);
+	outl((LINEBLINK<<21)|(((LCD_XSIZE>>1)-1)<<10)|(LCD_YSIZE-1), S3C44B0X_LCDCON2);
+	outl((3<<27)|((int)fbuf>>1), S3C44B0X_LCDSADDR1);
+	outl(((((int)fbuf+LCD_XSIZE*LCD_YSIZE)>>1)&0x1fffff)|(13<<21)|(1<<29), S3C44B0X_LCDSADDR2);
+	outl(C8_VS_SIZE, S3C44B0X_LCDSADDR3);
+	outl(0xfdb96420, S3C44B0X_REDLUT);
+	outl(0xfdb96420, S3C44B0X_GREENLUT);
+	outl(0xfb40, S3C44B0X_BLUELUT);
+#endif
+	outl(inl(S3C44B0X_LCDCON1)|ENVID, S3C44B0X_LCDCON1);
 
+	printk("LCD buffer : %p\n", fbuf);
 
+	s3c44b0fb_set_var(&cfb->fb.var, -1, &cfb->fb);
+	err = register_framebuffer(&cfb->fb);
+//	printk("err=%d\n", err);
 
-    /* uncomment this if your driver cannot be unloaded */
-    /* MOD_INC_USE_COUNT; */
-	printk("S3C44B0X framebuffer driver: Init ready\n");
-	return 0;
+out:	return err;
 }
 
-
-
-
-    /*
-     *  Cleanup
-     */
-
-void s3c44b0xfb_cleanup(struct fb_info *info)
+static void __exit s3c44b0xfb_exit(void)
 {
-	/*
-	 *  If your driver supports multiple boards, you should unregister and
-	 *  clean up all instances.
-	 */
-	unregister_framebuffer(info);
-}
+	unregister_framebuffer(&cfb->fb);
+	kfree(cfb);
 
-
-    /*
-     *  Setup
-     */
+}
 
 int __init s3c44b0xfb_setup(char *options)
 {
 	return 0;
 }
 
-
-/* ------------------------------------------------------------------------- */
-
-
-    /*
-     *  Frame buffer operations
-     */
-
-/* If all you need is that - just don't define ->fb_open */
-static int s3c44b0xfb_open(struct fb_info *info, int user)
-{
-    return 0;
-}
-
-/* If all you need is that - just don't define ->fb_release */
-static int s3c44b0xfb_release(struct fb_info *info, int user)
-{
-    return 0;
-}
-
-
-    /*
-     *  In most cases the `generic' routines (fbgen_*) should be satisfactory.
-     *  However, you're free to fill in your own replacements.
-     */
-
-static struct fb_ops s3c44b0xfb_ops = {
-	owner:		THIS_MODULE,
-	fb_open:	s3c44b0xfb_open,    /* only if you need it to do something */
-	fb_release:	s3c44b0xfb_release, /* only if you need it to do something */
-	fb_get_fix:	fbgen_get_fix,
-	fb_get_var:	fbgen_get_var,
-	fb_set_var:	fbgen_set_var,
-	fb_get_cmap:	fbgen_get_cmap,
-	fb_set_cmap:	fbgen_set_cmap,
-	fb_pan_display:	fbgen_pan_display,
-	fb_ioctl:	NULL,   /* optional */
-};
-
-
-/* ------------------------------------------------------------------------- */
-
-
-    /*
-     *  Modularization
-     */
-
 #ifdef MODULE
-MODULE_LICENSE("GPL");
-int init_module(void)
-{
-    return s3c44b0xfb_init();
-}
-
-void cleanup_module(void)
-{
-    s3c44b0xfb_cleanup(&fb_info.gen.info);
-}
-#endif /* MODULE */
+module_init(s3c44b0xfb_init);
+module_exit(s3c44b0xfb_exit);
+#endif
diff -urN uClinux-dist/linux-2.4.x/include/asm-armnommu/arch-S3C44B0X/io.h linux-2.4.x/include/asm-armnommu/arch-S3C44B0X/io.h
--- uClinux-dist/linux-2.4.x/include/asm-armnommu/arch-S3C44B0X/io.h	2004-02-17 20:53:53.000000000 +0800
+++ linux-2.4.x/include/asm-armnommu/arch-S3C44B0X/io.h	2004-05-15 17:17:05.000000000 +0800
@@ -76,4 +76,12 @@
 #define iomem_valid_addr(iomem,sz) (1)
 #define iomem_to_phys(iomem) (iomem)
 
+#define readb(b)                __arch_getb(b)
+#define readw(b)                __arch_getw(b)
+#define readl(b)                __arch_getl(b)
+
+#define writeb(v,b)             __arch_putb(v,b)
+#define writew(v,b)             __arch_putw(v,b)
+#define writel(v,b)             __arch_putl(v,b)
+
 #endif /* __ASM_ARM_ARCH_IO_H */
diff -urN uClinux-dist/linux-2.4.x/include/asm-armnommu/arch-S3C44B0X/memory.h linux-2.4.x/include/asm-armnommu/arch-S3C44B0X/memory.h
--- uClinux-dist/linux-2.4.x/include/asm-armnommu/arch-S3C44B0X/memory.h	2004-02-17 20:53:53.000000000 +0800
+++ linux-2.4.x/include/asm-armnommu/arch-S3C44B0X/memory.h	2004-03-24 22:20:30.000000000 +0800
@@ -11,9 +11,9 @@
 #define TASK_SIZE	(0x01a00000UL)
 #define TASK_SIZE_26	TASK_SIZE
 
-#define PHYS_OFFSET     (DRAM_BASE + 2*1024*1024)
+#define PHYS_OFFSET     (DRAM_BASE)//(DRAM_BASE + 2*1024*1024)
 #define PAGE_OFFSET 	(PHYS_OFFSET)
-#define END_MEM		(DRAM_BASE + DRAM_SIZE - 2*1024*1024)
+#define END_MEM		(DRAM_BASE+DRAM_SIZE)//(DRAM_BASE + DRAM_SIZE - 2*1024*1024)
 
 #define __virt_to_phys__is_a_macro
 #define __virt_to_phys(vpage) ((unsigned long) (vpage))
diff -urN uClinux-dist/linux-2.4.x/include/asm-armnommu/arch-S3C44B0X/time.h linux-2.4.x/include/asm-armnommu/arch-S3C44B0X/time.h
--- uClinux-dist/linux-2.4.x/include/asm-armnommu/arch-S3C44B0X/time.h	2004-02-17 20:53:53.000000000 +0800
+++ linux-2.4.x/include/asm-armnommu/arch-S3C44B0X/time.h	2004-05-17 11:26:08.000000000 +0800
@@ -18,15 +18,21 @@
 extern struct irqaction timer_irq;
 
 extern unsigned long s3c44b0x_gettimeoffset(void);
-extern void s3c44b0x_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs);
+//extern void s3c44b0x_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs);
+static inline  void s3c44b0x_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	do_leds();
+	do_timer(regs);
+}//modified by hzh
 
 /* TODO: THE, 2003-08-13, do timer setup like in eCos */
-#define S3C44B0X_TIMER5_PRESCALER 16
+#define S3C44B0X_TIMER5_PRESCALER 32 
 
 extern __inline__ void setup_timer (void)
 {
 	u_int32_t tmod;
 	u_int32_t period;
+	__u32 rw_tmp;
 
 	period = (CONFIG_ARM_CLK/S3C44B0X_TIMER5_PRESCALER)/HZ;
 	outl(period, S3C44B0X_TCNTB5);
@@ -36,8 +42,14 @@
 	outl(tmod, S3C44B0X_TCON);
 
 	/* initialize the timer period and prescaler */
-	outl((5-1) << 16, S3C44B0X_TCFG0);
-	outl( (0x3 <<20), S3C44B0X_TCFG1); /* prescaler */
+	rw_tmp  = inl(S3C44B0X_TCFG0);
+	rw_tmp &= ~(0xff<<16);
+	rw_tmp |= (16-1)<<16;
+	outl(rw_tmp, S3C44B0X_TCFG0);		// prescaler = 1/16
+	rw_tmp  = inl(S3C44B0X_TCFG1);
+	rw_tmp &= ~(0xf<<20);
+	rw_tmp |= 0<<20;
+	outl(rw_tmp, S3C44B0X_TCFG1);		// mux = 1/2
 
 	/*
 	 * @todo do those really need to be function pointers ?
diff -urN uClinux-dist/linux-2.4.x/include/asm-armnommu/arch-S3C44B0X/uncompress.c linux-2.4.x/include/asm-armnommu/arch-S3C44B0X/uncompress.c
--- uClinux-dist/linux-2.4.x/include/asm-armnommu/arch-S3C44B0X/uncompress.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.4.x/include/asm-armnommu/arch-S3C44B0X/uncompress.c	2004-03-24 00:35:01.000000000 +0800
@@ -0,0 +1,28 @@
+/*
+ * linux/include/asm/arch-samsung/uncompress.c
+ * 2001 Mac Wang <mac@os.nctu.edu.tw> 
+ */
+
+#include <asm/hardware.h>
+
+#define	outb(d, p)	*(volatile unsigned char *)(p) = (d)
+#define	inb(p)		*(volatile unsigned char *)(p)
+
+static int s3c44b0x_decomp_setup()
+{
+}
+
+static int s3c44b0x_putc(char c)
+{
+	outb(c, S3C44B0X_UTXH0);
+	while(!(inb(S3C44B0X_UTRSTAT0) & 2));
+
+	if(c == '\n')
+		s3c44b0x_putc('\r');
+}
+
+static void s3c44b0x_puts(const char *s)
+{
+	while(*s != '\0')
+		s3c44b0x_putc(*s++);
+}
diff -urN uClinux-dist/linux-2.4.x/include/asm-armnommu/arch-S3C44B0X/uncompress.h linux-2.4.x/include/asm-armnommu/arch-S3C44B0X/uncompress.h
--- uClinux-dist/linux-2.4.x/include/asm-armnommu/arch-S3C44B0X/uncompress.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.4.x/include/asm-armnommu/arch-S3C44B0X/uncompress.h	2004-03-24 00:04:05.000000000 +0800
@@ -0,0 +1,50 @@
+/*
+ * asm/arch/uncompress.c:
+ *         Optional routines to aid in debugging the decompression phase
+ *         of kernel boot.
+ * copyright:
+ *         (C) 2001 RidgeRun, Inc. (http://www.ridgerun.com)
+ * author: Gordon McNutt <gmcnutt@ridgerun.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ * WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ * NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ * USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+#include <asm/arch/uncompress.c>
+/*
+ * This is used by arch/armnommu/boot/compressed/misc.c to write progress info
+ * out the serial port so that the user can see debug messages up to the point
+ * where the kernel is decompressed. The STANDALONE_DEBUG macro chooses between
+ * this and the standard printf. Punt.
+ * --gmcnutt
+ */
+#define puts(s)			s3c44b0x_puts(s)
+
+/*
+ * Not sure what this is for. Probably an optional watchdog to check if the
+ * decompress got hung so we can warn the user. Punt.
+ */
+#define arch_decomp_wdog()
+
+/*
+ * If we need to do some setup prior to decompression (like initializing the
+ * UART if we want to use puts() above) then we define it here. Punt.
+ */
+#define arch_decomp_setup()	s3c44b0x_decomp_setup()
diff -urN uClinux-dist/linux-2.4.x/include/asm-armnommu/arch-snds100/hardware.h linux-2.4.x/include/asm-armnommu/arch-snds100/hardware.h
--- uClinux-dist/linux-2.4.x/include/asm-armnommu/arch-snds100/hardware.h	2004-02-17 20:53:52.000000000 +0800
+++ linux-2.4.x/include/asm-armnommu/arch-snds100/hardware.h	2004-05-18 10:10:20.000000000 +0800
@@ -188,7 +188,7 @@
 
 #define DEBUG_ULCON_REG_VAL	(0x3)
 #define DEBUG_UCON_REG_VAL	(0x9)
-#define DEBUG_UBRDIV_REG_VAL	(0x500)
+#define DEBUG_UBRDIV_REG_VAL	(0x1a0)//(0x500)
 #define DEBUG_RX_CHECK_BIT	(0X20)
 #define DEBUG_TX_CAN_CHECK_BIT	(0X40)
 #define DEBUG_TX_DONE_CHECK_BIT	(0X80)
@@ -223,7 +223,7 @@
 #define DSD2		(0<<16)
 #define DSD3		(0<<18)
 #define DSX0		(0<<20)	/* EXTIO0 */
-#define DSX1		(0<<22)
+#define DSX1		(2<<22)
 #define DSX2		(0<<24)
 #define DSX3		(0<<26)
 
@@ -259,9 +259,9 @@
 #define StRC0		(0x1<<7)
 #define StRP0		(0x3<<8)
 #define SDRAM_BASE0_R	((0x01000000>>16)<<10)
-#define SDRAM_NEXT0_R	((0x01800000>>16)<<20)
+#define SDRAM_NEXT0_R	((0x02000000>>16)<<20)
 #define SDRAM_BASE0_B	((0x00000000>>16)<<10)
-#define SDRAM_NEXT0_B	((0x00800000>>16)<<20)
+#define SDRAM_NEXT0_B	((0x01000000>>16)<<20)
 #define SCAN0		(0x0<<30)
 #define rSDRAMCON0_R	(SCAN0|SDRAM_NEXT0_R|SDRAM_BASE0_R|StRP0|StRC0)
 #define rSDRAMCON0_B	(SCAN0|SDRAM_NEXT0_B|SDRAM_BASE0_B|StRP0|StRC0)
diff -urN uClinux-dist/linux-2.4.x/include/asm-armnommu/arch-snds100/time.h linux-2.4.x/include/asm-armnommu/arch-snds100/time.h
--- uClinux-dist/linux-2.4.x/include/asm-armnommu/arch-snds100/time.h	2004-02-17 20:53:52.000000000 +0800
+++ linux-2.4.x/include/asm-armnommu/arch-snds100/time.h	2004-05-18 11:51:40.000000000 +0800
@@ -14,7 +14,12 @@
 extern struct irqaction timer_irq;
 
 extern unsigned long samsung_gettimeoffset(void);
-extern void samsung_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs);
+//extern void samsung_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs);
+static void inline samsung_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	do_leds();
+	do_timer(regs);
+}//modified by hzh
 
 
 void __inline__ setup_timer (void)
diff -urN uClinux-dist/linux-2.4.x/include/asm-armnommu/arch-snds100/timex.h linux-2.4.x/include/asm-armnommu/arch-snds100/timex.h
--- uClinux-dist/linux-2.4.x/include/asm-armnommu/arch-snds100/timex.h	2004-02-17 20:53:52.000000000 +0800
+++ linux-2.4.x/include/asm-armnommu/arch-snds100/timex.h	2004-05-18 11:42:31.000000000 +0800
@@ -7,6 +7,6 @@
 
 #include <asm/hardware.h>
 
-#define CLOCK_TICK_RATE	   (((fMCLK_MHz/100))*2)
+#define CLOCK_TICK_RATE	   (((fMCLK_MHz/100)))//(((fMCLK_MHz/100))*2)
 
 #endif /* __ASM_ARCH_TIMEX_H__ */
diff -urN uClinux-dist/linux-2.4.x/include/asm-armnommu/mach-types.h linux-2.4.x/include/asm-armnommu/mach-types.h
--- uClinux-dist/linux-2.4.x/include/asm-armnommu/mach-types.h	2004-02-17 20:53:53.000000000 +0800
+++ linux-2.4.x/include/asm-armnommu/mach-types.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,1287 +0,0 @@
-/*
- * This was automagically generated from mach-types!
- * Do NOT edit
- */
-
-#ifndef __ASM_ARM_MACH_TYPE_H
-#define __ASM_ARM_MACH_TYPE_H
-
-#include <linux/config.h>
-
-#ifndef __ASSEMBLY__
-/* The type of machine we're running on */
-extern unsigned int __machine_arch_type;
-#endif
-
-/* see arch/arm/kernel/arch.c for a description of these */
-#define MACH_TYPE_EBSA110              0
-#define MACH_TYPE_RISCPC               1
-#define MACH_TYPE_NEXUSPCI             3
-#define MACH_TYPE_EBSA285              4
-#define MACH_TYPE_NETWINDER            5
-#define MACH_TYPE_CATS                 6
-#define MACH_TYPE_TBOX                 7
-#define MACH_TYPE_CO285                8
-#define MACH_TYPE_CLPS7110             9
-#define MACH_TYPE_ARCHIMEDES           10
-#define MACH_TYPE_A5K                  11
-#define MACH_TYPE_ETOILE               12
-#define MACH_TYPE_LACIE_NAS            13
-#define MACH_TYPE_CLPS7500             14
-#define MACH_TYPE_SHARK                15
-#define MACH_TYPE_BRUTUS               16
-#define MACH_TYPE_PERSONAL_SERVER      17
-#define MACH_TYPE_ITSY                 18
-#define MACH_TYPE_L7200                19
-#define MACH_TYPE_PLEB                 20
-#define MACH_TYPE_INTEGRATOR           21
-#define MACH_TYPE_BITSY                22
-#define MACH_TYPE_IXP1200              23
-#define MACH_TYPE_P720T                24
-#define MACH_TYPE_ASSABET              25
-#define MACH_TYPE_VICTOR               26
-#define MACH_TYPE_LART                 27
-#define MACH_TYPE_RANGER               28
-#define MACH_TYPE_GRAPHICSCLIENT       29
-#define MACH_TYPE_XP860                30
-#define MACH_TYPE_CERF                 31
-#define MACH_TYPE_NANOENGINE           32
-#define MACH_TYPE_FPIC                 33
-#define MACH_TYPE_EXTENEX1             34
-#define MACH_TYPE_SHERMAN              35
-#define MACH_TYPE_ACCELENT_SA          36
-#define MACH_TYPE_ACCELENT_L7200       37
-#define MACH_TYPE_NETPORT              38
-#define MACH_TYPE_PANGOLIN             39
-#define MACH_TYPE_YOPY                 40
-#define MACH_TYPE_COOLIDGE             41
-#define MACH_TYPE_HUW_WEBPANEL         42
-#define MACH_TYPE_SPOTME               43
-#define MACH_TYPE_FREEBIRD             44
-#define MACH_TYPE_TI925                45
-#define MACH_TYPE_RISCSTATION          46
-#define MACH_TYPE_CAVY                 47
-#define MACH_TYPE_JORNADA720           48
-#define MACH_TYPE_OMNIMETER            49
-#define MACH_TYPE_EDB7211              50
-#define MACH_TYPE_CITYGO               51
-#define MACH_TYPE_PFS168               52
-#define MACH_TYPE_SPOT                 53
-#define MACH_TYPE_FLEXANET             54
-#define MACH_TYPE_WEBPAL               55
-#define MACH_TYPE_LINPDA               56
-#define MACH_TYPE_ANAKIN               57
-#define MACH_TYPE_MVI                  58
-#define MACH_TYPE_JUPITER              59
-#define MACH_TYPE_PSIONW               60
-#define MACH_TYPE_ALN                  61
-#define MACH_TYPE_CAMELOT              62
-#define MACH_TYPE_GDS2200              63
-#define MACH_TYPE_PSION_SERIES7        64
-#define MACH_TYPE_XFILE                65
-#define MACH_TYPE_ACCELENT_EP9312      66
-#define MACH_TYPE_IC200                67
-#define MACH_TYPE_CREDITLART           68
-#define MACH_TYPE_HTM                  69
-#define MACH_TYPE_IQ80310              70
-#define MACH_TYPE_FREEBOT              71
-#define MACH_TYPE_ENTEL                72
-#define MACH_TYPE_ENP3510              73
-#define MACH_TYPE_TRIZEPS              74
-#define MACH_TYPE_NESA                 75
-#define MACH_TYPE_VENUS                76
-#define MACH_TYPE_TARDIS               77
-#define MACH_TYPE_MERCURY              78
-#define MACH_TYPE_EMPEG                79
-#define MACH_TYPE_I80200FCC            80
-#define MACH_TYPE_ITT_CPB              81
-#define MACH_TYPE_SA1110_SVC           82
-#define MACH_TYPE_SA1100               83
-#define MACH_TYPE_ALPHA2               84
-#define MACH_TYPE_ALPHA1               85
-#define MACH_TYPE_NETARM               86
-#define MACH_TYPE_DSC21                115
-#define MACH_TYPE_CX821XX              130
-#define MACH_TYPE_ATMEL                224
-#define MACH_TYPE_TA7S                 334
-#define MACH_TYPE_P52                  87
-#define MACH_TYPE_SPIPE                88
-#define MACH_TYPE_SNDS100              90
-#define MACH_TYPE_EVS3C4530HEI         164
-#define MACH_TYPE_S3C3410              165
-#define MACH_TYPE_SMDK2500             166
-#define MACH_TYPE_S3C2500REFRGP        167
-
-#ifdef CONFIG_ARCH_EBSA110
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_EBSA110
-# endif
-# define machine_is_ebsa110()	(machine_arch_type == MACH_TYPE_EBSA110)
-#else
-# define machine_is_ebsa110()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_RPC
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_RISCPC
-# endif
-# define machine_is_riscpc()	(machine_arch_type == MACH_TYPE_RISCPC)
-#else
-# define machine_is_riscpc()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_NEXUSPCI
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_NEXUSPCI
-# endif
-# define machine_is_nexuspci()	(machine_arch_type == MACH_TYPE_NEXUSPCI)
-#else
-# define machine_is_nexuspci()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_EBSA285
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_EBSA285
-# endif
-# define machine_is_ebsa285()	(machine_arch_type == MACH_TYPE_EBSA285)
-#else
-# define machine_is_ebsa285()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_NETWINDER
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_NETWINDER
-# endif
-# define machine_is_netwinder()	(machine_arch_type == MACH_TYPE_NETWINDER)
-#else
-# define machine_is_netwinder()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_CATS
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_CATS
-# endif
-# define machine_is_cats()	(machine_arch_type == MACH_TYPE_CATS)
-#else
-# define machine_is_cats()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_TBOX
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_TBOX
-# endif
-# define machine_is_tbox()	(machine_arch_type == MACH_TYPE_TBOX)
-#else
-# define machine_is_tbox()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_CO285
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_CO285
-# endif
-# define machine_is_co285()	(machine_arch_type == MACH_TYPE_CO285)
-#else
-# define machine_is_co285()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_CLPS7110
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_CLPS7110
-# endif
-# define machine_is_clps7110()	(machine_arch_type == MACH_TYPE_CLPS7110)
-#else
-# define machine_is_clps7110()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_ARC
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_ARCHIMEDES
-# endif
-# define machine_is_archimedes()	(machine_arch_type == MACH_TYPE_ARCHIMEDES)
-#else
-# define machine_is_archimedes()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_A5K
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_A5K
-# endif
-# define machine_is_a5k()	(machine_arch_type == MACH_TYPE_A5K)
-#else
-# define machine_is_a5k()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_ETOILE
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_ETOILE
-# endif
-# define machine_is_etoile()	(machine_arch_type == MACH_TYPE_ETOILE)
-#else
-# define machine_is_etoile()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_LACIE_NAS
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_LACIE_NAS
-# endif
-# define machine_is_lacie_nas()	(machine_arch_type == MACH_TYPE_LACIE_NAS)
-#else
-# define machine_is_lacie_nas()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_CLPS7500
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_CLPS7500
-# endif
-# define machine_is_clps7500()	(machine_arch_type == MACH_TYPE_CLPS7500)
-#else
-# define machine_is_clps7500()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_SHARK
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_SHARK
-# endif
-# define machine_is_shark()	(machine_arch_type == MACH_TYPE_SHARK)
-#else
-# define machine_is_shark()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_BRUTUS
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_BRUTUS
-# endif
-# define machine_is_brutus()	(machine_arch_type == MACH_TYPE_BRUTUS)
-#else
-# define machine_is_brutus()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_PERSONAL_SERVER
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_PERSONAL_SERVER
-# endif
-# define machine_is_personal_server()	(machine_arch_type == MACH_TYPE_PERSONAL_SERVER)
-#else
-# define machine_is_personal_server()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_ITSY
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_ITSY
-# endif
-# define machine_is_itsy()	(machine_arch_type == MACH_TYPE_ITSY)
-#else
-# define machine_is_itsy()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_L7200
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_L7200
-# endif
-# define machine_is_l7200()	(machine_arch_type == MACH_TYPE_L7200)
-#else
-# define machine_is_l7200()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_PLEB
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_PLEB
-# endif
-# define machine_is_pleb()	(machine_arch_type == MACH_TYPE_PLEB)
-#else
-# define machine_is_pleb()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_INTEGRATOR
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_INTEGRATOR
-# endif
-# define machine_is_integrator()	(machine_arch_type == MACH_TYPE_INTEGRATOR)
-#else
-# define machine_is_integrator()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_BITSY
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_BITSY
-# endif
-# define machine_is_bitsy()	(machine_arch_type == MACH_TYPE_BITSY)
-#else
-# define machine_is_bitsy()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_IXP1200
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_IXP1200
-# endif
-# define machine_is_ixp1200()	(machine_arch_type == MACH_TYPE_IXP1200)
-#else
-# define machine_is_ixp1200()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_P720T
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_P720T
-# endif
-# define machine_is_p720t()	(machine_arch_type == MACH_TYPE_P720T)
-#else
-# define machine_is_p720t()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_ASSABET
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_ASSABET
-# endif
-# define machine_is_assabet()	(machine_arch_type == MACH_TYPE_ASSABET)
-#else
-# define machine_is_assabet()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_VICTOR
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_VICTOR
-# endif
-# define machine_is_victor()	(machine_arch_type == MACH_TYPE_VICTOR)
-#else
-# define machine_is_victor()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_LART
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_LART
-# endif
-# define machine_is_lart()	(machine_arch_type == MACH_TYPE_LART)
-#else
-# define machine_is_lart()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_RANGER
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_RANGER
-# endif
-# define machine_is_ranger()	(machine_arch_type == MACH_TYPE_RANGER)
-#else
-# define machine_is_ranger()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_GRAPHICSCLIENT
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_GRAPHICSCLIENT
-# endif
-# define machine_is_graphicsclient()	(machine_arch_type == MACH_TYPE_GRAPHICSCLIENT)
-#else
-# define machine_is_graphicsclient()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_XP860
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_XP860
-# endif
-# define machine_is_xp860()	(machine_arch_type == MACH_TYPE_XP860)
-#else
-# define machine_is_xp860()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_CERF
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_CERF
-# endif
-# define machine_is_cerf()	(machine_arch_type == MACH_TYPE_CERF)
-#else
-# define machine_is_cerf()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_NANOENGINE
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_NANOENGINE
-# endif
-# define machine_is_nanoengine()	(machine_arch_type == MACH_TYPE_NANOENGINE)
-#else
-# define machine_is_nanoengine()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_FPIC
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_FPIC
-# endif
-# define machine_is_fpic()	(machine_arch_type == MACH_TYPE_FPIC)
-#else
-# define machine_is_fpic()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_EXTENEX1
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_EXTENEX1
-# endif
-# define machine_is_extenex1()	(machine_arch_type == MACH_TYPE_EXTENEX1)
-#else
-# define machine_is_extenex1()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_SHERMAN
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_SHERMAN
-# endif
-# define machine_is_sherman()	(machine_arch_type == MACH_TYPE_SHERMAN)
-#else
-# define machine_is_sherman()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_ACCELENT
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_ACCELENT_SA
-# endif
-# define machine_is_accelent_sa()	(machine_arch_type == MACH_TYPE_ACCELENT_SA)
-#else
-# define machine_is_accelent_sa()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_L7200_ACCELENT
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_ACCELENT_L7200
-# endif
-# define machine_is_accelent_l7200()	(machine_arch_type == MACH_TYPE_ACCELENT_L7200)
-#else
-# define machine_is_accelent_l7200()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_NETPORT
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_NETPORT
-# endif
-# define machine_is_netport()	(machine_arch_type == MACH_TYPE_NETPORT)
-#else
-# define machine_is_netport()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_PANGOLIN
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_PANGOLIN
-# endif
-# define machine_is_pangolin()	(machine_arch_type == MACH_TYPE_PANGOLIN)
-#else
-# define machine_is_pangolin()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_YOPY
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_YOPY
-# endif
-# define machine_is_yopy()	(machine_arch_type == MACH_TYPE_YOPY)
-#else
-# define machine_is_yopy()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_COOLIDGE
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_COOLIDGE
-# endif
-# define machine_is_coolidge()	(machine_arch_type == MACH_TYPE_COOLIDGE)
-#else
-# define machine_is_coolidge()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_HUW_WEBPANEL
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_HUW_WEBPANEL
-# endif
-# define machine_is_huw_webpanel()	(machine_arch_type == MACH_TYPE_HUW_WEBPANEL)
-#else
-# define machine_is_huw_webpanel()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_SPOTME
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_SPOTME
-# endif
-# define machine_is_spotme()	(machine_arch_type == MACH_TYPE_SPOTME)
-#else
-# define machine_is_spotme()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_FREEBIRD
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_FREEBIRD
-# endif
-# define machine_is_freebird()	(machine_arch_type == MACH_TYPE_FREEBIRD)
-#else
-# define machine_is_freebird()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_TI925
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_TI925
-# endif
-# define machine_is_ti925()	(machine_arch_type == MACH_TYPE_TI925)
-#else
-# define machine_is_ti925()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_RISCSTATION
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_RISCSTATION
-# endif
-# define machine_is_riscstation()	(machine_arch_type == MACH_TYPE_RISCSTATION)
-#else
-# define machine_is_riscstation()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_CAVY
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_CAVY
-# endif
-# define machine_is_cavy()	(machine_arch_type == MACH_TYPE_CAVY)
-#else
-# define machine_is_cavy()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_JORNADA720
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_JORNADA720
-# endif
-# define machine_is_jornada720()	(machine_arch_type == MACH_TYPE_JORNADA720)
-#else
-# define machine_is_jornada720()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_OMNIMETER
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_OMNIMETER
-# endif
-# define machine_is_omnimeter()	(machine_arch_type == MACH_TYPE_OMNIMETER)
-#else
-# define machine_is_omnimeter()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_EDB7211
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_EDB7211
-# endif
-# define machine_is_edb7211()	(machine_arch_type == MACH_TYPE_EDB7211)
-#else
-# define machine_is_edb7211()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_CITYGO
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_CITYGO
-# endif
-# define machine_is_citygo()	(machine_arch_type == MACH_TYPE_CITYGO)
-#else
-# define machine_is_citygo()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_PFS168
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_PFS168
-# endif
-# define machine_is_pfs168()	(machine_arch_type == MACH_TYPE_PFS168)
-#else
-# define machine_is_pfs168()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_SPOT
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_SPOT
-# endif
-# define machine_is_spot()	(machine_arch_type == MACH_TYPE_SPOT)
-#else
-# define machine_is_spot()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_FLEXANET
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_FLEXANET
-# endif
-# define machine_is_flexanet()	(machine_arch_type == MACH_TYPE_FLEXANET)
-#else
-# define machine_is_flexanet()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_WEBPAL
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_WEBPAL
-# endif
-# define machine_is_webpal()	(machine_arch_type == MACH_TYPE_WEBPAL)
-#else
-# define machine_is_webpal()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_LINPDA
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_LINPDA
-# endif
-# define machine_is_linpda()	(machine_arch_type == MACH_TYPE_LINPDA)
-#else
-# define machine_is_linpda()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_ANAKIN
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_ANAKIN
-# endif
-# define machine_is_anakin()	(machine_arch_type == MACH_TYPE_ANAKIN)
-#else
-# define machine_is_anakin()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_MVI
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_MVI
-# endif
-# define machine_is_mvi()	(machine_arch_type == MACH_TYPE_MVI)
-#else
-# define machine_is_mvi()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_JUPITER
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_JUPITER
-# endif
-# define machine_is_jupiter()	(machine_arch_type == MACH_TYPE_JUPITER)
-#else
-# define machine_is_jupiter()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_PSIONW
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_PSIONW
-# endif
-# define machine_is_psionw()	(machine_arch_type == MACH_TYPE_PSIONW)
-#else
-# define machine_is_psionw()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_ALN
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_ALN
-# endif
-# define machine_is_aln()	(machine_arch_type == MACH_TYPE_ALN)
-#else
-# define machine_is_aln()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_CAMELOT
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_CAMELOT
-# endif
-# define machine_is_camelot()	(machine_arch_type == MACH_TYPE_CAMELOT)
-#else
-# define machine_is_camelot()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_GDS2200
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_GDS2200
-# endif
-# define machine_is_gds2200()	(machine_arch_type == MACH_TYPE_GDS2200)
-#else
-# define machine_is_gds2200()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_PSION_SERIES7
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_PSION_SERIES7
-# endif
-# define machine_is_psion_series7()	(machine_arch_type == MACH_TYPE_PSION_SERIES7)
-#else
-# define machine_is_psion_series7()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_XFILE
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_XFILE
-# endif
-# define machine_is_xfile()	(machine_arch_type == MACH_TYPE_XFILE)
-#else
-# define machine_is_xfile()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_ACCELENT_EP9312
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_ACCELENT_EP9312
-# endif
-# define machine_is_accelent_ep9312()	(machine_arch_type == MACH_TYPE_ACCELENT_EP9312)
-#else
-# define machine_is_accelent_ep9312()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_IC200
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_IC200
-# endif
-# define machine_is_ic200()	(machine_arch_type == MACH_TYPE_IC200)
-#else
-# define machine_is_ic200()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_CREDITLART
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_CREDITLART
-# endif
-# define machine_is_creditlart()	(machine_arch_type == MACH_TYPE_CREDITLART)
-#else
-# define machine_is_creditlart()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_HTM
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_HTM
-# endif
-# define machine_is_htm()	(machine_arch_type == MACH_TYPE_HTM)
-#else
-# define machine_is_htm()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_IQ80310
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_IQ80310
-# endif
-# define machine_is_iq80310()	(machine_arch_type == MACH_TYPE_IQ80310)
-#else
-# define machine_is_iq80310()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_FREEBOT
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_FREEBOT
-# endif
-# define machine_is_freebot()	(machine_arch_type == MACH_TYPE_FREEBOT)
-#else
-# define machine_is_freebot()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_ENTEL
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_ENTEL
-# endif
-# define machine_is_entel()	(machine_arch_type == MACH_TYPE_ENTEL)
-#else
-# define machine_is_entel()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_ENP3510
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_ENP3510
-# endif
-# define machine_is_enp3510()	(machine_arch_type == MACH_TYPE_ENP3510)
-#else
-# define machine_is_enp3510()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_TRIZEPS
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_TRIZEPS
-# endif
-# define machine_is_trizeps()	(machine_arch_type == MACH_TYPE_TRIZEPS)
-#else
-# define machine_is_trizeps()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_NESA
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_NESA
-# endif
-# define machine_is_nesa()	(machine_arch_type == MACH_TYPE_NESA)
-#else
-# define machine_is_nesa()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_VENUS
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_VENUS
-# endif
-# define machine_is_venus()	(machine_arch_type == MACH_TYPE_VENUS)
-#else
-# define machine_is_venus()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_TARDIS
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_TARDIS
-# endif
-# define machine_is_tardis()	(machine_arch_type == MACH_TYPE_TARDIS)
-#else
-# define machine_is_tardis()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_MERCURY
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_MERCURY
-# endif
-# define machine_is_mercury()	(machine_arch_type == MACH_TYPE_MERCURY)
-#else
-# define machine_is_mercury()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_EMPEG
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_EMPEG
-# endif
-# define machine_is_empeg()	(machine_arch_type == MACH_TYPE_EMPEG)
-#else
-# define machine_is_empeg()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_I80200FCC
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_I80200FCC
-# endif
-# define machine_is_i80200fcc()	(machine_arch_type == MACH_TYPE_I80200FCC)
-#else
-# define machine_is_i80200fcc()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_ITT_CPB
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_ITT_CPB
-# endif
-# define machine_is_itt_cpb()	(machine_arch_type == MACH_TYPE_ITT_CPB)
-#else
-# define machine_is_itt_cpb()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_SA1110_SVC
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_SA1110_SVC
-# endif
-# define machine_is_sa1110_svc()	(machine_arch_type == MACH_TYPE_SA1110_SVC)
-#else
-# define machine_is_sa1110_svc()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_SA1100
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_SA1100
-# endif
-# define machine_is_sa1100()	(machine_arch_type == MACH_TYPE_SA1100)
-#else
-# define machine_is_sa1100()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_ALPHA2
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_ALPHA2
-# endif
-# define machine_is_alpha2()	(machine_arch_type == MACH_TYPE_ALPHA2)
-#else
-# define machine_is_alpha2()	(0)
-#endif
-
-#ifdef CONFIG_SA1100_ALPHA1
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_ALPHA1
-# endif
-# define machine_is_alpha1()	(machine_arch_type == MACH_TYPE_ALPHA1)
-#else
-# define machine_is_alpha1()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_NETARM
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_NETARM
-# endif
-# define machine_is_netarm()	(machine_arch_type == MACH_TYPE_NETARM)
-#else
-# define machine_is_netarm()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_DSC21
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_DSC21
-# endif
-# define machine_is_dsc21()	(machine_arch_type == MACH_TYPE_DSC21)
-#else
-# define machine_is_dsc21()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_CX821XX
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_CX821XX
-# endif
-# define machine_is_cx821xx()	(machine_arch_type == MACH_TYPE_CX821XX)
-#else
-# define machine_is_cx821xx()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_ATMEL
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_ATMEL
-# endif
-# define machine_is_atmel()	(machine_arch_type == MACH_TYPE_ATMEL)
-#else
-# define machine_is_atmel()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_TA7S
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_TA7S
-# endif
-# define machine_is_ta7s()	(machine_arch_type == MACH_TYPE_TA7S)
-#else
-# define machine_is_ta7s()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_P52
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_P52
-# endif
-# define machine_is_p52()	(machine_arch_type == MACH_TYPE_P52)
-#else
-# define machine_is_p52()	(0)
-#endif
-
-#ifdef CONFIG_ARCH_SPIPE
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_SPIPE
-# endif
-# define machine_is_spipe()	(machine_arch_type == MACH_TYPE_SPIPE)
-#else
-# define machine_is_spipe()	(0)
-#endif
-
-#ifdef CONFIG_BOARD_SNDS100
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_SNDS100
-# endif
-# define machine_is_snds100()	(machine_arch_type == MACH_TYPE_SNDS100)
-#else
-# define machine_is_snds100()	(0)
-#endif
-
-#ifdef CONFIG_BOARD_EVS3C4530HEI
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_EVS3C4530HEI
-# endif
-# define machine_is_evS3C4530HEI()	(machine_arch_type == MACH_TYPE_EVS3C4530HEI)
-#else
-# define machine_is_evS3C4530HEI()	(0)
-#endif
-
-#ifdef CONFIG_BOARD_SMDK40100
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_S3C3410
-# endif
-# define machine_is_S3C3410X()	(machine_arch_type == MACH_TYPE_S3C3410)
-#else
-# define machine_is_S3C3410X()	(0)
-#endif
-
-#ifdef CONFIG_BOARD_SMDK2500
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_SMDK2500
-# endif
-# define machine_is_smdk2500()	(machine_arch_type == MACH_TYPE_SMDK2500)
-#else
-# define machine_is_smdk2500()	(0)
-#endif
-
-#ifdef CONFIG_BOARD_S3C2500REFRGP
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_S3C2500REFRGP
-# endif
-# define machine_is_S3C2500REFRGP()	(machine_arch_type == MACH_TYPE_S3C2500REFRGP)
-#else
-# define machine_is_S3C2500REFRGP()	(0)
-#endif
-
-/*
- * These have not yet been registered
- */
-
-#ifndef machine_arch_type
-#define machine_arch_type	__machine_arch_type
-#endif
-
-#endif
diff -urN uClinux-dist/linux-2.4.x/include/asm-armnommu/proc/system.h linux-2.4.x/include/asm-armnommu/proc/system.h
--- uClinux-dist/linux-2.4.x/include/asm-armnommu/proc/system.h	2004-02-17 20:53:53.000000000 +0800
+++ linux-2.4.x/include/asm-armnommu/proc/system.h	2004-05-18 11:11:02.000000000 +0800
@@ -42,6 +42,11 @@
 #define vectors_base()	(0)
 #endif
 
+#ifdef CONFIG_BOARD_MBA44
+#undef vectors_base()
+#define vectors_base()	(DRAM_BASE)
+#endif
+
 /*
  * A couple of speedups for the ARM
  */
diff -urN uClinux-dist/linux-2.4.x/include/asm-armnommu/sizes.h linux-2.4.x/include/asm-armnommu/sizes.h
--- uClinux-dist/linux-2.4.x/include/asm-armnommu/sizes.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.4.x/include/asm-armnommu/sizes.h	2004-05-15 16:35:26.000000000 +0800
@@ -0,0 +1,52 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* DO NOT EDIT!! - this file automatically generated
+ *                 from .s file by awk -f s2h.awk
+ */
+/*  Size defintions
+ *  Copyright (C) ARM Limited 1998. All rights reserved.
+ */
+
+#ifndef __sizes_h
+#define __sizes_h                       1
+
+/* handy sizes */
+#define SZ_1K                           0x00000400
+#define SZ_4K                           0x00001000
+#define SZ_8K                           0x00002000
+#define SZ_16K                          0x00004000
+#define SZ_64K                          0x00010000
+#define SZ_128K                         0x00020000
+#define SZ_256K                         0x00040000
+#define SZ_512K                         0x00080000
+
+#define SZ_1M                           0x00100000
+#define SZ_2M                           0x00200000
+#define SZ_4M                           0x00400000
+#define SZ_8M                           0x00800000
+#define SZ_16M                          0x01000000
+#define SZ_32M                          0x02000000
+#define SZ_64M                          0x04000000
+#define SZ_128M                         0x08000000
+#define SZ_256M                         0x10000000
+#define SZ_512M                         0x20000000
+
+#define SZ_1G                           0x40000000
+#define SZ_2G                           0x80000000
+
+#endif
+
+/*         END */
diff -urN uClinux-dist/linux-2.4.x/include/linux/mtd/mtd.h linux-2.4.x/include/linux/mtd/mtd.h
--- uClinux-dist/linux-2.4.x/include/linux/mtd/mtd.h	2004-02-17 20:54:08.000000000 +0800
+++ linux-2.4.x/include/linux/mtd/mtd.h	2004-05-15 18:03:02.000000000 +0800
@@ -27,9 +27,9 @@
 };
 
 
-#define MTD_CHAR_MAJOR 90
-#define MTD_BLOCK_MAJOR 31
-#define MAX_MTD_DEVICES 16
+#define MTD_CHAR_MAJOR	90
+#define MTD_BLOCK_MAJOR	30	//31
+#define MAX_MTD_DEVICES	16
 
 
 
diff -urN uClinux-dist/linux-2.4.x/include/linux/serial_core.h linux-2.4.x/include/linux/serial_core.h
--- uClinux-dist/linux-2.4.x/include/linux/serial_core.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.4.x/include/linux/serial_core.h	2004-05-15 18:03:33.000000000 +0800
@@ -0,0 +1,351 @@
+/*
+ *  linux/drivers/char/serial_core.h
+ *
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *  $Id: serial_core.h,v 1.9.2.3 2001/11/26 22:32:45 rmk Exp $
+ */
+
+/*
+ * The type definitions.  These are from Ted Ts'o's serial.h
+ */
+#define PORT_UNKNOWN	0
+#define PORT_8250	1
+#define PORT_16450	2
+#define PORT_16550	3
+#define PORT_16550A	4
+#define PORT_CIRRUS	5
+#define PORT_16650	6
+#define PORT_16650V2	7
+#define PORT_16750	8
+#define PORT_STARTECH	9
+#define PORT_16C950	10
+#define PORT_16654	11
+#define PORT_16850	12
+#define PORT_RSA	13
+#define PORT_MAX_8250	13	/* max port ID */
+
+/*
+ * ARM specific type numbers.  These are not currently guaranteed
+ * to be implemented, and will change in the future.
+ */
+#define PORT_AMBA	32
+#define PORT_CLPS711X	33
+#define PORT_SA1100	34
+#define PORT_UART00	35
+#define PORT_21285	37
+#define PORT_S3C44B0	38
+
+#ifdef __KERNEL__
+
+#include <linux/config.h>
+#include <linux/interrupt.h>
+#include <linux/circ_buf.h>
+#include <linux/serial.h>
+#include <linux/spinlock.h>
+
+struct uart_port;
+struct uart_info;
+
+/*
+ * This structure describes all the operations that can be
+ * done on the physical hardware.
+ */
+struct uart_ops {
+	u_int	(*tx_empty)(struct uart_port *);
+	void	(*set_mctrl)(struct uart_port *, u_int mctrl);
+	u_int	(*get_mctrl)(struct uart_port *);
+	void	(*stop_tx)(struct uart_port *, u_int from_tty);
+	void	(*start_tx)(struct uart_port *, u_int nonempty, u_int from_tty);
+	void	(*stop_rx)(struct uart_port *);
+	void	(*enable_ms)(struct uart_port *);
+	void	(*break_ctl)(struct uart_port *, int ctl);
+	int	(*startup)(struct uart_port *, struct uart_info *);
+	void	(*shutdown)(struct uart_port *, struct uart_info *);
+	void	(*change_speed)(struct uart_port *, u_int cflag, u_int iflag, u_int quot);
+	void	(*pm)(struct uart_port *, u_int state, u_int oldstate);
+	int	(*set_wake)(struct uart_port *, u_int state);
+
+	/*
+	 * Return a string describing the type of the port
+	 */
+	const char *(*type)(struct uart_port *);
+
+	/*
+	 * Release IO and memory resources used by the port.
+	 * This includes iounmap if necessary.
+	 */
+	void	(*release_port)(struct uart_port *);
+
+	/*
+	 * Request IO and memory resources used by the port.
+	 * This includes iomapping the port if necessary.
+	 */
+	int	(*request_port)(struct uart_port *);
+	void	(*config_port)(struct uart_port *, int);
+	int	(*verify_port)(struct uart_port *, struct serial_struct *);
+	int	(*ioctl)(struct uart_port *, u_int, u_long);
+};
+
+#define UART_CONFIG_TYPE	(1 << 0)
+#define UART_CONFIG_IRQ		(1 << 1)
+
+struct uart_icount {
+	__u32	cts;
+	__u32	dsr;
+	__u32	rng;
+	__u32	dcd;
+	__u32	rx;
+	__u32	tx;
+	__u32	frame;
+	__u32	overrun;
+	__u32	parity;
+	__u32	brk;
+	__u32	buf_overrun;
+};
+
+struct uart_port {
+	u_int			iobase;			/* in/out[bwl] */
+	void			*membase;		/* read/write[bwl] */
+	u_int			irq;
+	u_int			uartclk;
+	u_char			fifosize;		/* tx fifo size */
+	u_char			x_char;
+	u_char			regshift;		/* reg offset shift */
+	u_char			iotype;			/* io access style */
+	u_char			hub6;
+	u_char			unused[7];
+	u_int			read_status_mask;
+	u_int			ignore_status_mask;
+	u_int			flags;
+	u_int			type;			/* port type */
+	struct uart_ops		*ops;
+	struct uart_icount	icount;
+	u_int			line;
+	u_long			mapbase;		/* for ioremap */
+};
+
+/*
+ * This is the state information which is persistent across opens.
+ * The low level driver must not to touch any elements contained
+ * within.
+ */
+struct uart_state {
+	u_int			close_delay;
+	u_int			closing_wait;
+	u_int			custom_divisor;
+	struct termios		normal_termios;
+	struct termios		callout_termios;
+
+	int			count;
+	struct uart_info	*info;
+	struct uart_port	*port;
+
+	struct semaphore	count_sem;	/* this protects 'count' */
+#ifdef CONFIG_PM
+	struct pm_dev		*pm;
+	struct console		*cons;		/* need this to handle cons */
+#endif
+};
+
+#define UART_XMIT_SIZE 1024
+/*
+ * This is the state information which is only valid when the port
+ * is open; it may be freed by the core driver once the device has
+ * been closed.  Either the low level driver or the core can modify
+ * stuff here.
+ */
+struct uart_info {
+	spinlock_t		lock;
+	struct uart_port	*port;
+	struct uart_ops		*ops;
+	struct uart_state	*state;
+	struct tty_struct	*tty;
+	struct circ_buf		xmit;
+	u_int			flags;
+
+	u_int			event;
+	u_int			timeout;
+	u_int			mctrl;
+	u_int			driver_priv;
+	int			blocked_open;
+	pid_t			session;
+	pid_t			pgrp;
+
+	struct tasklet_struct	tlet;
+
+	wait_queue_head_t	open_wait;
+	wait_queue_head_t	close_wait;
+	wait_queue_head_t	delta_msr_wait;
+
+	/*
+	 * List if uarts on the same IRQ line.
+	 */
+	struct uart_info	*next_info;
+/*
+ * This is placed at the end since it may not be present.
+ * Do not place any new members after here.
+ */
+#if defined(CONFIG_SERIAL_CORE_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+	u_long			sysrq;		/* available for driver use */
+#endif
+};
+
+/* number of characters left in xmit buffer before we ask for more */
+#define WAKEUP_CHARS		256
+
+#define EVT_WRITE_WAKEUP	0
+
+struct module;
+
+struct uart_driver {
+	struct module		*owner;
+	int			 normal_major;
+	const char		*normal_name;
+	struct tty_driver	*normal_driver;
+	int			 callout_major;
+	const char		*callout_name;
+	struct tty_driver	*callout_driver;
+	struct tty_struct	**table;
+	struct termios		**termios;
+	struct termios		**termios_locked;
+	int			 minor;
+	int			 nr;
+	struct uart_state	*state;			/* driver should pass NULL */
+	struct uart_port	*port;			/* array of port information */
+	struct console		*cons;
+};
+
+void uart_event(struct uart_info *info, int event);
+struct uart_port *uart_get_console(struct uart_port *ports, int nr,
+				   struct console *c);
+void uart_parse_options(char *options, int *baud, int *parity, int *bits,
+			int *flow);
+int uart_set_options(struct uart_port *port, struct console *co, int baud,
+		     int parity, int bits, int flow);
+int uart_register_driver(struct uart_driver *uart);
+void uart_unregister_driver(struct uart_driver *uart);
+void uart_unregister_port(struct uart_driver *reg, int line);
+int uart_register_port(struct uart_driver *reg, struct uart_port *port);
+
+/*
+ * The following are helper functions for the low level drivers.
+ */
+#ifdef SUPPORT_SYSRQ
+static inline int
+__uart_handle_sysrq_char(struct uart_info *info, unsigned int ch,
+			 struct pt_regs *regs)
+{
+	if (info->sysrq) {
+		if (ch && time_before(jiffies, info->sysrq)) {
+			handle_sysrq(ch, regs, NULL, NULL);
+			info->sysrq = 0;
+			return 1;
+		}
+		info->sysrq = 0;
+	}
+	return 0;
+}
+#endif
+
+/*
+ * We do the SysRQ and SAK checking like this...
+ */
+static inline int __uart_handle_break(struct uart_info *info, struct console *con)
+{
+#ifdef SUPPORT_SYSRQ
+	if (info->port->line == con->index) {
+		if (!info->sysrq) {
+			info->sysrq = jiffies + HZ*5;
+			return 1;
+		}
+		info->sysrq = 0;
+	}
+#endif
+	if (info->flags & ASYNC_SAK)
+		do_SAK(info->tty);
+	return 0;
+}
+
+#ifdef SUPPORT_SYSRQ
+#define uart_handle_break(info,con)		__uart_handle_break(info,con)
+#define uart_handle_sysrq_char(info,ch,regs)	__uart_handle_sysrq_char(info,ch,regs)
+#else
+#define uart_handle_break(info,con)	__uart_handle_break(info,NULL)
+#define uart_handle_sysrq_char(info,ch,regs)	(0)
+#endif
+
+/**
+ *	uart_handle_dcd_change - handle a change of carrier detect state
+ *	@info: uart_info structure for the open port
+ *	@status: new carrier detect status, nonzero if active
+ */
+static inline void
+uart_handle_dcd_change(struct uart_info *info, unsigned int status)
+{
+	struct uart_port *port = info->port;
+
+	port->icount.dcd++;
+
+#ifdef CONFIG_HARD_PPS
+	if ((info->flags & ASYNC_HARDPPS_CD) && status)
+		hardpps();
+#endif
+
+	if (info->flags & ASYNC_CHECK_CD) {
+		if (status)
+			wake_up_interruptible(&info->open_wait);
+		else if (!((info->flags & ASYNC_CALLOUT_ACTIVE) &&
+			   (info->flags & ASYNC_CALLOUT_NOHUP))) {
+			if (info->tty)
+				tty_hangup(info->tty);
+		}
+	}
+}
+
+/**
+ *	uart_handle_cts_change - handle a change of clear-to-send state
+ *	@info: uart_info structure for the open port
+ *	@status: new clear to send status, nonzero if active
+ */
+static inline void
+uart_handle_cts_change(struct uart_info *info, unsigned int status)
+{
+	struct uart_port *port = info->port;
+	unsigned long flags;
+
+	port->icount.cts++;
+
+	if (info->flags & ASYNC_CTS_FLOW) {
+		spin_lock_irqsave(&info->lock, flags);
+		if (info->tty->hw_stopped) {
+			if (status) {
+				info->tty->hw_stopped = 0;
+				info->ops->start_tx(port, 1, 0);
+				uart_event(info, EVT_WRITE_WAKEUP);
+			}
+		} else {
+			if (!status) {
+				info->tty->hw_stopped = 1;
+				info->ops->stop_tx(port, 0);
+			}
+		}
+		spin_unlock_irqrestore(&info->lock, flags);
+	}
+}
+
+#endif
diff -urN uClinux-dist/linux-2.4.x/kernel_44b0.cfg linux-2.4.x/kernel_44b0.cfg
--- uClinux-dist/linux-2.4.x/kernel_44b0.cfg	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.4.x/kernel_44b0.cfg	2004-05-18 11:57:08.000000000 +0800
@@ -0,0 +1,564 @@
+#
+# Automatically generated by make menuconfig: don't edit
+#
+CONFIG_ARM=y
+# CONFIG_SBUS is not set
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_UCLINUX=y
+MAGIC_ROM_PTR=y
+
+#
+# Code maturity level options
+#
+# CONFIG_EXPERIMENTAL is not set
+# CONFIG_OBSOLETE is not set
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# System Type
+#
+# CONFIG_ARCH_DSC21 is not set
+# CONFIG_ARCH_C5471 is not set
+# CONFIG_ARCH_CNXT is not set
+# CONFIG_ARCH_NETARM is not set
+# CONFIG_ARCH_TA7S is not set
+# CONFIG_ARCH_TA7V is not set
+# CONFIG_ARCH_SWARM is not set
+CONFIG_ARCH_SAMSUNG=y
+# CONFIG_ARCH_ATMEL is not set
+# CONFIG_CPU_BIG_ENDIAN is not set
+CONFIG_SET_MEM_PARAM=y
+DRAM_BASE=0x0C000000
+DRAM_SIZE=0x00800000
+FLASH_MEM_BASE=0x00000000
+FLASH_SIZE=0x00200000
+CONFIG_RAMKERNEL=y
+# CONFIG_ROMKERNEL is not set
+# CONFIG_BOARD_SMDK40100 is not set
+CONFIG_BOARD_MBA44=y
+# CONFIG_BOARD_EVS3C4530HEI is not set
+# CONFIG_BOARD_S3C2500REFRGP is not set
+# CONFIG_BOARD_SMDK2500 is not set
+# CONFIG_BOARD_SNDS100 is not set
+CONFIG_SPU_NAME="S3C44B0X"
+CONFIG_CPU_S3C44B0X=y
+CONFIG_CPU_ARM710=y
+CONFIG_CPU_32v4=y
+CONFIG_CPU_32=y
+# CONFIG_CPU_26 is not set
+CONFIG_NO_PGT_CACHE=y
+CONFIG_CPU_WITH_CACHE=y
+# CONFIG_CPU_WITH_MCR_INSTRUCTION is not set
+CONFIG_ARM_CLK=64000000
+
+#
+# General setup
+#
+# CONFIG_HOTPLUG is not set
+# CONFIG_PCMCIA is not set
+CONFIG_NET=y
+CONFIG_SYSVIPC=y
+# CONFIG_REDUCED_MEMORY is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+CONFIG_NWFPE=y
+CONFIG_KCORE_ELF=y
+# CONFIG_KCORE_AOUT is not set
+CONFIG_BINFMT_FLAT=y
+# CONFIG_BINFMT_ZFLAT is not set
+CONFIG_KERNEL_ELF=y
+# CONFIG_ARTHUR is not set
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_LEDS=y
+CONFIG_LEDS_TIMER=y
+CONFIG_LEDS_CPU=y
+# CONFIG_ALIGNMENT_TRAP is not set
+# CONFIG_RAM_ATTACHED_ROMFS is not set
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_FILTER is not set
+# CONFIG_UNIX is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_ARP_LIMIT is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_INET_ECN is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+
+#
+# Appletalk devices
+#
+# CONFIG_DEV_APPLETALK is not set
+# CONFIG_DECNET is not set
+# CONFIG_BRIDGE is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_IPSEC is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_ETH_S3C4510=y
+# CONFIG_ARM_AM79C961A is not set
+# CONFIG_ARM_CIRRUS is not set
+# CONFIG_SUNLANCE is not set
+# CONFIG_SUNBMAC is not set
+# CONFIG_SUNQE is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_LANCE is not set
+# CONFIG_NET_VENDOR_SMC is not set
+# CONFIG_NET_VENDOR_RACAL is not set
+CONFIG_NET_ISA=y
+# CONFIG_E2100 is not set
+# CONFIG_EWRK3 is not set
+# CONFIG_EEXPRESS is not set
+# CONFIG_EEXPRESS_PRO is not set
+# CONFIG_HPLAN_PLUS is not set
+# CONFIG_HPLAN is not set
+# CONFIG_LP486E is not set
+# CONFIG_ETH16I is not set
+CONFIG_NE2000=y
+# CONFIG_NE2000_16b is not set
+# CONFIG_NET_PCI is not set
+# CONFIG_NET_POCKET is not set
+# CONFIG_FEC is not set
+# CONFIG_CS89x0 is not set
+# CONFIG_UCCS8900 is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_MYRI_SBUS is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_FDDI is not set
+# CONFIG_PLIP is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+# CONFIG_NET_FC is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+
+#
+# Amateur Radio support
+#
+# CONFIG_HAMRADIO is not set
+
+#
+# IrDA (infrared) support
+#
+# CONFIG_IRDA is not set
+
+#
+# ATA/IDE/MFM/RLL support
+#
+# CONFIG_IDE is not set
+# CONFIG_BLK_DEV_IDE_MODES is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI support
+#
+# CONFIG_SCSI is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Console drivers
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_FB=y
+
+#
+# Frame-buffer support
+#
+CONFIG_FB=y
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FB_ACORN is not set
+# CONFIG_FB_CLPS711X is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_SA1100 is not set
+CONFIG_FB_S3C44B0X=y
+CONFIG_FBCON_ADVANCED=y
+# CONFIG_FBCON_MFB is not set
+# CONFIG_FBCON_CFB2 is not set
+CONFIG_FBCON_CFB4=y
+# CONFIG_FBCON_CFB8 is not set
+# CONFIG_FBCON_CFB16 is not set
+# CONFIG_FBCON_CFB24 is not set
+# CONFIG_FBCON_CFB32 is not set
+# CONFIG_FBCON_AFB is not set
+# CONFIG_FBCON_ILBM is not set
+# CONFIG_FBCON_IPLAN2P2 is not set
+# CONFIG_FBCON_IPLAN2P4 is not set
+# CONFIG_FBCON_IPLAN2P8 is not set
+# CONFIG_FBCON_MAC is not set
+# CONFIG_FBCON_VGA_PLANES is not set
+# CONFIG_FBCON_VGA is not set
+# CONFIG_FBCON_HGA is not set
+# CONFIG_FBCON_FONTWIDTH8_ONLY is not set
+CONFIG_FBCON_FONTS=y
+CONFIG_FONT_8x8=y
+# CONFIG_FONT_8x16 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Plug and Play configuration
+#
+# CONFIG_PNP is not set
+# CONFIG_ISAPNP is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_XD is not set
+# CONFIG_PARIDE is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_CISS_SCSI_TAPE is not set
+# CONFIG_CISS_MONITOR_THREAD is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=1024
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_BLK_DEV_RAMDISK_DATA is not set
+CONFIG_BLK_DEV_BLKMEM=y
+CONFIG_NOFLASH=y
+# CONFIG_AMDFLASH is not set
+# CONFIG_INTELFLASH is not set
+# CONFIG_BLK_STATS is not set
+
+#
+# File systems
+#
+# CONFIG_QUOTA is not set
+# CONFIG_QFMT_V2 is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_ADFS_FS_RW is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BEFS_DEBUG is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_JBD_DEBUG is not set
+# CONFIG_FAT_FS is not set
+# CONFIG_MSDOS_FS is not set
+# CONFIG_UMSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_CRAMFS=y
+# CONFIG_TMPFS is not set
+CONFIG_RAMFS=y
+# CONFIG_ISO9660_FS is not set
+# CONFIG_JOLIET is not set
+# CONFIG_ZISOFS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_JFS_DEBUG is not set
+# CONFIG_JFS_STATISTICS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_NTFS_FS is not set
+# CONFIG_NTFS_RW is not set
+# CONFIG_HPFS_FS is not set
+CONFIG_PROC_FS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVFS_MOUNT is not set
+# CONFIG_DEVFS_DEBUG is not set
+# CONFIG_DEVPTS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX4FS_RW is not set
+CONFIG_ROMFS_FS=y
+CONFIG_EXT2_FS=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UDF_FS is not set
+# CONFIG_UDF_RW is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_UFS_FS_WRITE is not set
+
+#
+# Network File Systems
+#
+# CONFIG_CODA_FS is not set
+# CONFIG_INTERMEZZO_FS is not set
+# CONFIG_NFS_FS is not set
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_ROOT_NFS is not set
+# CONFIG_NFSD is not set
+# CONFIG_NFSD_V3 is not set
+# CONFIG_NFSD_TCP is not set
+# CONFIG_SUNRPC is not set
+# CONFIG_LOCKD is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_NCPFS_PACKET_SIGNING is not set
+# CONFIG_NCPFS_IOCTL_LOCKING is not set
+# CONFIG_NCPFS_STRONG is not set
+# CONFIG_NCPFS_NFS_NS is not set
+# CONFIG_NCPFS_OS2_NS is not set
+# CONFIG_NCPFS_SMALLDOS is not set
+# CONFIG_NCPFS_NLS is not set
+# CONFIG_NCPFS_EXTRAS is not set
+# CONFIG_ZISOFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+# CONFIG_SMB_NLS is not set
+# CONFIG_NLS is not set
+
+#
+# Character devices
+#
+CONFIG_SERIAL_S3C44B0X=y
+# CONFIG_CONSOLE_NULL is not set
+CONFIG_CONSOLE_UART=y
+CONFIG_SERIAL_S3C44B0X_CONSOLE=y
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_ANAKIN is not set
+# CONFIG_SERIAL_ANAKIN_CONSOLE is not set
+CONFIG_SERIAL_S3C44B0X=y
+CONFIG_SERIAL_S3C44B0X_CONSOLE=y
+CONFIG_S3C44B0_DEFAULT_BAUDRATE=57600
+# CONFIG_SERIAL_AMBA is not set
+# CONFIG_SERIAL_AMBA_CONSOLE is not set
+# CONFIG_SERIAL_CLPS711X is not set
+# CONFIG_SERIAL_CLPS711X_CONSOLE is not set
+# CONFIG_SERIAL_21285 is not set
+# CONFIG_SERIAL_21285_OLD is not set
+# CONFIG_SERIAL_21285_CONSOLE is not set
+# CONFIG_SERIAL_UART00 is not set
+# CONFIG_SERIAL_UART00_CONSOLE is not set
+# CONFIG_SERIAL_SA1100 is not set
+# CONFIG_SERIAL_SA1100_CONSOLE is not set
+# CONFIG_SERIAL_8250 is not set
+# CONFIG_SERIAL_8250_CONSOLE is not set
+# CONFIG_SERIAL_8250_EXTENDED is not set
+# CONFIG_SERIAL_8250_MANY_PORTS is not set
+# CONFIG_SERIAL_8250_SHARE_IRQ is not set
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+# CONFIG_SERIAL_8250_MULTIPORT is not set
+# CONFIG_SERIAL_8250_HUB6 is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_LEDMAN is not set
+# CONFIG_DS1302 is not set
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+# CONFIG_SERIAL is not set
+# CONFIG_SERIAL_EXTENDED is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_UNIX98_PTYS is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Mice
+#
+# CONFIG_BUSMOUSE is not set
+# CONFIG_MOUSE is not set
+
+#
+# Joysticks
+#
+# CONFIG_INPUT_GAMEPORT is not set
+# CONFIG_INPUT_NS558 is not set
+# CONFIG_INPUT_LIGHTNING is not set
+# CONFIG_INPUT_PCIGAME is not set
+# CONFIG_INPUT_CS461X is not set
+# CONFIG_INPUT_EMU10K1 is not set
+# CONFIG_INPUT_SERIO is not set
+# CONFIG_INPUT_SERPORT is not set
+# CONFIG_INPUT_ANALOG is not set
+# CONFIG_INPUT_A3D is not set
+# CONFIG_INPUT_ADI is not set
+# CONFIG_INPUT_COBRA is not set
+# CONFIG_INPUT_GF2K is not set
+# CONFIG_INPUT_GRIP is not set
+# CONFIG_INPUT_INTERACT is not set
+# CONFIG_INPUT_TMDC is not set
+# CONFIG_INPUT_SIDEWINDER is not set
+# CONFIG_INPUT_IFORCE_USB is not set
+# CONFIG_INPUT_IFORCE_232 is not set
+# CONFIG_INPUT_WARRIOR is not set
+# CONFIG_INPUT_MAGELLAN is not set
+# CONFIG_INPUT_SPACEORB is not set
+# CONFIG_INPUT_SPACEBALL is not set
+# CONFIG_INPUT_STINGER is not set
+# CONFIG_INPUT_DB9 is not set
+# CONFIG_INPUT_GAMECON is not set
+# CONFIG_INPUT_TURBOGRAFX is not set
+# CONFIG_QIC02_TAPE is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_IPMI_PANIC_EVENT is not set
+# CONFIG_IPMI_DEVICE_INTERFACE is not set
+# CONFIG_IPMI_KCS is not set
+# CONFIG_IPMI_WATCHDOG is not set
+
+#
+# Controller Area Network Cards/Chips
+#
+# CONFIG_CAN4LINUX is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_SCx200_GPIO is not set
+# CONFIG_AMD_PM768 is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+
+#
+# Direct Rendering Manager (XFree86 DRI support)
+#
+# CONFIG_DRM is not set
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+
+#
+# Support for USB gadgets
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+# CONFIG_I2O_BLOCK is not set
+# CONFIG_I2O_LAN is not set
+# CONFIG_I2O_SCSI is not set
+# CONFIG_I2O_PROC is not set
+
+#
+# Kernel hacking
+#
+CONFIG_FRAME_POINTER=y
+# CONFIG_REVISIT is not set
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_USER is not set
+CONFIG_DEBUG_INFO=y
+# CONFIG_MAGIC_SYSRQ is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC32 is not set
+CONFIG_ZLIB_INFLATE=y
+# CONFIG_ZLIB_DEFLATE is not set
diff -urN uClinux-dist/linux-2.4.x/kernel_44b0.cfg.old linux-2.4.x/kernel_44b0.cfg.old
--- uClinux-dist/linux-2.4.x/kernel_44b0.cfg.old	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.4.x/kernel_44b0.cfg.old	2004-05-18 11:57:05.000000000 +0800
@@ -0,0 +1,559 @@
+#
+# Automatically generated by make menuconfig: don't edit
+#
+CONFIG_ARM=y
+# CONFIG_SBUS is not set
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_UCLINUX=y
+MAGIC_ROM_PTR=y
+
+#
+# Code maturity level options
+#
+# CONFIG_EXPERIMENTAL is not set
+# CONFIG_OBSOLETE is not set
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# System Type
+#
+# CONFIG_ARCH_DSC21 is not set
+# CONFIG_ARCH_C5471 is not set
+# CONFIG_ARCH_CNXT is not set
+# CONFIG_ARCH_NETARM is not set
+# CONFIG_ARCH_TA7S is not set
+# CONFIG_ARCH_TA7V is not set
+# CONFIG_ARCH_SWARM is not set
+CONFIG_ARCH_SAMSUNG=y
+# CONFIG_ARCH_ATMEL is not set
+# CONFIG_CPU_BIG_ENDIAN is not set
+CONFIG_SET_MEM_PARAM=y
+DRAM_BASE=0x0C000000
+DRAM_SIZE=0x00800000
+FLASH_MEM_BASE=0x00000000
+FLASH_SIZE=0x00200000
+CONFIG_RAMKERNEL=y
+# CONFIG_ROMKERNEL is not set
+# CONFIG_BOARD_SMDK40100 is not set
+CONFIG_BOARD_MBA44=y
+# CONFIG_BOARD_EVS3C4530HEI is not set
+# CONFIG_BOARD_S3C2500REFRGP is not set
+# CONFIG_BOARD_SMDK2500 is not set
+# CONFIG_BOARD_SNDS100 is not set
+CONFIG_SPU_NAME="S3C44B0X"
+CONFIG_CPU_S3C44B0X=y
+CONFIG_CPU_ARM710=y
+CONFIG_CPU_32v4=y
+CONFIG_CPU_32=y
+# CONFIG_CPU_26 is not set
+CONFIG_NO_PGT_CACHE=y
+CONFIG_CPU_WITH_CACHE=y
+# CONFIG_CPU_WITH_MCR_INSTRUCTION is not set
+CONFIG_ARM_CLK=64000000
+
+#
+# General setup
+#
+# CONFIG_HOTPLUG is not set
+# CONFIG_PCMCIA is not set
+CONFIG_NET=y
+CONFIG_SYSVIPC=y
+# CONFIG_REDUCED_MEMORY is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+CONFIG_NWFPE=y
+CONFIG_KCORE_ELF=y
+# CONFIG_KCORE_AOUT is not set
+CONFIG_BINFMT_FLAT=y
+# CONFIG_BINFMT_ZFLAT is not set
+CONFIG_KERNEL_ELF=y
+# CONFIG_ARTHUR is not set
+# CONFIG_CMDLINE_BOOL is not set
+# CONFIG_ALIGNMENT_TRAP is not set
+# CONFIG_RAM_ATTACHED_ROMFS is not set
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_FILTER is not set
+# CONFIG_UNIX is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_ARP_LIMIT is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_INET_ECN is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+
+#
+# Appletalk devices
+#
+# CONFIG_DEV_APPLETALK is not set
+# CONFIG_DECNET is not set
+# CONFIG_BRIDGE is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_IPSEC is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_ARM_AM79C961A is not set
+# CONFIG_ARM_CIRRUS is not set
+# CONFIG_SUNLANCE is not set
+# CONFIG_SUNBMAC is not set
+# CONFIG_SUNQE is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_LANCE is not set
+# CONFIG_NET_VENDOR_SMC is not set
+# CONFIG_NET_VENDOR_RACAL is not set
+CONFIG_NET_ISA=y
+# CONFIG_E2100 is not set
+# CONFIG_EWRK3 is not set
+# CONFIG_EEXPRESS is not set
+# CONFIG_EEXPRESS_PRO is not set
+# CONFIG_HPLAN_PLUS is not set
+# CONFIG_HPLAN is not set
+# CONFIG_LP486E is not set
+# CONFIG_ETH16I is not set
+CONFIG_NE2000=y
+# CONFIG_NET_PCI is not set
+# CONFIG_NET_POCKET is not set
+# CONFIG_FEC is not set
+# CONFIG_CS89x0 is not set
+# CONFIG_UCCS8900 is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_MYRI_SBUS is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_FDDI is not set
+# CONFIG_PLIP is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+# CONFIG_NET_FC is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+
+#
+# Amateur Radio support
+#
+# CONFIG_HAMRADIO is not set
+
+#
+# IrDA (infrared) support
+#
+# CONFIG_IRDA is not set
+
+#
+# ATA/IDE/MFM/RLL support
+#
+# CONFIG_IDE is not set
+# CONFIG_BLK_DEV_IDE_MODES is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI support
+#
+# CONFIG_SCSI is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Console drivers
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_FB=y
+
+#
+# Frame-buffer support
+#
+CONFIG_FB=y
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FB_ACORN is not set
+# CONFIG_FB_CLPS711X is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_SA1100 is not set
+CONFIG_FB_S3C44B0X=y
+CONFIG_FBCON_ADVANCED=y
+# CONFIG_FBCON_MFB is not set
+# CONFIG_FBCON_CFB2 is not set
+CONFIG_FBCON_CFB4=y
+# CONFIG_FBCON_CFB8 is not set
+# CONFIG_FBCON_CFB16 is not set
+# CONFIG_FBCON_CFB24 is not set
+# CONFIG_FBCON_CFB32 is not set
+# CONFIG_FBCON_AFB is not set
+# CONFIG_FBCON_ILBM is not set
+# CONFIG_FBCON_IPLAN2P2 is not set
+# CONFIG_FBCON_IPLAN2P4 is not set
+# CONFIG_FBCON_IPLAN2P8 is not set
+# CONFIG_FBCON_MAC is not set
+# CONFIG_FBCON_VGA_PLANES is not set
+# CONFIG_FBCON_VGA is not set
+# CONFIG_FBCON_HGA is not set
+# CONFIG_FBCON_FONTWIDTH8_ONLY is not set
+CONFIG_FBCON_FONTS=y
+CONFIG_FONT_8x8=y
+# CONFIG_FONT_8x16 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Plug and Play configuration
+#
+# CONFIG_PNP is not set
+# CONFIG_ISAPNP is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_XD is not set
+# CONFIG_PARIDE is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_CISS_SCSI_TAPE is not set
+# CONFIG_CISS_MONITOR_THREAD is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=1024
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_BLK_DEV_RAMDISK_DATA is not set
+CONFIG_BLK_DEV_BLKMEM=y
+CONFIG_NOFLASH=y
+# CONFIG_AMDFLASH is not set
+# CONFIG_INTELFLASH is not set
+# CONFIG_BLK_STATS is not set
+
+#
+# File systems
+#
+# CONFIG_QUOTA is not set
+# CONFIG_QFMT_V2 is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_ADFS_FS_RW is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BEFS_DEBUG is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_JBD_DEBUG is not set
+# CONFIG_FAT_FS is not set
+# CONFIG_MSDOS_FS is not set
+# CONFIG_UMSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_CRAMFS=y
+# CONFIG_TMPFS is not set
+CONFIG_RAMFS=y
+# CONFIG_ISO9660_FS is not set
+# CONFIG_JOLIET is not set
+# CONFIG_ZISOFS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_JFS_DEBUG is not set
+# CONFIG_JFS_STATISTICS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_NTFS_FS is not set
+# CONFIG_NTFS_RW is not set
+# CONFIG_HPFS_FS is not set
+CONFIG_PROC_FS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVFS_MOUNT is not set
+# CONFIG_DEVFS_DEBUG is not set
+# CONFIG_DEVPTS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX4FS_RW is not set
+CONFIG_ROMFS_FS=y
+CONFIG_EXT2_FS=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UDF_FS is not set
+# CONFIG_UDF_RW is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_UFS_FS_WRITE is not set
+
+#
+# Network File Systems
+#
+# CONFIG_CODA_FS is not set
+# CONFIG_INTERMEZZO_FS is not set
+# CONFIG_NFS_FS is not set
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_ROOT_NFS is not set
+# CONFIG_NFSD is not set
+# CONFIG_NFSD_V3 is not set
+# CONFIG_NFSD_TCP is not set
+# CONFIG_SUNRPC is not set
+# CONFIG_LOCKD is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_NCPFS_PACKET_SIGNING is not set
+# CONFIG_NCPFS_IOCTL_LOCKING is not set
+# CONFIG_NCPFS_STRONG is not set
+# CONFIG_NCPFS_NFS_NS is not set
+# CONFIG_NCPFS_OS2_NS is not set
+# CONFIG_NCPFS_SMALLDOS is not set
+# CONFIG_NCPFS_NLS is not set
+# CONFIG_NCPFS_EXTRAS is not set
+# CONFIG_ZISOFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+# CONFIG_SMB_NLS is not set
+# CONFIG_NLS is not set
+
+#
+# Character devices
+#
+CONFIG_SERIAL_S3C44B0X=y
+# CONFIG_CONSOLE_NULL is not set
+CONFIG_CONSOLE_UART=y
+CONFIG_SERIAL_S3C44B0X_CONSOLE=y
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_ANAKIN is not set
+# CONFIG_SERIAL_ANAKIN_CONSOLE is not set
+CONFIG_SERIAL_S3C44B0X=y
+CONFIG_SERIAL_S3C44B0X_CONSOLE=y
+CONFIG_S3C44B0_DEFAULT_BAUDRATE=57600
+# CONFIG_SERIAL_AMBA is not set
+# CONFIG_SERIAL_AMBA_CONSOLE is not set
+# CONFIG_SERIAL_CLPS711X is not set
+# CONFIG_SERIAL_CLPS711X_CONSOLE is not set
+# CONFIG_SERIAL_21285 is not set
+# CONFIG_SERIAL_21285_OLD is not set
+# CONFIG_SERIAL_21285_CONSOLE is not set
+# CONFIG_SERIAL_UART00 is not set
+# CONFIG_SERIAL_UART00_CONSOLE is not set
+# CONFIG_SERIAL_SA1100 is not set
+# CONFIG_SERIAL_SA1100_CONSOLE is not set
+# CONFIG_SERIAL_8250 is not set
+# CONFIG_SERIAL_8250_CONSOLE is not set
+# CONFIG_SERIAL_8250_EXTENDED is not set
+# CONFIG_SERIAL_8250_MANY_PORTS is not set
+# CONFIG_SERIAL_8250_SHARE_IRQ is not set
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+# CONFIG_SERIAL_8250_MULTIPORT is not set
+# CONFIG_SERIAL_8250_HUB6 is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_LEDMAN is not set
+# CONFIG_DS1302 is not set
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+# CONFIG_SERIAL is not set
+# CONFIG_SERIAL_EXTENDED is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_UNIX98_PTYS is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Mice
+#
+# CONFIG_BUSMOUSE is not set
+# CONFIG_MOUSE is not set
+
+#
+# Joysticks
+#
+# CONFIG_INPUT_GAMEPORT is not set
+# CONFIG_INPUT_NS558 is not set
+# CONFIG_INPUT_LIGHTNING is not set
+# CONFIG_INPUT_PCIGAME is not set
+# CONFIG_INPUT_CS461X is not set
+# CONFIG_INPUT_EMU10K1 is not set
+# CONFIG_INPUT_SERIO is not set
+# CONFIG_INPUT_SERPORT is not set
+# CONFIG_INPUT_ANALOG is not set
+# CONFIG_INPUT_A3D is not set
+# CONFIG_INPUT_ADI is not set
+# CONFIG_INPUT_COBRA is not set
+# CONFIG_INPUT_GF2K is not set
+# CONFIG_INPUT_GRIP is not set
+# CONFIG_INPUT_INTERACT is not set
+# CONFIG_INPUT_TMDC is not set
+# CONFIG_INPUT_SIDEWINDER is not set
+# CONFIG_INPUT_IFORCE_USB is not set
+# CONFIG_INPUT_IFORCE_232 is not set
+# CONFIG_INPUT_WARRIOR is not set
+# CONFIG_INPUT_MAGELLAN is not set
+# CONFIG_INPUT_SPACEORB is not set
+# CONFIG_INPUT_SPACEBALL is not set
+# CONFIG_INPUT_STINGER is not set
+# CONFIG_INPUT_DB9 is not set
+# CONFIG_INPUT_GAMECON is not set
+# CONFIG_INPUT_TURBOGRAFX is not set
+# CONFIG_QIC02_TAPE is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_IPMI_PANIC_EVENT is not set
+# CONFIG_IPMI_DEVICE_INTERFACE is not set
+# CONFIG_IPMI_KCS is not set
+# CONFIG_IPMI_WATCHDOG is not set
+
+#
+# Controller Area Network Cards/Chips
+#
+# CONFIG_CAN4LINUX is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_SCx200_GPIO is not set
+# CONFIG_AMD_PM768 is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+
+#
+# Direct Rendering Manager (XFree86 DRI support)
+#
+# CONFIG_DRM is not set
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+
+#
+# Support for USB gadgets
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+# CONFIG_I2O_BLOCK is not set
+# CONFIG_I2O_LAN is not set
+# CONFIG_I2O_SCSI is not set
+# CONFIG_I2O_PROC is not set
+
+#
+# Kernel hacking
+#
+CONFIG_FRAME_POINTER=y
+# CONFIG_REVISIT is not set
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_USER is not set
+CONFIG_DEBUG_INFO=y
+# CONFIG_MAGIC_SYSRQ is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC32 is not set
+CONFIG_ZLIB_INFLATE=y
+# CONFIG_ZLIB_DEFLATE is not set
diff -urN uClinux-dist/linux-2.4.x/kernel_4510.cfg linux-2.4.x/kernel_4510.cfg
--- uClinux-dist/linux-2.4.x/kernel_4510.cfg	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.4.x/kernel_4510.cfg	2004-05-18 11:43:07.000000000 +0800
@@ -0,0 +1,504 @@
+#
+# Automatically generated by make menuconfig: don't edit
+#
+CONFIG_ARM=y
+# CONFIG_SBUS is not set
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_UCLINUX=y
+MAGIC_ROM_PTR=y
+
+#
+# Code maturity level options
+#
+# CONFIG_EXPERIMENTAL is not set
+# CONFIG_OBSOLETE is not set
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# System Type
+#
+# CONFIG_ARCH_DSC21 is not set
+# CONFIG_ARCH_C5471 is not set
+# CONFIG_ARCH_CNXT is not set
+# CONFIG_ARCH_NETARM is not set
+# CONFIG_ARCH_TA7S is not set
+# CONFIG_ARCH_TA7V is not set
+# CONFIG_ARCH_SWARM is not set
+CONFIG_ARCH_SAMSUNG=y
+# CONFIG_ARCH_ATMEL is not set
+# CONFIG_CPU_BIG_ENDIAN is not set
+CONFIG_SET_MEM_PARAM=y
+DRAM_BASE=0
+DRAM_SIZE=01000000
+FLASH_MEM_BASE=01000000
+FLASH_SIZE=0x00200000
+CONFIG_RAMKERNEL=y
+# CONFIG_ROMKERNEL is not set
+# CONFIG_BOARD_SMDK40100 is not set
+# CONFIG_BOARD_MBA44 is not set
+# CONFIG_BOARD_EVS3C4530HEI is not set
+# CONFIG_BOARD_S3C2500REFRGP is not set
+# CONFIG_BOARD_SMDK2500 is not set
+CONFIG_BOARD_SNDS100=y
+CONFIG_NO_PGT_CACHE=y
+CONFIG_CPU_32=y
+CONFIG_CPU_32v4=y
+# CONFIG_CPU_26 is not set
+CONFIG_CPU_S3C4510=y
+CONFIG_CPU_ARM710=y
+CONFIG_CPU_WITH_CACHE=y
+# CONFIG_CPU_WITH_MCR_INSTRUCTION is not set
+# CONFIG_ZYXEL_BOOTEXT is not set
+
+#
+# General setup
+#
+# CONFIG_HOTPLUG is not set
+# CONFIG_PCMCIA is not set
+CONFIG_NET=y
+CONFIG_SYSVIPC=y
+# CONFIG_REDUCED_MEMORY is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+CONFIG_NWFPE=y
+CONFIG_KCORE_ELF=y
+# CONFIG_KCORE_AOUT is not set
+CONFIG_BINFMT_FLAT=y
+# CONFIG_BINFMT_ZFLAT is not set
+CONFIG_KERNEL_ELF=y
+# CONFIG_ARTHUR is not set
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_LEDS=y
+CONFIG_LEDS_TIMER=y
+CONFIG_LEDS_CPU=y
+# CONFIG_ALIGNMENT_TRAP is not set
+# CONFIG_RAM_ATTACHED_ROMFS is not set
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_FILTER is not set
+# CONFIG_UNIX is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_ARP_LIMIT is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_INET_ECN is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+
+#
+# Appletalk devices
+#
+# CONFIG_DEV_APPLETALK is not set
+# CONFIG_DECNET is not set
+# CONFIG_BRIDGE is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_IPSEC is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_ETH_S3C4510=y
+# CONFIG_ARM_AM79C961A is not set
+# CONFIG_ARM_CIRRUS is not set
+# CONFIG_SUNLANCE is not set
+# CONFIG_SUNBMAC is not set
+# CONFIG_SUNQE is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_LANCE is not set
+# CONFIG_NET_VENDOR_SMC is not set
+# CONFIG_NET_VENDOR_RACAL is not set
+# CONFIG_NET_ISA is not set
+# CONFIG_NET_PCI is not set
+# CONFIG_NET_POCKET is not set
+# CONFIG_FEC is not set
+# CONFIG_CS89x0 is not set
+# CONFIG_UCCS8900 is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_MYRI_SBUS is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_FDDI is not set
+# CONFIG_PLIP is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+# CONFIG_NET_FC is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+
+#
+# Amateur Radio support
+#
+# CONFIG_HAMRADIO is not set
+
+#
+# IrDA (infrared) support
+#
+# CONFIG_IRDA is not set
+
+#
+# ATA/IDE/MFM/RLL support
+#
+# CONFIG_IDE is not set
+# CONFIG_BLK_DEV_IDE_MODES is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI support
+#
+# CONFIG_SCSI is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Plug and Play configuration
+#
+# CONFIG_PNP is not set
+# CONFIG_ISAPNP is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_XD is not set
+# CONFIG_PARIDE is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_CISS_SCSI_TAPE is not set
+# CONFIG_CISS_MONITOR_THREAD is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=1024
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_BLK_DEV_RAMDISK_DATA is not set
+CONFIG_BLK_DEV_BLKMEM=y
+CONFIG_NOFLASH=y
+# CONFIG_AMDFLASH is not set
+# CONFIG_INTELFLASH is not set
+# CONFIG_BLK_STATS is not set
+
+#
+# File systems
+#
+# CONFIG_QUOTA is not set
+# CONFIG_QFMT_V2 is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_ADFS_FS_RW is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BEFS_DEBUG is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_JBD_DEBUG is not set
+# CONFIG_FAT_FS is not set
+# CONFIG_MSDOS_FS is not set
+# CONFIG_UMSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_CRAMFS=y
+# CONFIG_TMPFS is not set
+CONFIG_RAMFS=y
+# CONFIG_ISO9660_FS is not set
+# CONFIG_JOLIET is not set
+# CONFIG_ZISOFS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_JFS_DEBUG is not set
+# CONFIG_JFS_STATISTICS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_NTFS_FS is not set
+# CONFIG_NTFS_RW is not set
+# CONFIG_HPFS_FS is not set
+CONFIG_PROC_FS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVFS_MOUNT is not set
+# CONFIG_DEVFS_DEBUG is not set
+# CONFIG_DEVPTS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX4FS_RW is not set
+CONFIG_ROMFS_FS=y
+CONFIG_EXT2_FS=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UDF_FS is not set
+# CONFIG_UDF_RW is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_UFS_FS_WRITE is not set
+
+#
+# Network File Systems
+#
+# CONFIG_CODA_FS is not set
+# CONFIG_INTERMEZZO_FS is not set
+# CONFIG_NFS_FS is not set
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_ROOT_NFS is not set
+# CONFIG_NFSD is not set
+# CONFIG_NFSD_V3 is not set
+# CONFIG_NFSD_TCP is not set
+# CONFIG_SUNRPC is not set
+# CONFIG_LOCKD is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_NCPFS_PACKET_SIGNING is not set
+# CONFIG_NCPFS_IOCTL_LOCKING is not set
+# CONFIG_NCPFS_STRONG is not set
+# CONFIG_NCPFS_NFS_NS is not set
+# CONFIG_NCPFS_OS2_NS is not set
+# CONFIG_NCPFS_SMALLDOS is not set
+# CONFIG_NCPFS_NLS is not set
+# CONFIG_NCPFS_EXTRAS is not set
+# CONFIG_ZISOFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+# CONFIG_SMB_NLS is not set
+# CONFIG_NLS is not set
+
+#
+# Character devices
+#
+CONFIG_SERIAL_SAMSUNG=y
+CONFIG_SERIAL_SAMSUNG_CONSOLE=y
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_ANAKIN is not set
+# CONFIG_SERIAL_ANAKIN_CONSOLE is not set
+# CONFIG_SERIAL_S3C44B0X is not set
+# CONFIG_SERIAL_S3C44B0X_CONSOLE is not set
+# CONFIG_SERIAL_AMBA is not set
+# CONFIG_SERIAL_AMBA_CONSOLE is not set
+# CONFIG_SERIAL_CLPS711X is not set
+# CONFIG_SERIAL_CLPS711X_CONSOLE is not set
+# CONFIG_SERIAL_21285 is not set
+# CONFIG_SERIAL_21285_OLD is not set
+# CONFIG_SERIAL_21285_CONSOLE is not set
+# CONFIG_SERIAL_UART00 is not set
+# CONFIG_SERIAL_UART00_CONSOLE is not set
+# CONFIG_SERIAL_SA1100 is not set
+# CONFIG_SERIAL_SA1100_CONSOLE is not set
+# CONFIG_SERIAL_8250 is not set
+# CONFIG_SERIAL_8250_CONSOLE is not set
+# CONFIG_SERIAL_8250_EXTENDED is not set
+# CONFIG_SERIAL_8250_MANY_PORTS is not set
+# CONFIG_SERIAL_8250_SHARE_IRQ is not set
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+# CONFIG_SERIAL_8250_MULTIPORT is not set
+# CONFIG_SERIAL_8250_HUB6 is not set
+# CONFIG_LEDMAN is not set
+# CONFIG_DS1302 is not set
+# CONFIG_VT is not set
+# CONFIG_SERIAL is not set
+# CONFIG_SERIAL_EXTENDED is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_UNIX98_PTYS is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Mice
+#
+# CONFIG_BUSMOUSE is not set
+# CONFIG_MOUSE is not set
+
+#
+# Joysticks
+#
+# CONFIG_INPUT_GAMEPORT is not set
+# CONFIG_INPUT_NS558 is not set
+# CONFIG_INPUT_LIGHTNING is not set
+# CONFIG_INPUT_PCIGAME is not set
+# CONFIG_INPUT_CS461X is not set
+# CONFIG_INPUT_EMU10K1 is not set
+# CONFIG_INPUT_SERIO is not set
+# CONFIG_INPUT_SERPORT is not set
+# CONFIG_INPUT_ANALOG is not set
+# CONFIG_INPUT_A3D is not set
+# CONFIG_INPUT_ADI is not set
+# CONFIG_INPUT_COBRA is not set
+# CONFIG_INPUT_GF2K is not set
+# CONFIG_INPUT_GRIP is not set
+# CONFIG_INPUT_INTERACT is not set
+# CONFIG_INPUT_TMDC is not set
+# CONFIG_INPUT_SIDEWINDER is not set
+# CONFIG_INPUT_IFORCE_USB is not set
+# CONFIG_INPUT_IFORCE_232 is not set
+# CONFIG_INPUT_WARRIOR is not set
+# CONFIG_INPUT_MAGELLAN is not set
+# CONFIG_INPUT_SPACEORB is not set
+# CONFIG_INPUT_SPACEBALL is not set
+# CONFIG_INPUT_STINGER is not set
+# CONFIG_INPUT_DB9 is not set
+# CONFIG_INPUT_GAMECON is not set
+# CONFIG_INPUT_TURBOGRAFX is not set
+# CONFIG_QIC02_TAPE is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_IPMI_PANIC_EVENT is not set
+# CONFIG_IPMI_DEVICE_INTERFACE is not set
+# CONFIG_IPMI_KCS is not set
+# CONFIG_IPMI_WATCHDOG is not set
+
+#
+# Controller Area Network Cards/Chips
+#
+# CONFIG_CAN4LINUX is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_SCx200_GPIO is not set
+# CONFIG_AMD_PM768 is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+
+#
+# Direct Rendering Manager (XFree86 DRI support)
+#
+# CONFIG_DRM is not set
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+
+#
+# Support for USB gadgets
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+# CONFIG_I2O_BLOCK is not set
+# CONFIG_I2O_LAN is not set
+# CONFIG_I2O_SCSI is not set
+# CONFIG_I2O_PROC is not set
+
+#
+# Kernel hacking
+#
+CONFIG_FRAME_POINTER=y
+# CONFIG_REVISIT is not set
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_USER is not set
+CONFIG_DEBUG_INFO=y
+# CONFIG_MAGIC_SYSRQ is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC32 is not set
+CONFIG_ZLIB_INFLATE=y
+# CONFIG_ZLIB_DEFLATE is not set
diff -urN uClinux-dist/linux-2.4.x/kernel_4510.cfg.old linux-2.4.x/kernel_4510.cfg.old
--- uClinux-dist/linux-2.4.x/kernel_4510.cfg.old	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.4.x/kernel_4510.cfg.old	2004-05-18 11:43:05.000000000 +0800
@@ -0,0 +1,532 @@
+#
+# Automatically generated by make menuconfig: don't edit
+#
+CONFIG_ARM=y
+# CONFIG_SBUS is not set
+CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_UCLINUX=y
+MAGIC_ROM_PTR=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_OBSOLETE is not set
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# System Type
+#
+# CONFIG_ARCH_DSC21 is not set
+# CONFIG_ARCH_C5471 is not set
+# CONFIG_ARCH_CNXT is not set
+# CONFIG_ARCH_NETARM is not set
+# CONFIG_ARCH_TA7S is not set
+# CONFIG_ARCH_TA7V is not set
+# CONFIG_ARCH_SWARM is not set
+CONFIG_ARCH_SAMSUNG=y
+# CONFIG_ARCH_ATMEL is not set
+# CONFIG_CPU_BIG_ENDIAN is not set
+CONFIG_SET_MEM_PARAM=y
+DRAM_BASE=0
+DRAM_SIZE=01000000
+FLASH_MEM_BASE=01000000
+FLASH_SIZE=0x00200000
+CONFIG_RAMKERNEL=y
+# CONFIG_ROMKERNEL is not set
+# CONFIG_BOARD_SMDK40100 is not set
+# CONFIG_BOARD_MBA44 is not set
+# CONFIG_BOARD_EVS3C4530HEI is not set
+# CONFIG_BOARD_S3C2500REFRGP is not set
+# CONFIG_BOARD_SMDK2500 is not set
+CONFIG_BOARD_SNDS100=y
+CONFIG_NO_PGT_CACHE=y
+CONFIG_CPU_32=y
+CONFIG_CPU_32v4=y
+# CONFIG_CPU_26 is not set
+CONFIG_CPU_S3C4510=y
+CONFIG_CPU_ARM710=y
+CONFIG_CPU_WITH_CACHE=y
+# CONFIG_CPU_WITH_MCR_INSTRUCTION is not set
+# CONFIG_ZYXEL_BOOTEXT is not set
+
+#
+# General setup
+#
+# CONFIG_HOTPLUG is not set
+# CONFIG_PCMCIA is not set
+CONFIG_NET=y
+CONFIG_SYSVIPC=y
+# CONFIG_REDUCED_MEMORY is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+CONFIG_NWFPE=y
+CONFIG_KCORE_ELF=y
+# CONFIG_KCORE_AOUT is not set
+CONFIG_BINFMT_FLAT=y
+# CONFIG_BINFMT_ZFLAT is not set
+CONFIG_KERNEL_ELF=y
+# CONFIG_PM is not set
+# CONFIG_ARTHUR is not set
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_LEDS=y
+CONFIG_LEDS_TIMER=y
+CONFIG_LEDS_CPU=y
+# CONFIG_ALIGNMENT_TRAP is not set
+# CONFIG_RAM_ATTACHED_ROMFS is not set
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_FILTER is not set
+# CONFIG_UNIX is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_ARP_LIMIT is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_INET_ECN is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_IPV6 is not set
+# CONFIG_KHTTPD is not set
+
+#
+#    SCTP Configuration (EXPERIMENTAL)
+#
+CONFIG_IPV6_SCTP__=y
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+
+#
+# Appletalk devices
+#
+# CONFIG_DEV_APPLETALK is not set
+# CONFIG_DECNET is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_LLC is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_IPSEC is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_ETHERTAP is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_ETH_S3C4510=y
+# CONFIG_ARM_AM79C961A is not set
+# CONFIG_ARM_CIRRUS is not set
+# CONFIG_SUNLANCE is not set
+# CONFIG_SUNBMAC is not set
+# CONFIG_SUNQE is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_LANCE is not set
+# CONFIG_NET_VENDOR_SMC is not set
+# CONFIG_NET_VENDOR_RACAL is not set
+# CONFIG_NET_ISA is not set
+# CONFIG_NET_PCI is not set
+# CONFIG_NET_POCKET is not set
+# CONFIG_FEC is not set
+# CONFIG_CS89x0 is not set
+# CONFIG_UCCS8900 is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_MYRI_SBUS is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PLIP is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+# CONFIG_NET_FC is not set
+# CONFIG_RCPCI is not set
+# CONFIG_SHAPER is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+
+#
+# Amateur Radio support
+#
+# CONFIG_HAMRADIO is not set
+
+#
+# IrDA (infrared) support
+#
+# CONFIG_IRDA is not set
+
+#
+# ATA/IDE/MFM/RLL support
+#
+# CONFIG_IDE is not set
+# CONFIG_BLK_DEV_IDE_MODES is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI support
+#
+# CONFIG_SCSI is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Plug and Play configuration
+#
+# CONFIG_PNP is not set
+# CONFIG_ISAPNP is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_XD is not set
+# CONFIG_PARIDE is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_CISS_SCSI_TAPE is not set
+# CONFIG_CISS_MONITOR_THREAD is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=1024
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_BLK_DEV_RAMDISK_DATA is not set
+CONFIG_BLK_DEV_BLKMEM=y
+CONFIG_NOFLASH=y
+# CONFIG_AMDFLASH is not set
+# CONFIG_INTELFLASH is not set
+# CONFIG_BLK_STATS is not set
+
+#
+# File systems
+#
+# CONFIG_QUOTA is not set
+# CONFIG_QFMT_V2 is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_ADFS_FS_RW is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BEFS_DEBUG is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_JBD_DEBUG is not set
+# CONFIG_FAT_FS is not set
+# CONFIG_MSDOS_FS is not set
+# CONFIG_UMSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_CRAMFS=y
+# CONFIG_TMPFS is not set
+CONFIG_RAMFS=y
+# CONFIG_ISO9660_FS is not set
+# CONFIG_JOLIET is not set
+# CONFIG_ZISOFS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_JFS_DEBUG is not set
+# CONFIG_JFS_STATISTICS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_NTFS_FS is not set
+# CONFIG_NTFS_RW is not set
+# CONFIG_HPFS_FS is not set
+CONFIG_PROC_FS=y
+CONFIG_DEVFS_FS=y
+CONFIG_DEVFS_MOUNT=y
+# CONFIG_DEVFS_DEBUG is not set
+# CONFIG_DEVPTS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX4FS_RW is not set
+CONFIG_ROMFS_FS=y
+CONFIG_EXT2_FS=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UDF_FS is not set
+# CONFIG_UDF_RW is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_UFS_FS_WRITE is not set
+
+#
+# Network File Systems
+#
+# CONFIG_CODA_FS is not set
+# CONFIG_INTERMEZZO_FS is not set
+# CONFIG_NFS_FS is not set
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_ROOT_NFS is not set
+# CONFIG_NFSD is not set
+# CONFIG_NFSD_V3 is not set
+# CONFIG_NFSD_TCP is not set
+# CONFIG_SUNRPC is not set
+# CONFIG_LOCKD is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_NCPFS_PACKET_SIGNING is not set
+# CONFIG_NCPFS_IOCTL_LOCKING is not set
+# CONFIG_NCPFS_STRONG is not set
+# CONFIG_NCPFS_NFS_NS is not set
+# CONFIG_NCPFS_OS2_NS is not set
+# CONFIG_NCPFS_SMALLDOS is not set
+# CONFIG_NCPFS_NLS is not set
+# CONFIG_NCPFS_EXTRAS is not set
+# CONFIG_ZISOFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+# CONFIG_SMB_NLS is not set
+# CONFIG_NLS is not set
+
+#
+# Character devices
+#
+CONFIG_SERIAL_SAMSUNG=y
+CONFIG_SERIAL_SAMSUNG_CONSOLE=y
+# CONFIG_SERIAL_S3C44B0X is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_ANAKIN is not set
+# CONFIG_SERIAL_ANAKIN_CONSOLE is not set
+# CONFIG_SERIAL_S3C44B0X is not set
+# CONFIG_SERIAL_S3C44B0X_CONSOLE is not set
+# CONFIG_SERIAL_AMBA is not set
+# CONFIG_SERIAL_AMBA_CONSOLE is not set
+# CONFIG_SERIAL_CLPS711X is not set
+# CONFIG_SERIAL_CLPS711X_CONSOLE is not set
+# CONFIG_SERIAL_21285 is not set
+# CONFIG_SERIAL_21285_OLD is not set
+# CONFIG_SERIAL_21285_CONSOLE is not set
+# CONFIG_SERIAL_UART00 is not set
+# CONFIG_SERIAL_UART00_CONSOLE is not set
+# CONFIG_SERIAL_SA1100 is not set
+# CONFIG_SERIAL_SA1100_CONSOLE is not set
+# CONFIG_SERIAL_8250 is not set
+# CONFIG_SERIAL_8250_CONSOLE is not set
+# CONFIG_SERIAL_8250_EXTENDED is not set
+# CONFIG_SERIAL_8250_MANY_PORTS is not set
+# CONFIG_SERIAL_8250_SHARE_IRQ is not set
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+# CONFIG_SERIAL_8250_MULTIPORT is not set
+# CONFIG_SERIAL_8250_HUB6 is not set
+# CONFIG_LEDMAN is not set
+# CONFIG_DS1302 is not set
+# CONFIG_VT is not set
+# CONFIG_SERIAL is not set
+# CONFIG_SERIAL_EXTENDED is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_UNIX98_PTYS is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Mice
+#
+# CONFIG_BUSMOUSE is not set
+# CONFIG_MOUSE is not set
+
+#
+# Joysticks
+#
+# CONFIG_INPUT_GAMEPORT is not set
+# CONFIG_INPUT_NS558 is not set
+# CONFIG_INPUT_LIGHTNING is not set
+# CONFIG_INPUT_PCIGAME is not set
+# CONFIG_INPUT_CS461X is not set
+# CONFIG_INPUT_EMU10K1 is not set
+# CONFIG_INPUT_SERIO is not set
+# CONFIG_INPUT_SERPORT is not set
+# CONFIG_INPUT_ANALOG is not set
+# CONFIG_INPUT_A3D is not set
+# CONFIG_INPUT_ADI is not set
+# CONFIG_INPUT_COBRA is not set
+# CONFIG_INPUT_GF2K is not set
+# CONFIG_INPUT_GRIP is not set
+# CONFIG_INPUT_INTERACT is not set
+# CONFIG_INPUT_TMDC is not set
+# CONFIG_INPUT_SIDEWINDER is not set
+# CONFIG_INPUT_IFORCE_USB is not set
+# CONFIG_INPUT_IFORCE_232 is not set
+# CONFIG_INPUT_WARRIOR is not set
+# CONFIG_INPUT_MAGELLAN is not set
+# CONFIG_INPUT_SPACEORB is not set
+# CONFIG_INPUT_SPACEBALL is not set
+# CONFIG_INPUT_STINGER is not set
+# CONFIG_INPUT_DB9 is not set
+# CONFIG_INPUT_GAMECON is not set
+# CONFIG_INPUT_TURBOGRAFX is not set
+# CONFIG_QIC02_TAPE is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_IPMI_PANIC_EVENT is not set
+# CONFIG_IPMI_DEVICE_INTERFACE is not set
+# CONFIG_IPMI_KCS is not set
+# CONFIG_IPMI_WATCHDOG is not set
+
+#
+# Controller Area Network Cards/Chips
+#
+# CONFIG_CAN4LINUX is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_SCx200_GPIO is not set
+# CONFIG_AMD_PM768 is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+
+#
+# Direct Rendering Manager (XFree86 DRI support)
+#
+# CONFIG_DRM is not set
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+
+#
+# Support for USB gadgets
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+# CONFIG_I2O_BLOCK is not set
+# CONFIG_I2O_LAN is not set
+# CONFIG_I2O_SCSI is not set
+# CONFIG_I2O_PROC is not set
+
+#
+# Kernel hacking
+#
+CONFIG_FRAME_POINTER=y
+# CONFIG_REVISIT is not set
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_USER is not set
+CONFIG_DEBUG_INFO=y
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_DEBUG_LL is not set
+# CONFIG_CONTIGUOUS_PAGE_ALLOC is not set
+# CONFIG_MEM_MAP is not set
+# CONFIG_NO_MMU_LARGE_ALLOCS is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC32 is not set
+CONFIG_ZLIB_INFLATE=y
+# CONFIG_ZLIB_DEFLATE is not set
diff -urN uClinux-dist/linux-2.4.x/Makefile linux-2.4.x/Makefile
--- uClinux-dist/linux-2.4.x/Makefile	2004-02-17 20:52:16.000000000 +0800
+++ linux-2.4.x/Makefile	2004-03-26 01:01:28.000000000 +0800
@@ -5,7 +5,7 @@
 
 KERNELRELEASE=$(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
 
-# ARCH := armnommu
+ARCH := armnommu
 # ARCH := m68knommu
 # ARCH := h8300
 # ARCH := niosnommu
@@ -40,7 +40,7 @@
 HOSTCFLAGS	= -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer
 
 # CROSS_COMPILE 	= m68k-elf-
-# CROSS_COMPILE 	= arm-elf-
+CROSS_COMPILE 	= arm-elf-
 # CROSS_COMPILE 	= h8300-elf-
 # CROSS_COMPILE 	= nios-elf-
 # CROSS_COMPILE		= e1-coff-
@@ -187,7 +187,8 @@
 
 DRIVERS-$(CONFIG_ACPI_BOOT) += drivers/acpi/acpi.o
 DRIVERS-$(CONFIG_PARPORT) += drivers/parport/driver.o
-DRIVERS-y += drivers/char/char.o \
+DRIVERS-y += drivers/serial/serial.o \
+	drivers/char/char.o \
 	drivers/block/block.o \
 	drivers/misc/misc.o \
 	drivers/net/net.o

diff -Naur uClinux-dist/linux-2.4.x/arch/armnommu/vmlinux-armv.lds.in linux-2.4.x/arch/armnommu/vmlinux-armv.lds.in
--- uClinux-dist/linux-2.4.x/arch/armnommu/vmlinux-armv.lds.in	2003-05-22 09:04:15.000000000 +0800
+++ linux-2.4.x/arch/armnommu/vmlinux-armv.lds.in	2003-05-24 23:14:15.000000000 +0800
@@ -59,6 +59,9 @@
 		__stop___kallsyms = .;

 		*(.got)			/* Global offset table		*/
+		romfs_data = .;
+		romfs.o
+		romfs_data_end = .;

 		_etext = .;		/* End of text section		*/
 	}

diff -Naur uClinux-dist/vendors/Samsung/44B0/Makefile vendors/Samsung/44B0/Makefile
--- uClinux-dist/vendors/Samsung/44B0/Makefile 2004-04-08 08:27:25.000000000 +0800
+++ uClinux-dist/vendors/Samsung/44B0/Makefile 2004-08-01 02:43:50.000000000 +0800
@@ -3,11 +3,13 @@
 #

 ROMFSIMG = $(IMAGEDIR)/romfs.img
-IMAGE    = $(IMAGEDIR)/image.bin
-ELFIMAGE = $(IMAGEDIR)/image.elf
-
-
+ROMIMAGE = $(IMAGEDIR)/image.rom
+RAMIMAGE = $(IMAGEDIR)/image.ram
+VERSIONSTR1 = uClinux-ARM7-S3C44B0X(www.hzlitai.com.cn)
+
@@ -55,23 +57,32 @@
	*) echo "ttyS0:linux:/bin/sh" >> $(ROMFSDIR)/etc/inittab ;; \
	esac
	$(ROMFSINST) /etc/motd
#	$(ROMFSINST) /etc/boa.conf
#	$(ROMFSINST) index.html /home/index.html
	$(ROMFSINST) /etc/passwd
	echo "$(VERSIONSTR) -- " `date` > $(ROMFSDIR)/etc/version
+	cp $(ROOTDIR)/user/ramimage/ramfs2048.img \
+		$(ROOTDIR)/romfs/etc/ramfs2048.img

image:
	[ -d $(IMAGEDIR) ] || mkdir -p $(IMAGEDIR)
	genromfs -v -V "ROMdisk" -f $(ROMFSIMG) -d $(ROMFSDIR)
-	$(CROSS_COMPILE)objcopy -O binary --remove-section=.romvec \
+	$(CROSS_COMPILE)ld -r -o $(ROOTDIR)/$(LINUXDIR)/romfs.o \
+			-b binary $(ROMFSIMG)
+	$(CROSS_COMPILE)objcopy -O binary -R .note -R .comment \
+			-S $(ROOTDIR)/$(LINUXDIR)/linux $(RAMIMAGE)
+	cp $(ROOTDIR)/$(LINUXDIR)/arch/armnommu/boot/zImage \
+			$(ROMIMAGE)
+
+#	$(CROSS_COMPILE)objcopy -O binary --remove-section=.romvec \	
			--remove-section=.text --remove-section=.ramvec \
			--remove-section=.init \
			--remove-section=.bss --remove-section=.eram \
			$(ROOTDIR)/$(LINUXDIR)/linux $(IMAGEDIR)/linux.data
-	$(CROSS_COMPILE)objcopy -O binary --remove-section=.ramvec \
+#	$(CROSS_COMPILE)objcopy -O binary --remove-section=.ramvec \
			--remove-section=.bss --remove-section=.data \
			--remove-section=.eram \
			--set-section-flags=.romvec=CONTENTS,ALLOC,LOAD,READONLY,CODE \
			$(ROOTDIR)/$(LINUXDIR)/linux $(IMAGEDIR)/linux.text
-	cat $(IMAGEDIR)/linux.text $(IMAGEDIR)/linux.data $(ROMFSIMG) > $(IMAGE)
+#	cat $(IMAGEDIR)/linux.text $(IMAGEDIR)/linux.data $(ROMFSIMG) > $(IMAGE)

diff -Naur uClinux-dist/vendors/Samsung/44B0/rc vendors/Samsung/44B0/rc
--- uClinux-dist/vendors/Samsung/44B0/rc	2003-05-22 09:10:10.000000000 +0800
+++ uClinux-dailzh/vendors/Samsung/44B0/rc	2003-05-25 02:41:59.000000000 +0800
@@ -1,13 +1,16 @@
 hostname Samsung
 /bin/expand /etc/ramfs.img /dev/ram0
+/bin/expand /etc/ramfs2048.img /dev/ram1
 mount -t proc proc /proc
 mount -t ext2 /dev/ram0 /var
+mount -t ext2 /dev/ram1 /ramdisk
+chmod 777 /ramdisk
 mkdir /var/config
 mkdir /var/tmp
 mkdir /var/log
 mkdir /var/run
 mkdir /var/lock
-cat /etc/motd
 ifconfig lo 127.0.0.1
 route add -net 127.0.0.0 netmask 255.255.255.0 lo
-dhcpcd &
+ifconfig eth0 192.168.168.101 netmask 255.255.255.0 up
+cat /etc/motd
